package com.android.server.pm;

import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.AppOpsManager;
import android.app.BroadcastOptions;
import android.app.IActivityManager;
import android.app.IApplicationThread;
import android.app.ResourcesManager;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.SecurityLog;
import android.app.backup.IBackupManager;
import android.common.HwFrameworkFactory;
import android.common.HwFrameworkSecurityPartsFactory;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.AppsQueryHelper;
import android.content.pm.AuxiliaryResolveInfo;
import android.content.pm.ChangedPackages;
import android.content.pm.ComponentInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.IDexModuleRegisterCallback;
import android.content.pm.IOnPermissionsChangeListener;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageDeleteObserver2;
import android.content.pm.IPackageInstallObserver2;
import android.content.pm.IPackageInstaller;
import android.content.pm.IPackageManager;
import android.content.pm.IPackageManagerNative;
import android.content.pm.IPackageMoveObserver;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.InstantAppInfo;
import android.content.pm.InstantAppRequest;
import android.content.pm.InstrumentationInfo;
import android.content.pm.IntentFilterVerificationInfo;
import android.content.pm.KeySet;
import android.content.pm.ModuleInfo;
import android.content.pm.PackageBackwardCompatibility;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInfoLite;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageList;
import android.content.pm.PackageManager;
import android.content.pm.PackageManagerInternal;
import android.content.pm.PackageParser;
import android.content.pm.PackageStats;
import android.content.pm.PackageUserState;
import android.content.pm.ParceledListSlice;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.SELinuxUtil;
import android.content.pm.ServiceInfo;
import android.content.pm.SharedLibraryInfo;
import android.content.pm.Signature;
import android.content.pm.SuspendDialogInfo;
import android.content.pm.UserInfo;
import android.content.pm.VerifierDeviceIdentity;
import android.content.pm.VerifierInfo;
import android.content.pm.VersionedPackage;
import android.content.pm.dex.ArtManager;
import android.content.pm.dex.DexMetadataHelper;
import android.content.pm.dex.IArtManager;
import android.content.rollback.IRollbackManager;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.hardware.biometrics.fingerprint.V2_1.RequestStatus;
import android.hardware.display.DisplayManager;
import android.hdm.HwDeviceManager;
import android.hwtheme.HwThemeManager;
import android.iawareperf.UniPerf;
import android.installermanager.InstallerMgr;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBackupSessionCallback;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.UserManagerInternal;
import android.os.storage.DiskInfo;
import android.os.storage.IStorageManager;
import android.os.storage.StorageEventListener;
import android.os.storage.StorageManager;
import android.os.storage.StorageManagerInternal;
import android.os.storage.VolumeInfo;
import android.provider.DeviceConfig;
import android.provider.MediaStore;
import android.provider.Settings;
import android.security.KeyStore;
import android.security.SystemKeyStore;
import android.system.ErrnoException;
import android.system.Os;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Base64;
import android.util.ByteStringUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.ExceptionUtils;
import android.util.Flog;
import android.util.IntArray;
import android.util.Log;
import android.util.LogPrinter;
import android.util.LongSparseArray;
import android.util.LongSparseLongArray;
import android.util.MathUtils;
import android.util.PackageUtils;
import android.util.Pair;
import android.util.PrintStreamPrinter;
import android.util.PrintWriterPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.util.StatsLog;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.util.jar.StrictJarFile;
import android.util.proto.ProtoOutputStream;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.IntentForwarderActivity;
import com.android.internal.app.ResolverActivity;
import com.android.internal.content.NativeLibraryHelper;
import com.android.internal.content.PackageHelper;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.SomeArgs;
import com.android.internal.os.ZygoteInit;
import com.android.internal.telephony.CarrierAppUtils;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.ConcurrentUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.FunctionalUtils;
import com.android.internal.util.IndentingPrintWriter;
import com.android.internal.util.IntPair;
import com.android.internal.util.Preconditions;
import com.android.internal.util.function.TriFunction;
import com.android.server.AttributeCache;
import com.android.server.BatteryService;
import com.android.server.DeviceIdleController;
import com.android.server.EventLogTags;
import com.android.server.HwServiceExFactory;
import com.android.server.HwServiceFactory;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.PackageWatchdog;
import com.android.server.ServiceThread;
import com.android.server.SystemConfig;
import com.android.server.SystemServerInitThreadPool;
import com.android.server.am.HwBroadcastRadarUtil;
import com.android.server.backup.BackupAgentTimeoutParameters;
import com.android.server.devicepolicy.HwLog;
import com.android.server.job.controllers.JobStatus;
import com.android.server.net.NetworkPolicyManagerInternal;
import com.android.server.net.watchlist.WatchlistLoggingHandler;
import com.android.server.pm.CompilerStats;
import com.android.server.pm.Installer;
import com.android.server.pm.PackageDexOptimizer;
import com.android.server.pm.PackageInstallerService;
import com.android.server.pm.PackageManagerService;
import com.android.server.pm.ParallelPackageParser;
import com.android.server.pm.Settings;
import com.android.server.pm.dex.ArtManagerService;
import com.android.server.pm.dex.DexManager;
import com.android.server.pm.dex.DexoptOptions;
import com.android.server.pm.dex.PackageDexUsage;
import com.android.server.pm.dex.ViewCompiler;
import com.android.server.pm.permission.BasePermission;
import com.android.server.pm.permission.DefaultPermissionGrantPolicy;
import com.android.server.pm.permission.PermissionManagerService;
import com.android.server.pm.permission.PermissionManagerServiceInternal;
import com.android.server.pm.permission.PermissionsState;
import com.android.server.security.VerityUtils;
import com.android.server.slice.SliceClientPermissions;
import com.android.server.storage.DeviceStorageMonitorInternal;
import com.android.server.usage.AppStandbyController;
import com.android.server.usage.UnixCalendar;
import com.android.server.usb.descriptors.UsbTerminalTypes;
import com.android.server.utils.PriorityDump;
import com.android.server.wm.ActivityTaskManagerInternal;
import com.huawei.android.content.pm.HwHepPackageInfo;
import com.huawei.android.content.pm.IExtServiceProvider;
import com.huawei.android.content.pm.IHwPackageManager;
import com.huawei.android.permission.ZosPermissionAdapter;
import dalvik.system.CloseGuard;
import dalvik.system.VMRuntime;
import huawei.android.app.HwCustEmergDataManager;
import huawei.android.security.IHwBehaviorCollectManager;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.security.DigestException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import libcore.io.IoUtils;
import libcore.util.EmptyArray;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class PackageManagerService extends AbsPackageManagerService implements PackageSender, IHwPackageManagerInner {
    private static final String ATTR_IS_GRANTED = "g";
    private static final String ATTR_PACKAGE_NAME = "pkg";
    private static final String ATTR_PERMISSION_NAME = "name";
    private static final String ATTR_REVOKE_ON_UPGRADE = "rou";
    private static final String ATTR_USER_FIXED = "fixed";
    private static final String ATTR_USER_SET = "set";
    private static final int BLUETOOTH_UID = 1002;
    static final long BROADCAST_DELAY = 1000;
    private static final long BROADCAST_DELAY_DURING_STARTUP = 10000;
    private static final String BROADCAST_INTENT_VALUE = "value";
    static final int CHECK_PENDING_VERIFICATION = 16;
    static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
    public static final String COMPRESSED_EXTENSION = ".gz";
    private static final int DDMP_UID = 5511;
    private static final boolean DEBUG_ABI_SELECTION = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_APP_DATA = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_BACKUP = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_BROADCASTS = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_COMPRESSION = Build.IS_DEBUGGABLE;
    public static final boolean DEBUG_DEXOPT = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_DOMAIN_VERIFICATION = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_GUNSTALL = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_INSTALL = HwPackageManagerServiceUtils.DEBUG_FLAG;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_INSTANT = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_INTENT_MATCHING = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_PACKAGE_INFO = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_PACKAGE_SCANNING = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_PERMISSIONS = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_PREFERRED = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_REMOVE = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_SD_INSTALL = false;
    public static final boolean DEBUG_SETTINGS = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_SHARED_LIBRARIES = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_UPGRADE = HwPackageManagerServiceUtils.DEBUG_FLAG;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_VERIFY = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final long DEFAULT_ENABLE_ROLLBACK_TIMEOUT_MILLIS = 10000;
    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 259200000;
    private static final boolean DEFAULT_PACKAGE_PARSER_CACHE_ENABLED = true;
    private static final long DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD = 7200000;
    private static final int DEFAULT_VERIFICATION_RESPONSE = 1;
    private static final long DEFAULT_VERIFICATION_TIMEOUT = 10000;
    private static final boolean DEFAULT_VERIFY_ENABLE = true;
    static final int DEFERRED_NO_KILL_INSTALL_OBSERVER = 24;
    static final int DEFERRED_NO_KILL_INSTALL_OBSERVER_DELAY_MS = 500;
    static final int DEFERRED_NO_KILL_POST_DELETE = 23;
    static final int DEFERRED_NO_KILL_POST_DELETE_DELAY_MS = 3000;
    private static final int DMSDPDEVICE_UID = 5512;
    /* access modifiers changed from: private */
    public static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final boolean ENABLE_FREE_CACHE_V2 = SystemProperties.getBoolean("fw.free_cache_v2", true);
    static final int ENABLE_ROLLBACK_STATUS = 21;
    static final int ENABLE_ROLLBACK_TIMEOUT = 22;
    private static final int FREQUEBTLY_DELETE_PACKAGE_BASELINE = 5;
    private static final boolean HIDE_EPHEMERAL_APIS = false;
    static final int INIT_COPY = 5;
    private static final String[] INSTANT_APP_BROADCAST_PERMISSION = {"android.permission.ACCESS_INSTANT_APPS"};
    static final int INSTANT_APP_RESOLUTION_PHASE_TWO = 20;
    static final int INTENT_FILTER_VERIFIED = 18;
    private static boolean IS_BOPD = SystemProperties.getBoolean("sys.bopd", false);
    private static final String KILL_APP_REASON_GIDS_CHANGED = "permission grant or revoke changed gids";
    private static final String KILL_APP_REASON_PERMISSIONS_REVOKED = "permissions revoked";
    private static final int LOG_UID = 1007;
    private static final String MAPLE_DECOUPLE_CACHE_ENABLE = "maple.decouple.cache.enable";
    private static final boolean MAPLE_ENABLE = "1".equals(SystemProperties.get("ro.maple.enable", "0"));
    private static final ArrayMap<String, Boolean> MDM_SYS_APP_PREALOAD_LIST = new ArrayMap<>();
    private static final int NETWORKSTACK_UID = 1073;
    private static final int NFC_UID = 1027;
    private static final String ODM_OVERLAY_DIR = "/odm/overlay";
    private static final String OEM_OVERLAY_DIR = "/oem/overlay";
    private static final String PACKAGE_MIME_TYPE = "application/vnd.android.package-archive";
    private static final String PACKAGE_SCHEME = "package";
    static final int PACKAGE_VERIFIED = 15;
    public static final String PLATFORM_PACKAGE_NAME = "android";
    static final int POST_INSTALL = 9;
    private static final String PRECOMPILE_LAYOUTS = "pm.precompile_layouts";
    private static final int PRIME_DOMAIN_DEFAULT = 0;
    private static final int PRIME_DOMAIN_UPGRADE = 1;
    private static final String PRODUCT_OVERLAY_DIR = "/product/overlay";
    private static final String PRODUCT_SERVICES_OVERLAY_DIR = "/product_services/overlay";
    private static final String PROPERTY_ENABLE_ROLLBACK_TIMEOUT_MILLIS = "enable_rollback_timeout";
    private static final int RADIO_UID = 1001;
    public static final int REASON_AB_OTA = 4;
    public static final int REASON_BACKGROUND_DEXOPT = 3;
    public static final int REASON_BOOT = 1;
    public static final int REASON_FIRST_BOOT = 0;
    public static final int REASON_INACTIVE_PACKAGE_DOWNGRADE = 5;
    public static final int REASON_INSTALL = 2;
    public static final int REASON_LAST = 6;
    public static final int REASON_SHARED = 6;
    public static final int REASON_UNKNOWN = -1;
    static final int SCAN_AS_FULL_APP = 32768;
    static final int SCAN_AS_INSTANT_APP = 16384;
    static final int SCAN_AS_ODM = 8388608;
    static final int SCAN_AS_OEM = 524288;
    static final int SCAN_AS_PRIVILEGED = 262144;
    static final int SCAN_AS_PRODUCT = 2097152;
    static final int SCAN_AS_PRODUCT_SERVICES = 4194304;
    static final int SCAN_AS_SYSTEM = 131072;
    static final int SCAN_AS_VENDOR = 1048576;
    static final int SCAN_AS_VIRTUAL_PRELOAD = 65536;
    static final int SCAN_BOOTING = 16;
    static final int SCAN_CHECK_ONLY = 1024;
    static final int SCAN_DONT_KILL_APP = 2048;
    static final int SCAN_FIRST_BOOT_OR_UPGRADE = 8192;
    static final int SCAN_IGNORE_FROZEN = 4096;
    static final int SCAN_INITIAL = 512;
    static final int SCAN_MOVE = 256;
    static final int SCAN_NEW_INSTALL = 4;
    static final int SCAN_NO_DEX = 1;
    static final int SCAN_REQUIRE_KNOWN = 128;
    static final int SCAN_UPDATE_SIGNATURE = 2;
    static final int SCAN_UPDATE_TIME = 8;
    private static final String SD_ENCRYPTION_ALGORITHM = "AES";
    private static final String SD_ENCRYPTION_KEYSTORE_NAME = "AppsOnSD";
    static final int SEND_PENDING_BROADCAST = 1;
    private static final int SE_UID = 1068;
    private static final int SHELL_UID = 2000;
    static final int START_INTENT_FILTER_VERIFICATIONS = 17;
    private static final String STATIC_SHARED_LIB_DELIMITER = "_";
    public static final String STUB_SUFFIX = "-Stub";
    private static final String SUW_FRP_STATE = "hw_suw_frp_state";
    private static final String SYSTEM_MANAGER_PERMISSION = "com.huawei.systemmanager.permission.ACCESS_INTERFACE";
    private static final String SYSTEM_ROOT_DIR = "/system";
    private static final int SYSTEM_RUNTIME_GRANT_MASK = 52;
    static final String TAG = "PackageManager";
    private static final String TAG_ALL_GRANTS = "rt-grants";
    private static final String TAG_DEFAULT_APPS = "da";
    private static final String TAG_GRANT = "grant";
    private static final String TAG_INTENT_FILTER_VERIFICATION = "iv";
    private static final String TAG_PERMISSION = "perm";
    private static final String TAG_PERMISSION_BACKUP = "perm-grant-backup";
    private static final String TAG_PREFERRED_BACKUP = "pa";
    private static final int TYPE_ACTIVITY = 1;
    private static final int TYPE_PROVIDER = 4;
    private static final int TYPE_RECEIVER = 2;
    private static final int TYPE_SERVICE = 3;
    private static final int TYPE_UNKNOWN = 0;
    private static final String UPDATE_NOTIFICATION_SUPERWHITELIST = "com.huawei.notificationmanager.superwhitelist";
    private static final int USER_RUNTIME_GRANT_MASK = 11;
    private static final String VENDOR_OVERLAY_DIR = "/vendor/overlay";
    static final long WATCHDOG_TIMEOUT = 600000;
    static final int WRITE_PACKAGE_LIST = 19;
    static final int WRITE_PACKAGE_RESTRICTIONS = 14;
    static final int WRITE_SETTINGS = 13;
    static final int WRITE_SETTINGS_DELAY = 10000;
    static IHwPackageManagerServiceEx mHwPMSEx = null;
    private static final File sAppInstallDir = new File(Environment.getDataDirectory(), "app");
    protected static final File sAppLib32InstallDir = new File(Environment.getDataDirectory(), "app-lib");
    private static final Intent sBrowserIntent = new Intent();
    private static final Comparator<ProviderInfo> sProviderInitOrderSorter = $$Lambda$PackageManagerService$2YJvUTVTCi_lr8H2GsUrtJlWH8.INSTANCE;
    static UserManagerService sUserManager;
    private int callingSessionUid;
    private ActivityManagerInternal mActivityManagerInternal;
    private ActivityTaskManagerInternal mActivityTaskManagerInternal;
    ApplicationInfo mAndroidApplication;
    /* access modifiers changed from: private */
    public final ApexManager mApexManager;
    /* access modifiers changed from: private */
    public AppOpsManager mAppOpsManager;
    final String mAppPredictionServicePackage;
    final ArtManagerService mArtManagerService;
    @GuardedBy({"mAvailableFeatures"})
    final ArrayMap<String, FeatureInfo> mAvailableFeatures;
    private File mCacheDir;
    @GuardedBy({"mPackages"})
    final SparseArray<SparseArray<String>> mChangedPackages = new SparseArray<>();
    @GuardedBy({"mPackages"})
    int mChangedPackagesSequenceNumber;
    @GuardedBy({"mPackages"})
    final SparseArray<Map<String, Integer>> mChangedPackagesSequenceNumbers = new SparseArray<>();
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.CheckPermissionDelegate mCheckPermissionDelegate;
    private final CompilerStats mCompilerStats;
    private final ComponentResolver mComponentResolver;
    final String mConfiguratorPackage;
    final Context mContext;
    protected boolean mCotaFlag = false;
    ComponentName mCustomResolverComponentName;
    final int mDefParseFlags;
    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public PackageManagerInternal.DefaultBrowserProvider mDefaultBrowserProvider;
    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public PackageManagerInternal.DefaultDialerProvider mDefaultDialerProvider;
    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public PackageManagerInternal.DefaultHomeProvider mDefaultHomeProvider;
    protected final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;
    @GuardedBy({"mPackages"})
    private final SparseIntArray mDefaultPermissionsGrantedUsers = new SparseIntArray();
    private ArrayList<String> mDelPackageList;
    /* access modifiers changed from: private */
    public Set<Integer> mDeleteCheckingSet = new HashSet();
    /* access modifiers changed from: private */
    public Map<Integer, Set<Long>> mDeletePackageCallMap = new HashMap();
    private DeviceIdleController.LocalService mDeviceIdleController;
    private final DexManager mDexManager;
    @GuardedBy({"mPackages"})
    private boolean mDexOptDialogShown;
    /* access modifiers changed from: private */
    public ArraySet<Integer> mDirtyUsers = new ArraySet<>();
    final String mDocumenterPackage;
    /* access modifiers changed from: private */
    public final ArraySet<String> mExistingSystemPackages = new ArraySet<>();
    private final ArrayMap<String, File> mExpectingBetter = new ArrayMap<>();
    PackageManagerInternal.ExternalSourcesPolicy mExternalSourcesPolicy;
    final boolean mFactoryTest;
    boolean mFirstBoot;
    @GuardedBy({"mPackages"})
    final ArraySet<String> mFrozenPackages = new ArraySet<>();
    final PackageHandler mHandler;
    final ServiceThread mHandlerThread;
    volatile boolean mHasSystemUidErrors;
    HwInnerPackageManagerService mHwInnerService;
    final String mIncidentReportApproverPackage;
    final Object mInstallLock = new Object();
    @GuardedBy({"mInstallLock"})
    final Installer mInstaller;
    final PackageInstallerService mInstallerService;
    ActivityInfo mInstantAppInstallerActivity;
    final ResolveInfo mInstantAppInstallerInfo = new ResolveInfo();
    /* access modifiers changed from: private */
    public final InstantAppRegistry mInstantAppRegistry;
    final InstantAppResolverConnection mInstantAppResolverConnection;
    final ComponentName mInstantAppResolverSettingsComponent;
    final ArrayMap<ComponentName, PackageParser.Instrumentation> mInstrumentation = new ArrayMap<>();
    final SparseArray<IntentFilterVerificationState> mIntentFilterVerificationStates = new SparseArray<>();
    private int mIntentFilterVerificationToken = 0;
    /* access modifiers changed from: private */
    public final IntentFilterVerifier<PackageParser.ActivityIntentInfo> mIntentFilterVerifier;
    private final ComponentName mIntentFilterVerifierComponent;
    protected boolean mIsDefaultGoogleCalendar = SystemProperties.getBoolean("ro.default_GoogleCalendar", false);
    protected boolean mIsDefaultPreferredActivityChanged = false;
    final boolean mIsEmuiVersionUpgrade;
    boolean mIsPackageScanMultiThread = SystemProperties.getBoolean("ro.config.hw_packagescan_multi", false);
    final boolean mIsPreNMR1Upgrade;
    final boolean mIsPreNUpgrade;
    final boolean mIsPrePUpgrade;
    final boolean mIsPreQUpgrade;
    final boolean mIsUpgrade;
    @GuardedBy({"mPackages"})
    final SparseIntArray mIsolatedOwners = new SparseIntArray();
    /* access modifiers changed from: private */
    public List<String> mKeepUninstalledPackages;
    @GuardedBy({"mLoadedVolumes"})
    final ArraySet<String> mLoadedVolumes = new ArraySet<>();
    private boolean mMediaMounted;
    final DisplayMetrics mMetrics;
    /* access modifiers changed from: private */
    public final ModuleInfoProvider mModuleInfoProvider;
    /* access modifiers changed from: private */
    public final MoveCallbacks mMoveCallbacks;
    int mNextInstallToken;
    private AtomicInteger mNextMoveId = new AtomicInteger();
    private final Map<String, Pair<PackageInstalledInfo, IPackageInstallObserver2>> mNoKillInstallObservers = Collections.synchronizedMap(new HashMap());
    /* access modifiers changed from: private */
    public final OnPermissionChangeListeners mOnPermissionChangeListeners;
    final boolean mOnlyCore;
    protected final PackageDexOptimizer mPackageDexOptimizer;
    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public final ArraySet<PackageManagerInternal.PackageListObserver> mPackageListObservers = new ArraySet<>();
    final PackageParser.Callback mPackageParserCallback = new PackageParserCallback();
    private final PackageUsage mPackageUsage;
    @GuardedBy({"mPackages"})
    final ArrayMap<String, PackageParser.Package> mPackages = new ArrayMap<>();
    final ParallelPackageParserCallback mParallelPackageParserCallback = new ParallelPackageParserCallback();
    final PendingPackageBroadcasts mPendingBroadcasts = new PendingPackageBroadcasts();
    final SparseArray<InstallParams> mPendingEnableRollback = new SparseArray<>();
    private int mPendingEnableRollbackToken = 0;
    final SparseArray<PackageVerificationState> mPendingVerification = new SparseArray<>();
    private int mPendingVerificationToken = 0;
    protected PermissionManagerServiceInternal.PermissionCallback mPermissionCallback;
    protected final PermissionManagerServiceInternal mPermissionManager;
    PackageParser.Package mPlatformPackage;
    private Future<?> mPrepareAppDataFuture;
    private final ProcessLoggingHandler mProcessLoggingHandler;
    boolean mPromoteSystemApps;
    @GuardedBy({"mProtectedBroadcasts"})
    final ArraySet<String> mProtectedBroadcasts = new ArraySet<>();
    final ProtectedPackages mProtectedPackages;
    final String mRequiredInstallerPackage;
    final String mRequiredPermissionControllerPackage;
    final String mRequiredUninstallerPackage;
    final String mRequiredVerifierPackage;
    final ActivityInfo mResolveActivity = new ActivityInfo();
    ComponentName mResolveComponentName;
    final ResolveInfo mResolveInfo = new ResolveInfo();
    boolean mResolverReplaced = false;
    final SparseArray<PostInstallData> mRunningInstalls = new SparseArray<>();
    volatile boolean mSafeMode;
    final int mSdkVersion = Build.VERSION.SDK_INT;
    final String[] mSeparateProcesses;
    private long mServiceStartWithDelay;
    final String mServicesSystemSharedLibraryPackageName;
    @GuardedBy({"mPackages"})
    final Settings mSettings;
    final String mSetupWizardPackage;
    final ArrayMap<String, LongSparseArray<SharedLibraryInfo>> mSharedLibraries = new ArrayMap<>();
    final String mSharedSystemSharedLibraryPackageName;
    final ArrayMap<String, LongSparseArray<SharedLibraryInfo>> mStaticLibsByDeclaringPackage = new ArrayMap<>();
    private StorageEventListener mStorageListener;
    private StorageManagerInternal mStorageManagerInternal;
    final String mStorageManagerPackage;
    volatile boolean mSystemReady;
    final String mSystemTextClassifierPackage;
    protected ArrayList<PackageParser.Package> mTempPkgList = new ArrayList<>();
    final ArraySet<String> mTransferedPackages = new ArraySet<>();
    private UserManagerInternal mUserManagerInternal;
    private final SparseBooleanArray mUserNeedsBadging = new SparseBooleanArray();
    private final ViewCompiler mViewCompiler;
    /* access modifiers changed from: private */
    public volatile SparseBooleanArray mWebInstantAppsDisabled = new SparseBooleanArray();
    final String mWellbeingPackage;
    int tSdkVersion = -1;

    /* access modifiers changed from: private */
    public interface BlobXmlRestorer {
        void apply(XmlPullParser xmlPullParser, int i) throws IOException, XmlPullParserException;
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ComponentType {
    }

    /* access modifiers changed from: private */
    public interface IntentFilterVerifier<T extends IntentFilter> {
        boolean addOneIntentFilterVerification(int i, int i2, int i3, T t, String str);

        void receiveVerificationResponse(int i);

        void startVerifications(int i);
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ScanFlags {
    }

    static /* synthetic */ int access$3408(PackageManagerService x0) {
        int i = x0.mPendingVerificationToken;
        x0.mPendingVerificationToken = i + 1;
        return i;
    }

    static /* synthetic */ int access$3708(PackageManagerService x0) {
        int i = x0.mPendingEnableRollbackToken;
        x0.mPendingEnableRollbackToken = i + 1;
        return i;
    }

    static {
        sBrowserIntent.setAction("android.intent.action.VIEW");
        sBrowserIntent.addCategory("android.intent.category.BROWSABLE");
        sBrowserIntent.setData(Uri.parse("http:"));
        sBrowserIntent.addFlags(512);
    }

    class PackageParserCallback implements PackageParser.Callback {
        PackageParserCallback() {
        }

        public final boolean hasFeature(String feature) {
            return PackageManagerService.this.hasSystemFeature(feature, 0);
        }

        /* access modifiers changed from: package-private */
        public final List<PackageParser.Package> getStaticOverlayPackages(Collection<PackageParser.Package> allPackages, String targetPackageName) {
            if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(targetPackageName)) {
                return null;
            }
            List<PackageParser.Package> overlayPackages = null;
            for (PackageParser.Package p : allPackages) {
                if (targetPackageName.equals(p.mOverlayTarget) && p.mOverlayIsStatic) {
                    if (overlayPackages == null) {
                        overlayPackages = new ArrayList<>();
                    }
                    overlayPackages.add(p);
                }
            }
            if (overlayPackages != null) {
                overlayPackages.sort(Comparator.comparingInt($$Lambda$PackageManagerService$PackageParserCallback$xinvBJUpQse3J1IBBKjvYTIW8MQ.INSTANCE));
            }
            return overlayPackages;
        }

        /* access modifiers changed from: package-private */
        public final String[] getStaticOverlayPaths(List<PackageParser.Package> overlayPackages, String targetPath) {
            if (overlayPackages == null || overlayPackages.isEmpty()) {
                return null;
            }
            List<String> overlayPathList = null;
            for (PackageParser.Package overlayPackage : overlayPackages) {
                if (targetPath == null) {
                    if (overlayPathList == null) {
                        overlayPathList = new ArrayList<>();
                    }
                    overlayPathList.add(overlayPackage.baseCodePath);
                } else {
                    try {
                        PackageManagerService.this.mInstaller.idmap(targetPath, overlayPackage.baseCodePath, UserHandle.getSharedAppGid(UserHandle.getUserGid(0)));
                        if (overlayPathList == null) {
                            overlayPathList = new ArrayList<>();
                        }
                        overlayPathList.add(overlayPackage.baseCodePath);
                    } catch (Installer.InstallerException e) {
                        Slog.e(PackageManagerService.TAG, "Failed to generate idmap for " + targetPath + " and " + overlayPackage.baseCodePath);
                    }
                }
            }
            if (overlayPathList == null) {
                return null;
            }
            return (String[]) overlayPathList.toArray(new String[0]);
        }

        /* access modifiers changed from: package-private */
        public String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            List<PackageParser.Package> overlayPackages;
            String[] staticOverlayPaths;
            synchronized (PackageManagerService.this.mInstallLock) {
                synchronized (PackageManagerService.this.mPackages) {
                    overlayPackages = getStaticOverlayPackages(PackageManagerService.this.mPackages.values(), targetPackageName);
                }
                staticOverlayPaths = getStaticOverlayPaths(overlayPackages, targetPath);
            }
            return staticOverlayPaths;
        }

        public final String[] getOverlayApks(String targetPackageName) {
            return getStaticOverlayPaths(targetPackageName, (String) null);
        }

        public final String[] getOverlayPaths(String targetPackageName, String targetPath) {
            return getStaticOverlayPaths(targetPackageName, targetPath);
        }
    }

    class ParallelPackageParserCallback extends PackageParserCallback {
        List<PackageParser.Package> mOverlayPackages = null;

        ParallelPackageParserCallback() {
            super();
        }

        /* access modifiers changed from: package-private */
        public void findStaticOverlayPackages() {
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayIsStatic) {
                        if (this.mOverlayPackages == null) {
                            this.mOverlayPackages = new ArrayList();
                        }
                        this.mOverlayPackages.add(p);
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.PackageParserCallback
        public synchronized String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] strArr;
            if (this.mOverlayPackages == null) {
                strArr = null;
            } else {
                strArr = getStaticOverlayPaths(getStaticOverlayPackages(this.mOverlayPackages, targetPackageName), targetPath);
            }
            return strArr;
        }
    }

    private static class IFVerificationParams {
        PackageParser.Package pkg;
        boolean replacing;
        int userId;
        int verifierUid;

        public IFVerificationParams(PackageParser.Package _pkg, boolean _replacing, int _userId, int _verifierUid) {
            this.pkg = _pkg;
            this.replacing = _replacing;
            this.userId = _userId;
            this.verifierUid = _verifierUid;
        }
    }

    private class IntentVerifierProxy implements IntentFilterVerifier<PackageParser.ActivityIntentInfo> {
        private Context mContext;
        private ArrayList<Integer> mCurrentIntentFilterVerifications = new ArrayList<>();
        private ComponentName mIntentFilterVerifierComponent;

        public IntentVerifierProxy(Context context, ComponentName verifierComponent) {
            this.mContext = context;
            this.mIntentFilterVerifierComponent = verifierComponent;
        }

        private String getDefaultScheme() {
            return "https";
        }

        @Override // com.android.server.pm.PackageManagerService.IntentFilterVerifier
        public void startVerifications(int userId) {
            int count = this.mCurrentIntentFilterVerifications.size();
            for (int n = 0; n < count; n++) {
                int verificationId = this.mCurrentIntentFilterVerifications.get(n).intValue();
                IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                String packageName = ivs.getPackageName();
                ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
                int filterCount = filters.size();
                ArraySet<String> domainsSet = new ArraySet<>();
                for (int m = 0; m < filterCount; m++) {
                    domainsSet.addAll(filters.get(m).getHostsList());
                }
                synchronized (PackageManagerService.this.mPackages) {
                    if (PackageManagerService.this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domainsSet) != null) {
                        PackageManagerService.this.scheduleWriteSettingsLocked();
                    }
                }
                sendVerificationRequest(verificationId, ivs);
            }
            this.mCurrentIntentFilterVerifications.clear();
        }

        private void sendVerificationRequest(int verificationId, IntentFilterVerificationState ivs) {
            Intent verificationIntent = new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION");
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_ID", verificationId);
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_URI_SCHEME", getDefaultScheme());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_HOSTS", ivs.getHostsString());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_PACKAGE_NAME", ivs.getPackageName());
            verificationIntent.setComponent(this.mIntentFilterVerifierComponent);
            verificationIntent.addFlags(268435456);
            long whitelistTimeout = PackageManagerService.this.getVerificationTimeout();
            BroadcastOptions options = BroadcastOptions.makeBasic();
            options.setTemporaryAppWhitelistDuration(whitelistTimeout);
            PackageManagerService.this.getDeviceIdleController().addPowerSaveTempWhitelistApp(Process.myUid(), this.mIntentFilterVerifierComponent.getPackageName(), whitelistTimeout, 0, true, "intent filter verifier");
            this.mContext.sendBroadcastAsUser(verificationIntent, UserHandle.SYSTEM, null, options.toBundle());
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Sending IntentFilter verification broadcast");
            }
        }

        @Override // com.android.server.pm.PackageManagerService.IntentFilterVerifier
        public void receiveVerificationResponse(int verificationId) {
            IntentFilterVerificationInfo ivi;
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            boolean verified = ivs.isVerified();
            ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
            int count = filters.size();
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.i(PackageManagerService.TAG, "Received verification response " + verificationId + " for " + count + " filters, verified=" + verified);
            }
            for (int n = 0; n < count; n++) {
                PackageParser.ActivityIntentInfo filter = filters.get(n);
                filter.setVerified(verified);
                if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                    Slog.d(PackageManagerService.TAG, "IntentFilter " + filter.toString() + " verified with result:" + verified + " and hosts:" + ivs.getHostsString());
                }
            }
            PackageManagerService.this.mIntentFilterVerificationStates.remove(verificationId);
            String packageName = ivs.getPackageName();
            synchronized (PackageManagerService.this.mPackages) {
                ivi = PackageManagerService.this.mSettings.getIntentFilterVerificationLPr(packageName);
            }
            if (ivi == null) {
                Slog.w(PackageManagerService.TAG, "IntentFilterVerificationInfo not found for verificationId:" + verificationId + " packageName:" + packageName);
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                if (verified) {
                    ivi.setStatus(2);
                } else {
                    ivi.setStatus(1);
                }
                PackageManagerService.this.scheduleWriteSettingsLocked();
                int userId = ivs.getUserId();
                if (userId != -1) {
                    int userStatus = PackageManagerService.this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                    int updatedStatus = 0;
                    boolean needUpdate = false;
                    if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                        Slog.d(PackageManagerService.TAG, "Updating IntentFilterVerificationInfo for package " + packageName + " verificationId:" + verificationId + " verified=" + verified);
                    }
                    if (userStatus == 0) {
                        if (verified) {
                            updatedStatus = 2;
                        }
                        needUpdate = true;
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Applying update; old=" + userStatus + " new=" + updatedStatus);
                        }
                    } else if (userStatus != 1) {
                        if (userStatus == 2) {
                            if (!verified) {
                                if (!SystemConfig.getInstance().getLinkedApps().contains(packageName)) {
                                    needUpdate = true;
                                    if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                        Slog.d(PackageManagerService.TAG, "Formerly validated but now failing; demoting");
                                    }
                                } else if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                    Slog.d(PackageManagerService.TAG, "Updating bundled package " + packageName + " failed autoVerify, but sysconfig supersedes");
                                }
                            }
                        }
                    } else if (verified) {
                        updatedStatus = 2;
                        needUpdate = true;
                    }
                    if (needUpdate) {
                        PackageManagerService.this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, updatedStatus, userId);
                        PackageManagerService.this.scheduleWritePackageRestrictionsLocked(userId);
                    }
                } else {
                    Slog.i(PackageManagerService.TAG, "autoVerify ignored when installing for all users");
                }
            }
        }

        public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, PackageParser.ActivityIntentInfo filter, String packageName) {
            if (!PackageManagerService.hasValidDomains(filter)) {
                return false;
            }
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            if (ivs == null) {
                ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Adding verification filter for " + packageName + ": " + filter);
            }
            ivs.addFilter(filter);
            return true;
        }

        private IntentFilterVerificationState createDomainVerificationState(int verifierUid, int userId, int verificationId, String packageName) {
            IntentFilterVerificationState ivs = new IntentFilterVerificationState(verifierUid, userId, packageName);
            ivs.setPendingState();
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIntentFilterVerificationStates.append(verificationId, ivs);
                this.mCurrentIntentFilterVerifications.add(Integer.valueOf(verificationId));
            }
            return ivs;
        }
    }

    /* access modifiers changed from: private */
    public static boolean hasValidDomains(PackageParser.ActivityIntentInfo filter) {
        return filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"));
    }

    static class PendingPackageBroadcasts {
        final SparseArray<ArrayMap<String, ArrayList<String>>> mUidMap = new SparseArray<>(2);

        public ArrayList<String> get(int userId, String packageName) {
            return getOrAllocate(userId).get(packageName);
        }

        public void put(int userId, String packageName, ArrayList<String> components) {
            getOrAllocate(userId).put(packageName, components);
        }

        public void remove(int userId, String packageName) {
            ArrayMap<String, ArrayList<String>> packages = this.mUidMap.get(userId);
            if (packages != null) {
                packages.remove(packageName);
            }
        }

        public void remove(int userId) {
            this.mUidMap.remove(userId);
        }

        public int userIdCount() {
            return this.mUidMap.size();
        }

        public int userIdAt(int n) {
            return this.mUidMap.keyAt(n);
        }

        public ArrayMap<String, ArrayList<String>> packagesForUserId(int userId) {
            return this.mUidMap.get(userId);
        }

        public int size() {
            int num = 0;
            for (int i = 0; i < this.mUidMap.size(); i++) {
                num += this.mUidMap.valueAt(i).size();
            }
            return num;
        }

        public void clear() {
            this.mUidMap.clear();
        }

        private ArrayMap<String, ArrayList<String>> getOrAllocate(int userId) {
            ArrayMap<String, ArrayList<String>> map = this.mUidMap.get(userId);
            if (map != null) {
                return map;
            }
            ArrayMap<String, ArrayList<String>> map2 = new ArrayMap<>();
            this.mUidMap.put(userId, map2);
            return map2;
        }
    }

    static class PostInstallData {
        public final InstallArgs args;
        public final Runnable mPostInstallRunnable;
        public final PackageInstalledInfo res;

        PostInstallData(InstallArgs _a, PackageInstalledInfo _r, Runnable postInstallRunnable) {
            this.args = _a;
            this.res = _r;
            this.mPostInstallRunnable = postInstallRunnable;
        }
    }

    class PackageHandler extends Handler {
        PackageHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            try {
                doHandleMessage(msg);
            } finally {
                Process.setThreadPriority(10);
            }
        }

        /* JADX INFO: Multiple debug info for r0v31 int: [D('verificationId' int), D('params' com.android.server.pm.PackageManagerService$IFVerificationParams)] */
        /* access modifiers changed from: package-private */
        /* JADX WARNING: Code restructure failed: missing block: B:190:0x05c1, code lost:
            r3 = 0;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:191:0x05c2, code lost:
            if (r3 >= r11) goto L_0x05d2;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:192:0x05c4, code lost:
            r29.this$0.sendPackageChangedBroadcast(r0[r3], true, r9[r3], r10[r3]);
            r3 = r3 + 1;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:193:0x05d2, code lost:
            android.os.Process.setThreadPriority(10);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:205:?, code lost:
            return;
         */
        public void doHandleMessage(Message msg) {
            int i;
            ArrayList whitelistedRestrictedPermissions;
            int i2 = msg.what;
            int childCount = 0;
            if (i2 == 1) {
                Process.setThreadPriority(0);
                synchronized (PackageManagerService.this.mPackages) {
                    int size = PackageManagerService.this.mPendingBroadcasts.size();
                    if (size > 0) {
                        String[] packages = new String[size];
                        ArrayList<String>[] components = new ArrayList[size];
                        int[] uids = new int[size];
                        int i3 = 0;
                        while (childCount < PackageManagerService.this.mPendingBroadcasts.userIdCount()) {
                            int packageUserId = PackageManagerService.this.mPendingBroadcasts.userIdAt(childCount);
                            Iterator<Map.Entry<String, ArrayList<String>>> it = PackageManagerService.this.mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                            while (it.hasNext() && i3 < size) {
                                Map.Entry<String, ArrayList<String>> ent = it.next();
                                packages[i3] = ent.getKey();
                                components[i3] = ent.getValue();
                                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(ent.getKey());
                                if (ps != null) {
                                    i = UserHandle.getUid(packageUserId, ps.appId);
                                } else {
                                    i = -1;
                                }
                                uids[i3] = i;
                                i3++;
                            }
                            childCount++;
                        }
                        PackageManagerService.this.mPendingBroadcasts.clear();
                    }
                }
            } else if (i2 == 5) {
                HandlerParams params = (HandlerParams) msg.obj;
                if (params != null) {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "init_copy: " + params);
                    }
                    Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                    Trace.traceBegin(262144, "startCopy");
                    params.startCopy();
                    Trace.traceEnd(262144);
                }
            } else if (i2 != 9) {
                switch (i2) {
                    case 13:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(13);
                            removeMessages(14);
                            PackageManagerService.this.mSettings.writeLPr();
                            PackageManagerService.this.mDirtyUsers.clear();
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 14:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(14);
                            Iterator it2 = PackageManagerService.this.mDirtyUsers.iterator();
                            while (it2.hasNext()) {
                                PackageManagerService.this.mSettings.writePackageRestrictionsLPr(((Integer) it2.next()).intValue());
                            }
                            PackageManagerService.this.mDirtyUsers.clear();
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 15:
                        int verificationId = msg.arg1;
                        PackageVerificationState state = PackageManagerService.this.mPendingVerification.get(verificationId);
                        if (state == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid verification token " + verificationId + " received");
                            return;
                        }
                        PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                        state.setVerifierResponse(response.callerUid, response.code);
                        if (state.isVerificationComplete()) {
                            PackageManagerService.this.mPendingVerification.remove(verificationId);
                            InstallParams params2 = state.getInstallParams();
                            InstallArgs args = params2.mArgs;
                            Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                            if (state.isInstallAllowed()) {
                                PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, response.code, args.getUser());
                            } else {
                                params2.setReturnCode(-22);
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId);
                            params2.handleVerificationFinished();
                            return;
                        }
                        return;
                    case 16:
                        int verificationId2 = msg.arg1;
                        PackageVerificationState state2 = PackageManagerService.this.mPendingVerification.get(verificationId2);
                        if (state2 != null && !state2.timeoutExtended()) {
                            InstallParams params3 = state2.getInstallParams();
                            InstallArgs args2 = params3.mArgs;
                            Uri originUri2 = Uri.fromFile(args2.origin.resolvedFile);
                            Slog.i(PackageManagerService.TAG, "Verification timed out for " + originUri2);
                            PackageManagerService.this.mPendingVerification.remove(verificationId2);
                            UserHandle user = args2.getUser();
                            if (PackageManagerService.this.getDefaultVerificationResponse(user) == 1) {
                                Slog.i(PackageManagerService.TAG, "Continuing with installation of " + originUri2);
                                state2.setVerifierResponse(Binder.getCallingUid(), 2);
                                PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, 1, user);
                            } else {
                                PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, -1, user);
                                params3.setReturnCode(-22);
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId2);
                            params3.handleVerificationFinished();
                            return;
                        }
                        return;
                    case 17:
                        IFVerificationParams params4 = (IFVerificationParams) msg.obj;
                        PackageManagerService.this.verifyIntentFiltersIfNeeded(params4.userId, params4.verifierUid, params4.replacing, params4.pkg);
                        return;
                    case 18:
                        int verificationId3 = msg.arg1;
                        IntentFilterVerificationState state3 = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId3);
                        if (state3 == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid IntentFilter verification token " + verificationId3 + " received");
                            return;
                        }
                        int userId = state3.getUserId();
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Processing IntentFilter verification with token:" + verificationId3 + " and userId:" + userId);
                        }
                        IntentFilterVerificationResponse response2 = (IntentFilterVerificationResponse) msg.obj;
                        state3.setVerifierResponse(response2.callerUid, response2.code);
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " and userId:" + userId + " is settings verifier response with response code:" + response2.code);
                        }
                        if (response2.code == -1 && PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Domains failing verification: " + response2.getFailedDomainsString());
                        }
                        if (state3.isVerificationComplete()) {
                            PackageManagerService.this.mIntentFilterVerifier.receiveVerificationResponse(verificationId3);
                            return;
                        } else if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " was not said to be complete");
                            return;
                        } else {
                            return;
                        }
                    case 19:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(19);
                            PackageManagerService.this.mSettings.writePackageListLPr(msg.arg1);
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 20:
                        InstantAppResolver.doInstantAppResolutionPhaseTwo(PackageManagerService.this.mContext, PackageManagerService.this.mInstantAppResolverConnection, (InstantAppRequest) msg.obj, PackageManagerService.this.mInstantAppInstallerActivity, PackageManagerService.this.mHandler);
                        return;
                    case 21:
                        int enableRollbackToken = msg.arg1;
                        int enableRollbackCode = msg.arg2;
                        InstallParams params5 = PackageManagerService.this.mPendingEnableRollback.get(enableRollbackToken);
                        if (params5 == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid rollback enabled token " + enableRollbackToken + " received");
                            return;
                        }
                        PackageManagerService.this.mPendingEnableRollback.remove(enableRollbackToken);
                        if (enableRollbackCode != 1) {
                            Uri originUri3 = Uri.fromFile(params5.mArgs.origin.resolvedFile);
                            Slog.w(PackageManagerService.TAG, "Failed to enable rollback for " + originUri3);
                            Slog.w(PackageManagerService.TAG, "Continuing with installation of " + originUri3);
                        }
                        Trace.asyncTraceEnd(262144, "enable_rollback", enableRollbackToken);
                        params5.handleRollbackEnabled();
                        return;
                    case 22:
                        int enableRollbackToken2 = msg.arg1;
                        InstallParams params6 = PackageManagerService.this.mPendingEnableRollback.get(enableRollbackToken2);
                        if (params6 != null) {
                            Uri originUri4 = Uri.fromFile(params6.mArgs.origin.resolvedFile);
                            Slog.w(PackageManagerService.TAG, "Enable rollback timed out for " + originUri4);
                            PackageManagerService.this.mPendingEnableRollback.remove(enableRollbackToken2);
                            Slog.w(PackageManagerService.TAG, "Continuing with installation of " + originUri4);
                            Trace.asyncTraceEnd(262144, "enable_rollback", enableRollbackToken2);
                            params6.handleRollbackEnabled();
                            Intent rollbackTimeoutIntent = new Intent("android.intent.action.CANCEL_ENABLE_ROLLBACK");
                            rollbackTimeoutIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_TOKEN", enableRollbackToken2);
                            rollbackTimeoutIntent.addFlags(DumpState.DUMP_HANDLE);
                            PackageManagerService.this.mContext.sendBroadcastAsUser(rollbackTimeoutIntent, UserHandle.SYSTEM, "android.permission.PACKAGE_ROLLBACK_AGENT");
                            return;
                        }
                        return;
                    case PackageManagerService.DEFERRED_NO_KILL_POST_DELETE /*{ENCODED_INT: 23}*/:
                        synchronized (PackageManagerService.this.mInstallLock) {
                            InstallArgs args3 = (InstallArgs) msg.obj;
                            if (args3 != null) {
                                args3.doPostDeleteLI(true);
                            }
                        }
                        return;
                    case PackageManagerService.DEFERRED_NO_KILL_INSTALL_OBSERVER /*{ENCODED_INT: 24}*/:
                        String packageName = (String) msg.obj;
                        if (packageName != null) {
                            PackageManagerService.this.notifyInstallObserver(packageName);
                            return;
                        }
                        return;
                    default:
                        return;
                }
            } else {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Log.v(PackageManagerService.TAG, "Handling post-install for " + msg.arg1);
                }
                PostInstallData data = PackageManagerService.this.mRunningInstalls.get(msg.arg1);
                boolean didRestore = msg.arg2 != 0;
                PackageManagerService.this.mRunningInstalls.delete(msg.arg1);
                if (data != null && data.mPostInstallRunnable != null) {
                    data.mPostInstallRunnable.run();
                } else if (data != null) {
                    InstallArgs args4 = data.args;
                    PackageInstalledInfo parentRes = data.res;
                    if (parentRes != null) {
                        HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(1, parentRes.uid, 0, parentRes.name, parentRes.installerPackageName);
                    }
                    boolean grantPermissions = (args4.installFlags & 256) != 0;
                    boolean killApp = (args4.installFlags & 4096) == 0;
                    boolean virtualPreload = (args4.installFlags & 65536) != 0;
                    PackageManagerService.mHwPMSEx.addGrantedInstalledPkg(parentRes.pkg, grantPermissions);
                    String[] grantedPermissions = args4.installGrantPermissions;
                    if ((args4.installFlags & 4194304) == 0 || parentRes.pkg == null) {
                        whitelistedRestrictedPermissions = args4.whitelistedRestrictedPermissions;
                    } else {
                        whitelistedRestrictedPermissions = parentRes.pkg.requestedPermissions;
                    }
                    PackageManagerService.this.handlePackagePostInstall(parentRes, grantPermissions, killApp, virtualPreload, grantedPermissions, whitelistedRestrictedPermissions, didRestore, args4.installerPackageName, args4.observer);
                    if (parentRes.addedChildPackages != null) {
                        childCount = parentRes.addedChildPackages.size();
                    }
                    for (int i4 = 0; i4 < childCount; i4++) {
                        PackageManagerService.this.handlePackagePostInstall(parentRes.addedChildPackages.valueAt(i4), grantPermissions, killApp, virtualPreload, grantedPermissions, whitelistedRestrictedPermissions, false, args4.installerPackageName, args4.observer);
                    }
                    if (!(parentRes.pkg == null || (PackageManagerService.isSystemApp(parentRes.pkg) && (parentRes.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) == 0 && (parentRes.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0))) {
                        PackageManagerService.this.parseInstalledPkgInfo(args4, parentRes);
                    }
                    if (args4.traceMethod != null) {
                        Trace.asyncTraceEnd(262144, args4.traceMethod, args4.traceCookie);
                    }
                } else if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "Nothing to do for post-install token " + msg.arg1);
                }
                Trace.asyncTraceEnd(262144, "postInstall", msg.arg1);
            }
        }
    }

    private void updateDisablePluginsLocked(PackageParser.Package pkg, List<String> removeSplitList) {
        ArrayList<String> disablePlugins;
        String[] installedSplitNames;
        if (pkg != null) {
            try {
                if (pkg.codePath == null) {
                    return;
                }
                if (pkg.codePath.startsWith(sAppInstallDir.getCanonicalPath())) {
                    String packageName = pkg.packageName;
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageName);
                    if (disabledPs != null && disabledPs.pkg != null) {
                        if ((disabledPs.hw_extra_flags & 1) != 0) {
                            Slog.i(TAG, packageName + " disablePlugins: " + Arrays.toString(disabledPs.disablePlugins));
                            if (disabledPs.disablePlugins == null || disabledPs.disablePlugins.length <= 0) {
                                disablePlugins = new ArrayList<>();
                            } else {
                                disablePlugins = new ArrayList<>(Arrays.asList(disabledPs.disablePlugins));
                            }
                            String[] presetSplitNames = disabledPs.pkg.splitNames;
                            ArrayList<String> presetSplitList = new ArrayList<>(Arrays.asList(presetSplitNames));
                            for (int i = 0; i < presetSplitNames.length; i++) {
                                String splitName = presetSplitNames[i];
                                boolean isPluginPreset = (disabledPs.pkg.splitPrivateFlags[i] & Integer.MIN_VALUE) != 0;
                                boolean isRemoved = removeSplitList != null && removeSplitList.contains(splitName);
                                if (isPluginPreset && isRemoved && !disablePlugins.contains(splitName)) {
                                    disablePlugins.add(splitName);
                                }
                            }
                            for (String str : pkg.splitNames) {
                                disablePlugins.remove(str);
                            }
                            disablePlugins.removeIf(new Predicate(presetSplitList) {
                                /* class com.android.server.pm.$$Lambda$PackageManagerService$hmtzd5G2cJRtfjfGbXf2UQQRcQ */
                                private final /* synthetic */ ArrayList f$0;

                                {
                                    this.f$0 = r1;
                                }

                                @Override // java.util.function.Predicate
                                public final boolean test(Object obj) {
                                    return PackageManagerService.lambda$updateDisablePluginsLocked$0(this.f$0, (String) obj);
                                }
                            });
                            String[] disablePluginNew = (String[]) disablePlugins.toArray(new String[disablePlugins.size()]);
                            Slog.i(TAG, packageName + " disablePlugins change to: " + Arrays.toString(disablePluginNew));
                            if (!Arrays.equals(disablePluginNew, disabledPs.disablePlugins)) {
                                disabledPs.disablePlugins = disablePluginNew;
                            }
                            Slog.i(TAG, packageName + " updateDisablePlugins finish");
                        }
                    }
                }
            } catch (Exception e) {
                Slog.e(TAG, "updateDisablePlugins error " + e.getMessage());
            }
        }
    }

    static /* synthetic */ boolean lambda$updateDisablePluginsLocked$0(ArrayList presetSplitList, String e) {
        return !presetSplitList.contains(e);
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x03a7, code lost:
        r0 = th;
     */
    public void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, boolean virtualPreload, String[] grantedPermissions, List<String> whitelistedRestrictedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) {
        boolean z;
        String installerPackageName;
        int[] firstUserIds;
        InstallArgs args;
        InstallArgs args2;
        String installerPackageName2;
        int packageExternalStorageType;
        int i;
        int[] iArr;
        boolean succeeded = res.returnCode == 1;
        boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
        if (succeeded) {
            if (res.removedInfo != null) {
                res.removedInfo.sendPackageRemovedBroadcasts(killApp);
            }
            if (whitelistedRestrictedPermissions != null && !whitelistedRestrictedPermissions.isEmpty()) {
                this.mPermissionManager.setWhitelistedRestrictedPermissions(res.pkg, res.newUsers, whitelistedRestrictedPermissions, Process.myUid(), 2, this.mPermissionCallback);
            }
            boolean isSystemAppGrantByMdmAndNonPreload = isSystemAppGrantByMdmAndNonPreload(res.pkg);
            if (grantPermissions || isSystemAppGrantByMdmAndNonPreload) {
                this.mPermissionManager.grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions, Binder.getCallingUid(), this.mPermissionCallback);
            }
            if (isSystemAppGrantByMdmAndNonPreload) {
                mHwPMSEx.updateDozeList(res.pkg.applicationInfo.packageName, true);
            }
            if (res.installerPackageName != null) {
                installerPackageName = res.installerPackageName;
            } else if (res.removedInfo != null) {
                installerPackageName = res.removedInfo.installerPackageName;
            } else {
                installerPackageName = null;
            }
            if (res.pkg.parentPackage != null) {
                this.mPermissionManager.grantRuntimePermissionsGrantedToDisabledPackage(res.pkg, Binder.getCallingUid(), this.mPermissionCallback);
            }
            synchronized (this.mPackages) {
                this.mInstantAppRegistry.onPackageInstalledLPw(res.pkg, res.newUsers);
            }
            String packageName = res.pkg.applicationInfo.packageName;
            int[] firstUserIds2 = EMPTY_INT_ARRAY;
            int[] firstInstantUserIds = EMPTY_INT_ARRAY;
            int[] updateUserIds = EMPTY_INT_ARRAY;
            int[] instantUserIds = EMPTY_INT_ARRAY;
            boolean allNewUsers = res.origUsers == null || res.origUsers.length == 0;
            PackageSetting ps = (PackageSetting) res.pkg.mExtras;
            int[] iArr2 = res.newUsers;
            int length = iArr2.length;
            int[] instantUserIds2 = instantUserIds;
            int[] firstUserIds3 = firstUserIds2;
            int i2 = 0;
            int[] firstInstantUserIds2 = firstInstantUserIds;
            int[] updateUserIds2 = updateUserIds;
            while (i2 < length) {
                int newUser = iArr2[i2];
                boolean isInstantApp = ps.getInstantApp(newUser);
                if (!allNewUsers) {
                    boolean isNew = true;
                    int[] iArr3 = res.origUsers;
                    iArr = iArr2;
                    int length2 = iArr3.length;
                    i = length;
                    int i3 = 0;
                    while (true) {
                        if (i3 >= length2) {
                            break;
                        } else if (iArr3[i3] == newUser) {
                            isNew = false;
                            break;
                        } else {
                            i3++;
                            length2 = length2;
                        }
                    }
                    if (isNew) {
                        if (isInstantApp) {
                            firstInstantUserIds2 = ArrayUtils.appendInt(firstInstantUserIds2, newUser);
                        } else {
                            firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                        }
                    } else if (isInstantApp) {
                        instantUserIds2 = ArrayUtils.appendInt(instantUserIds2, newUser);
                    } else {
                        updateUserIds2 = ArrayUtils.appendInt(updateUserIds2, newUser);
                    }
                } else if (isInstantApp) {
                    firstInstantUserIds2 = ArrayUtils.appendInt(firstInstantUserIds2, newUser);
                    iArr = iArr2;
                    i = length;
                } else {
                    firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                    iArr = iArr2;
                    i = length;
                }
                i2++;
                iArr2 = iArr;
                length = i;
            }
            mHwPMSEx.updatePackageBlackListInfo(packageName);
            if (res.pkg.staticSharedLibName == null) {
                this.mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(res.pkg.baseCodePath);
                mHwPMSEx.sendIncompatibleNotificationIfNeeded(packageName);
                sendPackageAddedForNewUsers(packageName, res.pkg.applicationInfo.isSystemApp() || virtualPreload, virtualPreload, UserHandle.getAppId(res.uid), firstUserIds3, firstInstantUserIds2);
                Bundle extras = new Bundle(1);
                extras.putInt("android.intent.extra.UID", res.uid);
                if (update) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                args = null;
                sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, updateUserIds2, instantUserIds2);
                if (installerPackageName != null) {
                    installerPackageName2 = installerPackageName;
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, installerPackageName, null, updateUserIds2, instantUserIds2);
                } else {
                    installerPackageName2 = installerPackageName;
                }
                String str = this.mRequiredVerifierPackage;
                boolean notifyVerifier = str != null && !str.equals(installerPackageName2);
                if (notifyVerifier) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, this.mRequiredVerifierPackage, null, updateUserIds2, instantUserIds2);
                }
                String str2 = this.mRequiredInstallerPackage;
                if (str2 != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, DumpState.DUMP_SERVICE_PERMISSIONS, str2, null, firstUserIds3, instantUserIds2);
                }
                if (update) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, null, null, updateUserIds2, instantUserIds2);
                    if (installerPackageName2 != null) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, installerPackageName2, null, updateUserIds2, instantUserIds2);
                    }
                    if (notifyVerifier) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, this.mRequiredVerifierPackage, null, updateUserIds2, instantUserIds2);
                    }
                    sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, packageName, null, updateUserIds2, instantUserIds2);
                    firstUserIds = firstUserIds3;
                    packageName = packageName;
                } else if (!launchedForRestore || isSystemApp(res.pkg)) {
                    firstUserIds = firstUserIds3;
                    packageName = packageName;
                } else {
                    if (DEBUG_BACKUP) {
                        StringBuilder sb = new StringBuilder();
                        sb.append("Post-restore of ");
                        packageName = packageName;
                        sb.append(packageName);
                        sb.append(" sending FIRST_LAUNCH in ");
                        sb.append(Arrays.toString(firstUserIds3));
                        Slog.i(TAG, sb.toString());
                    } else {
                        packageName = packageName;
                    }
                    firstUserIds = firstUserIds3;
                    sendFirstLaunchBroadcast(packageName, installerPackage, firstUserIds, firstInstantUserIds2);
                }
                if (isExternal(res.pkg)) {
                    if (!update && (packageExternalStorageType = getPackageExternalStorageType(((StorageManager) this.mContext.getSystemService(StorageManager.class)).findVolumeByUuid(res.pkg.applicationInfo.storageUuid.toString()), isExternal(res.pkg))) != 0) {
                        StatsLog.write(181, packageExternalStorageType, res.pkg.packageName);
                    }
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "upgrading pkg " + res.pkg + " is external");
                    }
                    int[] uidArray = {res.pkg.applicationInfo.uid};
                    ArrayList<String> pkgList = new ArrayList<>(1);
                    pkgList.add(packageName);
                    sendResourcesChangedBroadcast(true, true, pkgList, uidArray, (IIntentReceiver) null);
                }
            } else {
                firstUserIds = firstUserIds3;
                args = null;
            }
            if (firstUserIds != null && firstUserIds.length > 0) {
                for (int userId : firstUserIds) {
                    if (packageIsBrowser(packageName, userId)) {
                        synchronized (this.mPackages) {
                            if (this.mSettings.mPackages.get(packageName).getInstallReason(userId) != 2) {
                                args2 = null;
                                setDefaultBrowserAsyncLPw(null, userId);
                            } else {
                                args2 = null;
                            }
                        }
                    }
                    this.mPermissionManager.restoreDelayedRuntimePermissions(packageName, UserHandle.of(userId));
                    updateDefaultHomeNotLocked(userId);
                }
            }
            if (!allNewUsers || update) {
                notifyPackageChanged(packageName, res.uid);
            } else {
                notifyPackageAdded(packageName, res.uid);
            }
            EventLog.writeEvent((int) EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
            if (res.removedInfo != null) {
                args = res.removedInfo.args;
            }
            if (args == null) {
                VMRuntime.getRuntime().requestConcurrentGC();
            } else if (!killApp) {
                scheduleDeferredNoKillPostDelete(args);
            } else {
                synchronized (this.mInstallLock) {
                    args.doPostDeleteLI(true);
                }
            }
            for (int userId2 : firstUserIds) {
                PackageInfo info = getPackageInfo(packageName, 0, userId2);
                if (info != null) {
                    this.mDexManager.notifyPackageInstalled(info, userId2);
                }
            }
            z = false;
        } else {
            z = false;
        }
        if ((!succeeded || !update || killApp) ? z : true) {
            scheduleDeferredNoKillInstallObserver(res, installObserver);
            return;
        } else {
            notifyInstallObserver(res, installObserver);
            return;
        }
        while (true) {
        }
    }

    public void notifyPackagesReplacedReceived(String[] packages) {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        for (String packageName : packages) {
            PackageSetting setting = this.mSettings.mPackages.get(packageName);
            if (setting != null && filterAppAccessLPr(setting, callingUid, callingUserId)) {
                notifyInstallObserver(packageName);
            }
        }
    }

    /* access modifiers changed from: private */
    public void notifyInstallObserver(String packageName) {
        Pair<PackageInstalledInfo, IPackageInstallObserver2> pair = this.mNoKillInstallObservers.remove(packageName);
        if (pair != null) {
            notifyInstallObserver((PackageInstalledInfo) pair.first, (IPackageInstallObserver2) pair.second);
        }
    }

    private void notifyInstallObserver(PackageInstalledInfo info, IPackageInstallObserver2 installObserver) {
        if (installObserver != null) {
            try {
                installObserver.onPackageInstalled(info.name, info.returnCode, info.returnMsg, extrasForInstallResult(info));
            } catch (RemoteException e) {
                Slog.i(TAG, "Observer no longer exists.");
            }
        }
    }

    private void scheduleDeferredNoKillPostDelete(InstallArgs args) {
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(DEFERRED_NO_KILL_POST_DELETE, args), BackupAgentTimeoutParameters.DEFAULT_QUOTA_EXCEEDED_TIMEOUT_MILLIS);
    }

    private void scheduleDeferredNoKillInstallObserver(PackageInstalledInfo info, IPackageInstallObserver2 observer) {
        String packageName = info.pkg.packageName;
        this.mNoKillInstallObservers.put(packageName, Pair.create(info, observer));
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(DEFERRED_NO_KILL_INSTALL_OBSERVER, packageName), 500);
    }

    private static int getPackageExternalStorageType(VolumeInfo packageVolume, boolean packageIsExternal) {
        DiskInfo disk;
        if (packageVolume == null || (disk = packageVolume.getDisk()) == null) {
            return 0;
        }
        if (disk.isSd()) {
            return 1;
        }
        if (disk.isUsb()) {
            return 2;
        }
        if (packageIsExternal) {
            return 3;
        }
        return 0;
    }

    /* access modifiers changed from: package-private */
    public Bundle extrasForInstallResult(PackageInstalledInfo res) {
        int i = res.returnCode;
        if (i != -112) {
            boolean z = true;
            if (i != 1) {
                return null;
            }
            Bundle extras = new Bundle();
            if (res.removedInfo == null || res.removedInfo.removedPackage == null) {
                z = false;
            }
            extras.putBoolean("android.intent.extra.REPLACING", z);
            return extras;
        }
        Bundle extras2 = new Bundle();
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PERMISSION", res.origPermission);
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PACKAGE", res.origPackage);
        return extras2;
    }

    /* access modifiers changed from: package-private */
    public void scheduleWriteSettingsLocked() {
        if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageListLocked(int userId) {
        if (!this.mHandler.hasMessages(19)) {
            Message msg = this.mHandler.obtainMessage(19);
            msg.arg1 = userId;
            this.mHandler.sendMessageDelayed(msg, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(UserHandle user) {
        scheduleWritePackageRestrictionsLocked(user == null ? -1 : user.getIdentifier());
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(int userId) {
        int i = 0;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        int length = userIds.length;
        while (i < length) {
            int nextUserId = userIds[i];
            if (sUserManager.exists(nextUserId)) {
                this.mDirtyUsers.add(Integer.valueOf(nextUserId));
                if (!this.mHandler.hasMessages(14)) {
                    this.mHandler.sendEmptyMessageDelayed(14, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
                }
                i++;
            } else {
                return;
            }
        }
    }

    /* JADX WARN: Type inference failed for: r2v0, types: [com.android.server.pm.PackageManagerService, java.lang.Object, android.os.IBinder] */
    /* JADX WARN: Type inference failed for: r3v1, types: [com.android.server.pm.PackageManagerService$PackageManagerNative, android.os.IBinder] */
    public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        long startTime = SystemClock.uptimeMillis();
        PackageManagerServiceCompilerMapping.checkProperties();
        ?? huaweiPackageManagerService = HwServiceFactory.getHuaweiPackageManagerService(context, installer, factoryTest, onlyCore);
        huaweiPackageManagerService.enableSystemUserPackages();
        ServiceManager.addService("package", (IBinder) huaweiPackageManagerService);
        Objects.requireNonNull(huaweiPackageManagerService);
        ServiceManager.addService("package_native", (IBinder) new PackageManagerNative());
        HwPackageManagerServiceUtils.timingsEnd(TAG, "PackageManagerService booting timestamp", startTime);
        return huaweiPackageManagerService;
    }

    private void enableSystemUserPackages() {
        if (UserManager.isSplitSystemUser()) {
            AppsQueryHelper queryHelper = new AppsQueryHelper(this);
            Set<String> enableApps = new ArraySet<>();
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_NON_LAUNCHABLE_APPS | AppsQueryHelper.GET_APPS_WITH_INTERACT_ACROSS_USERS_PERM | AppsQueryHelper.GET_IMES, true, UserHandle.SYSTEM));
            enableApps.addAll(SystemConfig.getInstance().getSystemUserWhitelistedApps());
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_REQUIRED_FOR_SYSTEM_USER, false, UserHandle.SYSTEM));
            enableApps.removeAll(SystemConfig.getInstance().getSystemUserBlacklistedApps());
            Log.i(TAG, "Applications installed for system user: " + enableApps);
            List<String> allAps = queryHelper.queryApps(0, false, UserHandle.SYSTEM);
            int allAppsSize = allAps.size();
            synchronized (this.mPackages) {
                for (int i = 0; i < allAppsSize; i++) {
                    String pName = allAps.get(i);
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(pName);
                    if (pkgSetting != null) {
                        boolean install = enableApps.contains(pName);
                        if (pkgSetting.getInstalled(0) != install) {
                            StringBuilder sb = new StringBuilder();
                            sb.append(install ? "Installing " : "Uninstalling ");
                            sb.append(pName);
                            sb.append(" for system user");
                            Log.i(TAG, sb.toString());
                            pkgSetting.setInstalled(install, 0);
                        }
                    }
                }
                scheduleWritePackageRestrictionsLocked(0);
            }
        }
    }

    private static void getDefaultDisplayMetrics(Context context, DisplayMetrics metrics) {
        ((DisplayManager) context.getSystemService("display")).getDisplay(0).getMetrics(metrics);
    }

    private static void requestCopyPreoptedFiles() {
        if (SystemProperties.getInt("ro.cp_system_other_odex", 0) == 1) {
            SystemProperties.set("sys.cppreopt", "requested");
            long timeStart = SystemClock.uptimeMillis();
            long timeEnd = 100000 + timeStart;
            long timeNow = timeStart;
            while (true) {
                if (SystemProperties.get("sys.cppreopt").equals("finished")) {
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
                timeNow = SystemClock.uptimeMillis();
                if (timeNow > timeEnd) {
                    SystemProperties.set("sys.cppreopt", "timed-out");
                    Slog.wtf(TAG, "cppreopt did not finish!");
                    break;
                }
            }
            Slog.i(TAG, "cppreopts took " + (timeNow - timeStart) + " ms");
        }
    }

    /* JADX DEBUG: Multi-variable search result rejected for r64v0, resolved type: int */
    /* JADX DEBUG: Multi-variable search result rejected for r1v237, resolved type: boolean */
    /* JADX DEBUG: Multi-variable search result rejected for r64v1, resolved type: int */
    /* JADX DEBUG: Multi-variable search result rejected for r7v16, resolved type: boolean */
    /* JADX DEBUG: Multi-variable search result rejected for r7v24, resolved type: boolean */
    /* JADX DEBUG: Multi-variable search result rejected for r64v2, resolved type: int */
    /* JADX DEBUG: Multi-variable search result rejected for r7v25, resolved type: boolean */
    /* JADX DEBUG: Multi-variable search result rejected for r64v3, resolved type: int */
    /* JADX DEBUG: Multi-variable search result rejected for r1v276, resolved type: boolean */
    /* JADX DEBUG: Multi-variable search result rejected for r1v277, resolved type: boolean */
    /* JADX DEBUG: Multi-variable search result rejected for r64v4, resolved type: int */
    /* JADX DEBUG: Multi-variable search result rejected for r64v5, resolved type: int */
    /* JADX DEBUG: Multi-variable search result rejected for r64v6, resolved type: int */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX INFO: Multiple debug info for r7v59 'vendorAppDir'  java.io.File: [D('odmAppDir' java.io.File), D('oemAppDir' java.io.File)] */
    /* JADX INFO: Multiple debug info for r5v83 'privilegedProductAppDir'  java.io.File: [D('reparseFlags' int), D('privilegedProductAppDir' java.io.File)] */
    /* JADX WARNING: Code restructure failed: missing block: B:100:0x0550, code lost:
        if (android.os.Build.HWFINGERPRINT.equals(r1.hwFingerprint) == false) goto L_0x055c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x055a, code lost:
        if (android.os.Build.FINGERPRINTEX.equals(r1.fingerprintEx) != false) goto L_0x055e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x055c, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x055e, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x055f, code lost:
        r70.mIsUpgrade = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x0563, code lost:
        if (r70.mIsUpgrade == false) goto L_0x05ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x0565, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, "FINGERPRINT Upgrading from " + r1.fingerprint + " to " + android.os.Build.FINGERPRINT + " and HWFINGERPRINT Upgrading from " + r1.hwFingerprint + " to " + android.os.Build.HWFINGERPRINT + " and FINGERPRINTEX Upgrading from " + r1.fingerprintEx + " to " + android.os.Build.FINGERPRINTEX);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x05ae, code lost:
        r2 = android.os.SystemProperties.getInt("ro.build.hw_emui_api_level", 0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x05b6, code lost:
        if (r1 == null) goto L_0x05be;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x05ba, code lost:
        if (r1.emuiVersion >= r2) goto L_0x05be;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x05bc, code lost:
        r7 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x05be, code lost:
        r7 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x05bf, code lost:
        r70.mIsEmuiVersionUpgrade = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x05c3, code lost:
        if (r70.mIsEmuiVersionUpgrade == false) goto L_0x05ff;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:?, code lost:
        r7 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x05ca, code lost:
        r34 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:?, code lost:
        r7.append("EMUI version upgrading from ");
        r7.append(r1.emuiVersion);
        r7.append(" to ");
        r7.append(r2);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, r7.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x05e7, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x05e8, code lost:
        r1 = r0;
        r22 = r5;
        r36 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x05f3, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x05f4, code lost:
        r1 = r0;
        r22 = r5;
        r36 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x05ff, code lost:
        r34 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:?, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.loadCorrectUninstallDelapp();
        r3 = com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsBegin();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x060a, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.loadSysWhitelist();
        com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsEnd(com.android.server.pm.PackageManagerService.TAG, "loadSysWhitelist", r3);
        r70.mDelPackageList = com.android.server.pm.PackageManagerService.mHwPMSEx.getDelPackageList();
        com.android.server.pm.PackageManagerService.mHwPMSEx.readPersistentConfig();
        com.android.server.pm.PackageManagerService.mHwPMSEx.readPreInstallApkList();
        com.android.server.pm.PackageManagerService.mHwPMSEx.getUninstallApk();
        com.android.server.pm.PackageManagerService.mHwPMSEx.initCertCompatSettings();
        com.android.server.pm.PackageManagerService.mHwPMSEx.resetSharedUserSignaturesIfNeeded();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x063c, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0646;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:0x0642, code lost:
        if (r1.sdkVersion > 22) goto L_0x0646;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x0644, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x0646, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x0647, code lost:
        r70.mPromoteSystemApps = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x064b, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0655;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x0651, code lost:
        if (r1.sdkVersion >= com.android.server.pm.PackageManagerService.DEFERRED_NO_KILL_INSTALL_OBSERVER) goto L_0x0655;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x0653, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:139:0x0655, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x0656, code lost:
        r70.mIsPreNUpgrade = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x065a, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0664;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x0660, code lost:
        if (r1.sdkVersion >= 25) goto L_0x0664;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x0662, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x0664, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x0665, code lost:
        r70.mIsPreNMR1Upgrade = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x0669, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0673;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x066f, code lost:
        if (r1.sdkVersion >= 29) goto L_0x0673;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x0671, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x0673, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x0674, code lost:
        r70.mIsPreQUpgrade = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x0678, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0682;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x067e, code lost:
        if (r1.sdkVersion >= 28) goto L_0x0682;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x0680, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x0682, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x0683, code lost:
        r70.mIsPrePUpgrade = r2;
        r2 = r1.sdkVersion;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x068b, code lost:
        if (r70.mPromoteSystemApps == false) goto L_0x06c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x068d, code lost:
        r2 = r70.mSettings.mPackages.values().iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x069d, code lost:
        if (r2.hasNext() == false) goto L_0x06c0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x069f, code lost:
        r7 = r2.next();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x06a9, code lost:
        if (isSystemApp(r7) == false) goto L_0x06b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x06ab, code lost:
        r36 = r1;
        r35 = r2;
        r70.mExistingSystemPackages.add(r7.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x06b7, code lost:
        r36 = r1;
        r35 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x06bb, code lost:
        r2 = r35;
        r1 = r36;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x06c0, code lost:
        r36 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x06c5, code lost:
        r36 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x06c7, code lost:
        r70.mCacheDir = preparePackageParserCache(r70.mIsUpgrade);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x06d3, code lost:
        if (r70.mIsUpgrade != false) goto L_0x06dc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x06d7, code lost:
        if (r70.mFirstBoot == false) goto L_0x06da;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x06da, code lost:
        r7 = 528;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x06dc, code lost:
        r7 = 528 | 8192;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x06df, code lost:
        r3 = com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsBegin();
        r37 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x06ee, code lost:
        r35 = huawei.cust.HwCfgFilePolicy.getCfgFileList("/overlay", 1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x06f2, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x06f3, code lost:
        r1 = r0;
        r36 = r6;
        r22 = r37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x06fc, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x0702, code lost:
        r35 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:?, code lost:
        android.util.Slog.e(com.android.server.pm.PackageManagerService.TAG, r0.getMessage());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x022d, code lost:
        r70.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.log", com.android.server.pm.PackageManagerService.LOG_UID, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.bluetooth", com.android.server.pm.PackageManagerService.BLUETOOTH_UID, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.se", com.android.server.pm.PackageManagerService.SE_UID, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.networkstack", com.android.server.pm.PackageManagerService.NETWORKSTACK_UID, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.ddmp", com.android.server.pm.PackageManagerService.DDMP_UID, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.dmsdpdevice", com.android.server.pm.PackageManagerService.DMSDPDEVICE_UID, 1, 8);
        r11 = android.os.SystemProperties.get("debug.separate_processes");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x0290, code lost:
        if (r11 == null) goto L_0x02d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x0296, code lost:
        if (r11.length() <= 0) goto L_0x02d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:27:0x029e, code lost:
        if ("*".equals(r11) == false) goto L_0x02af;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x02a0, code lost:
        r70.mDefParseFlags = 2;
        r70.mSeparateProcesses = null;
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Running with debug.separate_processes: * (ALL)");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x02af, code lost:
        r70.mDefParseFlags = 0;
        r70.mSeparateProcesses = r11.split(",");
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Running with debug.separate_processes: " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x02d2, code lost:
        r70.mDefParseFlags = 0;
        r70.mSeparateProcesses = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x02d8, code lost:
        r70.mPackageDexOptimizer = new com.android.server.pm.PackageDexOptimizer(r72, r70.mInstallLock, r71, "*dexopt*");
        r70.mDexManager = new com.android.server.pm.dex.DexManager(r70.mContext, r70, r70.mPackageDexOptimizer, r72, r70.mInstallLock);
        r70.mArtManagerService = new com.android.server.pm.dex.ArtManagerService(r70.mContext, r70, r72, r70.mInstallLock);
        r70.mMoveCallbacks = new com.android.server.pm.PackageManagerService.MoveCallbacks(com.android.server.FgThread.get().getLooper());
        r70.mViewCompiler = new com.android.server.pm.dex.ViewCompiler(r70.mInstallLock, r70.mInstaller);
        r70.mOnPermissionChangeListeners = new com.android.server.pm.PackageManagerService.OnPermissionChangeListeners(com.android.server.FgThread.get().getLooper());
        getDefaultDisplayMetrics(r71, r70.mMetrics);
        android.os.Trace.traceBegin(262144, "get system config");
        r16 = com.android.server.SystemConfig.getInstance();
        r70.mAvailableFeatures = r16.getAvailableFeatures();
        android.os.Trace.traceEnd(262144);
        r70.mProtectedPackages = new com.android.server.pm.ProtectedPackages(r70.mContext);
        r70.mApexManager = new com.android.server.pm.ApexManager(r71);
        com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsEnd(com.android.server.pm.PackageManagerService.TAG, "Config Init", r3);
        r5 = r70.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x0360, code lost:
        monitor-enter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:?, code lost:
        r6 = r70.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x0363, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:?, code lost:
        r70.mHandlerThread = new com.android.server.ServiceThread(com.android.server.pm.PackageManagerService.TAG, 10, true);
        r70.mHandlerThread.start();
        r70.mHandler = new com.android.server.pm.PackageManagerService.PackageHandler(r70, r70.mHandlerThread.getLooper());
        r70.mProcessLoggingHandler = new com.android.server.pm.ProcessLoggingHandler();
        com.android.server.Watchdog.getInstance().addThread(r70.mHandler, 600000);
        r70.mInstantAppRegistry = new com.android.server.pm.InstantAppRegistry(r70);
        r4 = r16.getSharedLibraries();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x03a6, code lost:
        r3 = r4.size();
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x03a8, code lost:
        if (r1 >= r3) goto L_0x03cd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:?, code lost:
        addBuiltInSharedLibraryLocked(r4.valueAt(r1).filename, r4.keyAt(r1));
        r1 = r1 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x03c2, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x03c3, code lost:
        r1 = r0;
        r22 = r5;
        r36 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x03cd, code lost:
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x03d0, code lost:
        if (r1 >= r3) goto L_0x0415;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x03d2, code lost:
        r2 = r4.keyAt(r1);
        r8 = r4.valueAt(r1);
        r3 = r8.dependencies.length;
        r4 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x03e9, code lost:
        if (r4 >= r3) goto L_0x040a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x03eb, code lost:
        r3 = getSharedLibraryInfoLPr(r8.dependencies[r4], -1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x03f5, code lost:
        if (r3 == null) goto L_0x0401;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x03f7, code lost:
        r28 = r7;
        getSharedLibraryInfoLPr(r2, -1).addDependency(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0401, code lost:
        r28 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0403, code lost:
        r4 = r4 + 1;
        r3 = r3;
        r7 = r28;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x040a, code lost:
        r1 = r1 + 1;
        r3 = r3;
        r4 = r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0415, code lost:
        com.android.server.pm.SELinuxMMAC.readInstallPolicy();
        com.android.server.pm.PackageManagerService.mHwPMSEx.initHwCertificationManager();
        r1 = com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsBegin();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:?, code lost:
        android.os.Trace.traceBegin(262144, "loadFallbacks");
        android.content.pm.FallbackCategoryProvider.loadFallbacks();
        android.os.Trace.traceEnd(262144);
        com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsEnd(com.android.server.pm.PackageManagerService.TAG, "loadFallbacks", r1);
        r1 = com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsBegin();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:581:0x149a, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:582:0x149b, code lost:
        r36 = r6;
        r22 = r37;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:583:0x14a3, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:584:0x14a4, code lost:
        r22 = r5;
        r36 = r6;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:585:0x14ae, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:586:0x14af, code lost:
        r22 = r5;
        r36 = r6;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:587:0x14b9, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:588:0x14ba, code lost:
        r22 = r5;
        r36 = r6;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:589:0x14c2, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:590:0x14c3, code lost:
        r22 = r5;
        r36 = r6;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:596:0x14d0, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:597:0x14d1, code lost:
        r22 = r5;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:?, code lost:
        android.os.Trace.traceBegin(262144, "read user settings");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:608:0x14e1, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:609:0x14e2, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x045a, code lost:
        if (r70.mSettings.readLPw(com.android.server.pm.PackageManagerService.sUserManager.getUsers(false)) != false) goto L_0x045e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x045c, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x045e, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x045f, code lost:
        r70.mFirstBoot = r1;
        android.os.Trace.traceEnd(262144);
        com.android.server.pm.HwPackageManagerServiceUtils.hwTimingsEnd(com.android.server.pm.PackageManagerService.TAG, "mSettings.readLPw", r1);
        r26 = false;
        r26 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0473, code lost:
        if (com.android.server.pm.PackageManagerService.MAPLE_ENABLE == false) goto L_0x048c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:?, code lost:
        com.android.server.pm.HwMaplePMServiceUtils.init(r70.mHandlerThread.getLooper());
        com.android.server.pm.HwMaplePMServiceUtils.loadDisabledMaplePkgs();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x0482, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x0483, code lost:
        r1 = r0;
        r22 = r5;
        r36 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x048c, code lost:
        com.android.server.pm.HwMaplePMServiceUtils.deleteDisabledMapleFile();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x048f, code lost:
        r1 = r70.mSettings.mPackages.size() - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x049b, code lost:
        if (r1 < 0) goto L_0x04d4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x049d, code lost:
        r2 = r70.mSettings.mPackages.valueAt(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x04ab, code lost:
        if (isExternal(r2) != false) goto L_0x04d1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x04af, code lost:
        if (r2.codePath == null) goto L_0x04b9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x04b7, code lost:
        if (r2.codePath.exists() != false) goto L_0x04d1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x04c1, code lost:
        if (r70.mSettings.getDisabledSystemPkgLPr(r2.name) == null) goto L_0x04d1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x04c3, code lost:
        r70.mSettings.mPackages.removeAt(r1);
        r70.mSettings.enableSystemPackageLPw(r2.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x04d1, code lost:
        r1 = r1 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x04d6, code lost:
        if (r70.mOnlyCore != false) goto L_0x04df;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x04da, code lost:
        if (r70.mFirstBoot == false) goto L_0x04df;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x04dc, code lost:
        requestCopyPreoptedFiles();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x04df, code lost:
        r1 = android.content.res.Resources.getSystem().getString(17039809);
        r2 = android.common.HwFrameworkFactory.getHuaweiResolverActivity(r70.mContext);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x04f6, code lost:
        if (android.text.TextUtils.isEmpty(r2) != false) goto L_0x04fe;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x04f8, code lost:
        r70.mCustomResolverComponentName = android.content.ComponentName.unflattenFromString(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x04fe, code lost:
        r1 = android.os.SystemClock.uptimeMillis();
        android.util.EventLog.writeEvent((int) com.android.server.EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, r1);
        r1 = java.lang.System.getenv("BOOTCLASSPATH");
        r1 = java.lang.System.getenv("SYSTEMSERVERCLASSPATH");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x0518, code lost:
        if (r1 != null) goto L_0x0521;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x051a, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "No BOOTCLASSPATH found!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x0521, code lost:
        if (r1 != null) goto L_0x052a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x0523, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "No SYSTEMSERVERCLASSPATH found!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x052a, code lost:
        r8 = new java.io.File(android.os.Environment.getRootDirectory(), "framework");
        r1 = r70.mSettings.getInternalVersion();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x053c, code lost:
        if (r1 == null) goto L_0x055e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x0546, code lost:
        if (android.os.Build.FINGERPRINT.equals(r1.fingerprint) == false) goto L_0x055c;
     */
    /* JADX WARNING: Removed duplicated region for block: B:268:0x09fa  */
    /* JADX WARNING: Removed duplicated region for block: B:322:0x0ba6 A[Catch:{ all -> 0x1471 }] */
    /* JADX WARNING: Removed duplicated region for block: B:325:0x0be5 A[Catch:{ all -> 0x1471 }] */
    /* JADX WARNING: Removed duplicated region for block: B:326:0x0be8 A[Catch:{ all -> 0x1471 }] */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0c01 A[ADDED_TO_REGION, Catch:{ all -> 0x1471 }] */
    /* JADX WARNING: Removed duplicated region for block: B:334:0x0c12 A[Catch:{ all -> 0x1471 }] */
    /* JADX WARNING: Removed duplicated region for block: B:340:0x0c43 A[Catch:{ all -> 0x1471 }] */
    /* JADX WARNING: Removed duplicated region for block: B:372:0x0d88  */
    /* JADX WARNING: Removed duplicated region for block: B:429:0x1011  */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x1018  */
    /* JADX WARNING: Removed duplicated region for block: B:436:0x1043  */
    /* JADX WARNING: Removed duplicated region for block: B:440:0x10ab  */
    /* JADX WARNING: Removed duplicated region for block: B:454:0x1125  */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x1127  */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x112c  */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x1177  */
    /* JADX WARNING: Removed duplicated region for block: B:470:0x11a6  */
    /* JADX WARNING: Removed duplicated region for block: B:479:0x11d6  */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x11d9  */
    /* JADX WARNING: Removed duplicated region for block: B:483:0x120b A[ADDED_TO_REGION] */
    /* JADX WARNING: Removed duplicated region for block: B:495:0x1253  */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x129d  */
    /* JADX WARNING: Removed duplicated region for block: B:522:0x12f3  */
    /* JADX WARNING: Removed duplicated region for block: B:527:0x1330  */
    /* JADX WARNING: Removed duplicated region for block: B:531:0x135d  */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x13c0  */
    /* JADX WARNING: Removed duplicated region for block: B:552:0x13f7  */
    /* JADX WARNING: Removed duplicated region for block: B:555:0x1408 A[LOOP:18: B:554:0x1406->B:555:0x1408, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:558:0x1427  */
    public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        Throwable th;
        Object obj;
        Throwable th2;
        ArrayMap<String, PackageParser.Package> arrayMap;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        Throwable th3;
        boolean isSettingsDirty;
        long startTime;
        File frameworkDir;
        Settings.VersionInfo ver;
        int scanFlags;
        long hwStartTime;
        Object obj2;
        ArrayList<File> fileList;
        long hwStartTime2;
        Settings.VersionInfo ver2;
        boolean z;
        long hwStartTime3;
        Boolean bool;
        File privilegedAppDir;
        long hwStartTime4;
        File systemAppDir;
        File privilegedVendorAppDir;
        File vendorAppDir;
        File vendorAppDir2;
        File privilegedOdmAppDir;
        File privilegedOdmAppDir2;
        File privilegedOdmAppDir3;
        File privilegedVendorAppDir2;
        File vendorAppDir3;
        File odmAppDir;
        File odmAppDir2;
        File odmAppDir3;
        File vendorAppDir4;
        File privilegedProductAppDir;
        File privilegedProductAppDir2;
        File privilegedProductAppDir3;
        File productAppDir;
        File productAppDir2;
        File productAppDir3;
        File privilegedProductServicesAppDir;
        File privilegedProductServicesAppDir2;
        File privilegedProductServicesAppDir3;
        File productServicesAppDir;
        File productServicesAppDir2;
        File productServicesAppDir3;
        long hwStartTime5;
        List<String> stubSystemApps;
        int cachedSystemApps;
        long systemScanTime;
        int systemPackagesCount;
        PackageParser.Package r6;
        int i;
        PackageParser.Package r7;
        boolean sdkUpdated;
        int storageFlags;
        int i2;
        boolean z2;
        Iterator<PackageParser.Package> it;
        Pair<ComponentName, String> instantAppResolverComponent;
        String str;
        int storageFlags2;
        Iterator<PackageParser.Package> it2;
        int i3;
        int i4;
        List<String> possiblyDeletedUpdatedSystemApps;
        int i5;
        int i6;
        int i7;
        int i8;
        File privilegedProductAppDir4;
        File oemAppDir;
        int i9;
        File vendorAppDir5;
        File odmAppDir4;
        int rescanFlags;
        int reparseFlags;
        int i10;
        File odmAppDir5;
        File privilegedProductAppDir5;
        File privilegedVendorAppDir3;
        File systemAppDir2;
        File odmAppDir6;
        File privilegedProductAppDir6;
        String packageName;
        int i11;
        List<String> possiblyDeletedUpdatedSystemApps2;
        int systemPackagesCount2;
        String msg;
        PackageSetting ps;
        PackageManagerException e;
        long hwStartTime6;
        List<String> stubSystemApps2;
        Iterator<PackageParser.Package> pkgIterator;
        File frameworkDir2;
        Boolean bool2;
        boolean z3 = true;
        this.mNextInstallToken = 1;
        this.mPackageUsage = new PackageUsage();
        this.mCompilerStats = new CompilerStats();
        this.mPermissionCallback = new PermissionManagerServiceInternal.PermissionCallback() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass1 */

            public /* synthetic */ void lambda$onGidsChanged$0$PackageManagerService$1(int appId, int userId) {
                PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onGidsChanged(int appId, int userId) {
                PackageManagerService.this.mHandler.post(new Runnable(appId, userId) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$1$7o99DenVu604GN9uaO7x0s_Ispw */
                    private final /* synthetic */ int f$1;
                    private final /* synthetic */ int f$2;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                    }

                    public final void run() {
                        PackageManagerService.AnonymousClass1.this.lambda$onGidsChanged$0$PackageManagerService$1(this.f$1, this.f$2);
                    }
                });
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionGranted(int uid, int userId) {
                PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onInstallPermissionGranted() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionRevoked(int uid, int userId) {
                PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
                }
                int appId = UserHandle.getAppId(uid);
                if (uid != 1001) {
                    PackageManagerService.this.mHandler.post(new Runnable(appId, userId) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$1$UqkVA9qTDjOrKboRoZUSVel9Qek */
                        private final /* synthetic */ int f$1;
                        private final /* synthetic */ int f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        public final void run() {
                            PackageManagerService.AnonymousClass1.this.lambda$onPermissionRevoked$1$PackageManagerService$1(this.f$1, this.f$2);
                        }
                    });
                } else {
                    Slog.w(PackageManagerService.TAG, "onPermissionRevoked don't kill PHONE_UID processes ");
                }
            }

            public /* synthetic */ void lambda$onPermissionRevoked$1$PackageManagerService$1(int appId, int userId) {
                PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onInstallPermissionRevoked() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
                synchronized (PackageManagerService.this.mPackages) {
                    for (int userId : updatedUserIds) {
                        PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, sync);
                    }
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onInstallPermissionUpdated() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionRemoved() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.mSettings.writeLPr();
                }
            }
        };
        this.mStorageListener = new StorageEventListener() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass2 */

            public void onVolumeStateChanged(VolumeInfo vol, int oldState, int newState) {
                if (vol.type != 1) {
                    return;
                }
                if (vol.state == 2) {
                    String volumeUuid = vol.getFsUuid();
                    PackageManagerService.sUserManager.reconcileUsers(volumeUuid);
                    PackageManagerService.this.reconcileApps(volumeUuid);
                    PackageManagerService.this.mInstallerService.onPrivateVolumeMounted(volumeUuid);
                    PackageManagerService.this.loadPrivatePackages(vol);
                } else if (vol.state == 5) {
                    PackageManagerService.this.unloadPrivatePackages(vol);
                }
            }

            public void onVolumeForgotten(String fsUuid) {
                if (TextUtils.isEmpty(fsUuid)) {
                    Slog.e(PackageManagerService.TAG, "Forgetting internal storage is probably a mistake; ignoring");
                    return;
                }
                synchronized (PackageManagerService.this.mPackages) {
                    for (PackageSetting ps : PackageManagerService.this.mSettings.getVolumePackagesLPr(fsUuid)) {
                        Slog.d(PackageManagerService.TAG, "Destroying " + ps.name + " because volume was forgotten");
                        PackageManagerService.this.deletePackageVersioned(new VersionedPackage(ps.name, -1), new PackageManager.LegacyPackageDeleteObserver((IPackageDeleteObserver) null).getBinder(), 0, 2);
                        AttributeCache.instance().removePackage(ps.name);
                    }
                    PackageManagerService.this.mSettings.onVolumeForgotten(fsUuid);
                    PackageManagerService.this.mSettings.writeLPr();
                }
            }
        };
        this.mMediaMounted = false;
        this.mHwInnerService = new HwInnerPackageManagerService(this);
        mHwPMSEx = HwServiceExFactory.getHwPackageManagerServiceEx(this, context);
        HwPackageManagerServiceUtils.initHwPMSEx(mHwPMSEx);
        LockGuard.installLock(this.mPackages, 3);
        Trace.traceBegin(262144, "create package manager");
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());
        if (this.mSdkVersion <= 0) {
            Slog.w(TAG, "**** ro.build.version.sdk not set!");
        }
        this.mContext = context;
        long hwStartTime7 = HwPackageManagerServiceUtils.hwTimingsBegin();
        this.mFactoryTest = factoryTest;
        this.mOnlyCore = onlyCore;
        this.mMetrics = new DisplayMetrics();
        this.mInstaller = installer;
        synchronized (this.mInstallLock) {
            try {
                synchronized (this.mPackages) {
                    try {
                        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());
                        try {
                            Slog.i(TAG, "UserManagerService");
                            HwServiceFactory.IHwUserManagerService service = HwServiceFactory.getHwUserManagerService();
                            if (service != null) {
                                sUserManager = service.getInstance(context, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                            } else {
                                sUserManager = new UserManagerService(context, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                            }
                        } catch (Throwable e2) {
                            Slog.e(TAG, "UserManagerService error " + e2);
                        }
                        this.mComponentResolver = new ComponentResolver(sUserManager, (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class), this.mPackages);
                        this.mPermissionManager = PermissionManagerService.create(context, this.mPackages);
                        this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                        this.mSettings = new Settings(Environment.getDataDirectory(), this.mPermissionManager.getPermissionSettings(), this.mPackages);
                    } catch (Throwable th4) {
                        th = th4;
                        throw th;
                    }
                }
            } catch (Throwable th5) {
                th = th5;
                throw th;
            }
        }
        while (i5 >= 0) {
            String packageName2 = possiblyDeletedUpdatedSystemApps.get(i5);
            PackageParser.Package pkg = this.mPackages.get(packageName2);
            this.mSettings.removeDisabledSystemPackageLPw(packageName2);
            boolean keepDataForMigrate = false;
            keepDataForMigrate = false;
            if (pkg == null) {
                packageName = packageName2;
                i11 = i5;
                possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps;
                systemPackagesCount2 = systemPackagesCount;
                msg = "Updated system package " + packageName2 + " no longer exists; removing its data";
            } else {
                String msg2 = "Updated system package " + packageName2 + " no longer exists; rescanning package on data";
                removePackageLI(pkg, true);
                if (!mHwPMSEx.getRenamedPackagePolicyByOriginalName(packageName2).isPresent() || !isUpgradeAndEmuiVersionUpgrade()) {
                    try {
                        packageName = packageName2;
                        i11 = i5;
                        possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps;
                        systemPackagesCount2 = systemPackagesCount;
                        try {
                            scanPackageTracedLI(new File(pkg.applicationInfo.getCodePath()), 0, scanFlags, 0, (UserHandle) null);
                        } catch (PackageManagerException e3) {
                            e = e3;
                        }
                    } catch (PackageManagerException e4) {
                        packageName = packageName2;
                        systemPackagesCount2 = systemPackagesCount;
                        i11 = i5;
                        possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps;
                        e = e4;
                        Slog.e(TAG, "Failed to parse updated, ex-system package: " + e.getMessage());
                        msg = msg2;
                        ps = this.mSettings.mPackages.get(packageName);
                        if (ps == null && this.mPackages.get(packageName) == null && !keepDataForMigrate) {
                            removePackageDataLIF(ps, null, null, 0, false);
                        }
                        PackageManagerServiceUtils.logCriticalInfo(5, msg);
                        i5 = i11 - 1;
                        systemPackagesCount = systemPackagesCount2;
                        possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps2;
                    }
                    msg = msg2;
                } else {
                    keepDataForMigrate = true;
                    Slog.i(TAG, "PACKAGE_NAME_CHANGE " + packageName2 + ", do not scaned the package on data");
                    packageName = packageName2;
                    systemPackagesCount2 = systemPackagesCount;
                    msg = msg2;
                    i11 = i5;
                    possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps;
                }
            }
            ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
            }
            PackageManagerServiceUtils.logCriticalInfo(5, msg);
            i5 = i11 - 1;
            systemPackagesCount = systemPackagesCount2;
            possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps2;
        }
        i6 = 5;
        i = 0;
        i = 0;
        i7 = 0;
        while (i7 < this.mExpectingBetter.size()) {
            String packageName3 = this.mExpectingBetter.keyAt(i7);
            if (!this.mPackages.containsKey(packageName3)) {
                File scanFile = this.mExpectingBetter.valueAt(i7);
                PackageManagerServiceUtils.logCriticalInfo(i6, "Expected better " + packageName3 + " but never showed up; reverting to system");
                if (FileUtils.contains(privilegedAppDir, scanFile)) {
                    reparseFlags = this.mDefParseFlags | 16;
                    rescanFlags = scanFlags | 131072 | 262144;
                    i10 = i7;
                    odmAppDir5 = vendorAppDir4;
                    privilegedProductAppDir5 = privilegedProductAppDir3;
                } else if (FileUtils.contains(systemAppDir, scanFile)) {
                    reparseFlags = this.mDefParseFlags | 16;
                    rescanFlags = scanFlags | 131072;
                    systemAppDir = systemAppDir;
                    i10 = i7;
                    odmAppDir5 = vendorAppDir4;
                    privilegedProductAppDir5 = privilegedProductAppDir3;
                } else {
                    if (FileUtils.contains(privilegedVendorAppDir2, scanFile)) {
                        privilegedVendorAppDir3 = privilegedVendorAppDir2;
                        systemAppDir2 = systemAppDir;
                        i10 = i7;
                        odmAppDir6 = vendorAppDir4;
                        privilegedProductAppDir6 = privilegedProductAppDir3;
                    } else if (FileUtils.contains(privilegedOdmAppDir3, scanFile)) {
                        privilegedOdmAppDir3 = privilegedOdmAppDir3;
                        privilegedVendorAppDir3 = privilegedVendorAppDir2;
                        systemAppDir2 = systemAppDir;
                        i10 = i7;
                        odmAppDir6 = vendorAppDir4;
                        privilegedProductAppDir6 = privilegedProductAppDir3;
                    } else {
                        i10 = i7;
                        if (!FileUtils.contains(vendorAppDir3, scanFile)) {
                            vendorAppDir3 = vendorAppDir3;
                            if (FileUtils.contains(odmAppDir3, scanFile)) {
                                privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                systemAppDir = systemAppDir;
                                odmAppDir3 = odmAppDir3;
                                odmAppDir5 = vendorAppDir4;
                                privilegedProductAppDir5 = privilegedProductAppDir3;
                            } else {
                                odmAppDir3 = odmAppDir3;
                                odmAppDir5 = vendorAppDir4;
                                if (FileUtils.contains(odmAppDir5, scanFile)) {
                                    privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                    privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                    systemAppDir = systemAppDir;
                                    rescanFlags = scanFlags | 131072 | 524288;
                                    reparseFlags = this.mDefParseFlags | 16;
                                    privilegedProductAppDir5 = privilegedProductAppDir3;
                                } else {
                                    privilegedProductAppDir5 = privilegedProductAppDir3;
                                    if (FileUtils.contains(privilegedProductAppDir5, scanFile)) {
                                        privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                        privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                        systemAppDir = systemAppDir;
                                        rescanFlags = scanFlags | 131072 | 2097152 | 262144;
                                        reparseFlags = this.mDefParseFlags | 16;
                                    } else {
                                        privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                        if (FileUtils.contains(productAppDir3, scanFile)) {
                                            productAppDir3 = productAppDir3;
                                            privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                            systemAppDir = systemAppDir;
                                            rescanFlags = scanFlags | 131072 | 2097152;
                                            reparseFlags = this.mDefParseFlags | 16;
                                        } else {
                                            productAppDir3 = productAppDir3;
                                            if (FileUtils.contains(privilegedProductServicesAppDir3, scanFile)) {
                                                privilegedProductServicesAppDir3 = privilegedProductServicesAppDir3;
                                                privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                                systemAppDir = systemAppDir;
                                                rescanFlags = scanFlags | 131072 | 4194304 | 262144;
                                                reparseFlags = this.mDefParseFlags | 16;
                                            } else {
                                                privilegedProductServicesAppDir3 = privilegedProductServicesAppDir3;
                                                if (FileUtils.contains(productServicesAppDir3, scanFile)) {
                                                    productServicesAppDir3 = productServicesAppDir3;
                                                    privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                                    systemAppDir = systemAppDir;
                                                    rescanFlags = scanFlags | 131072 | 4194304;
                                                    reparseFlags = this.mDefParseFlags | 16;
                                                } else {
                                                    productServicesAppDir3 = productServicesAppDir3;
                                                    if (mHwPMSEx != null && mHwPMSEx.isSystemPreApp(scanFile)) {
                                                        privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                                        systemAppDir = systemAppDir;
                                                        rescanFlags = scanFlags | 131072;
                                                        reparseFlags = this.mDefParseFlags | 16;
                                                    } else if (mHwPMSEx == null || !mHwPMSEx.isPrivilegedPreApp(scanFile)) {
                                                        privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                                        StringBuilder sb = new StringBuilder();
                                                        systemAppDir = systemAppDir;
                                                        sb.append("Ignoring unexpected fallback path ");
                                                        sb.append(scanFile);
                                                        Slog.e(TAG, sb.toString());
                                                        privilegedProductAppDir4 = privilegedProductAppDir5;
                                                        oemAppDir = vendorAppDir3;
                                                        i8 = 5;
                                                        vendorAppDir5 = odmAppDir5;
                                                        i9 = i10;
                                                        odmAppDir4 = odmAppDir3;
                                                    } else {
                                                        privilegedVendorAppDir2 = privilegedVendorAppDir2;
                                                        systemAppDir = systemAppDir;
                                                        rescanFlags = scanFlags | 131072 | 262144;
                                                        reparseFlags = this.mDefParseFlags | 16;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            privilegedOdmAppDir3 = privilegedOdmAppDir3;
                            privilegedVendorAppDir2 = privilegedVendorAppDir2;
                            systemAppDir = systemAppDir;
                            vendorAppDir3 = vendorAppDir3;
                            odmAppDir5 = vendorAppDir4;
                            privilegedProductAppDir5 = privilegedProductAppDir3;
                        }
                        reparseFlags = this.mDefParseFlags | 16;
                        rescanFlags = scanFlags | 131072 | 1048576;
                    }
                    reparseFlags = this.mDefParseFlags | 16;
                    rescanFlags = scanFlags | 131072 | 1048576 | 262144;
                }
                this.mSettings.enableSystemPackageLPw(packageName3);
                isSettingsDirty = true;
                isSettingsDirty = true;
                privilegedProductAppDir4 = privilegedProductAppDir5;
                i8 = 5;
                i8 = 5;
                oemAppDir = vendorAppDir3;
                vendorAppDir5 = odmAppDir5;
                i9 = i10;
                odmAppDir4 = odmAppDir3;
                try {
                    scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, 0, (UserHandle) null);
                } catch (PackageManagerException e5) {
                    Slog.e(TAG, "Failed to parse original system package: " + e5.getMessage());
                }
            } else {
                i8 = i6;
                odmAppDir4 = odmAppDir3;
                privilegedProductAppDir4 = privilegedProductAppDir3;
                i9 = i7;
                oemAppDir = vendorAppDir3;
                vendorAppDir5 = vendorAppDir4;
            }
            i7 = i9 + 1;
            odmAppDir3 = odmAppDir4;
            privilegedProductAppDir3 = privilegedProductAppDir4;
            i6 = i8;
            vendorAppDir4 = vendorAppDir5;
            vendorAppDir3 = oemAppDir;
        }
        installSystemStubPackages(stubSystemApps, scanFlags);
        int cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps;
        long dataScanTime = (SystemClock.uptimeMillis() - systemScanTime) - startTime;
        int dataPackagesCount = this.mPackages.size() - systemPackagesCount;
        StringBuilder sb2 = new StringBuilder();
        sb2.append("Finished scanning non-system apps. Time: ");
        sb2.append(dataScanTime);
        sb2.append(" ms, packageCount: ");
        sb2.append(dataPackagesCount);
        sb2.append(" , timePerPackage: ");
        sb2.append(dataPackagesCount != 0 ? 0 : dataScanTime / ((long) dataPackagesCount));
        sb2.append(" , cached: ");
        sb2.append(cachedNonSystemApps);
        Slog.i(TAG, sb2.toString());
        if (this.mIsUpgrade || dataPackagesCount <= 0) {
            r7 = null;
        } else {
            r7 = null;
            MetricsLogger.histogram((Context) null, "ota_package_manager_data_app_avg_scan_time", ((int) dataScanTime) / dataPackagesCount);
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
            List<String> changedAbiCodePath = adjustCpuAbisForSharedUserLPw(setting.packages, r7);
            if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
                for (i4 = changedAbiCodePath.size() - 1; i4 >= 0; i4--) {
                    try {
                        this.mInstaller.rmdex(changedAbiCodePath.get(i4), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                    } catch (Installer.InstallerException e6) {
                    }
                }
            }
            setting.fixSeInfoLocked();
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        sdkUpdated = ver2.sdkVersion == this.mSdkVersion ? 1 : i;
        if (sdkUpdated != 0) {
            this.tSdkVersion = ver2.sdkVersion;
            Slog.i(TAG, "Platform changed from " + ver2.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for internal storage");
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore && (this.mPromoteSystemApps || this.mFirstBoot)) {
            for (UserInfo user : sUserManager.getUsers(true)) {
                this.mSettings.applyDefaultPreferredAppsLPw(user.id);
                primeDomainVerificationsLPw(user.id);
            }
        } else if (!onlyCore || !this.mIsUpgrade) {
            Slog.d(TAG, "No need to do anything to prime domain");
        } else {
            for (UserInfo user2 : sUserManager.getUsers(true)) {
                primeDomainVerificationsLPw(user2.id, 1);
            }
        }
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
            storageFlags = 1;
        } else {
            storageFlags = 3;
        }
        i2 = i;
        List<String> deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags3 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages, storageFlags3) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade && !onlyCore) {
            Slog.i(TAG, "Build fingerprint changed; clearing code caches");
            for (int i12 = i2; i12 < this.mSettings.mPackages.size(); i12++) {
                PackageSetting ps2 = this.mSettings.mPackages.valueAt(i12);
                if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps2.volumeUuid)) {
                    clearAppDataLIF(ps2.pkg, -1, 39);
                }
            }
            ver2.fingerprint = Build.FINGERPRINT;
            ver2.hwFingerprint = Build.HWFINGERPRINT;
            ver2.fingerprintEx = Build.FINGERPRINTEX;
        }
        if (!onlyCore || !this.mIsPreQUpgrade) {
            z2 = i2;
        } else {
            Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
            int size = this.mSettings.mPackages.size();
            int i13 = 0;
            while (i13 < size) {
                PackageSetting ps3 = this.mSettings.mPackages.valueAt(i13);
                if ((ps3.pkgFlags & 1) != 0) {
                    i3 = i2;
                } else {
                    i3 = i2;
                    ps3.disableComponentLPw(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME, i3);
                }
                i13++;
                i2 = i3;
            }
            z2 = i2;
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty || this.mIsUpgrade || this.mFirstBoot) {
            long hwStartTime8 = HwPackageManagerServiceUtils.hwTimingsBegin();
            try {
                Trace.traceBegin(262144, "write settings");
                this.mSettings.writeLPr();
                Trace.traceEnd(262144);
                HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime8);
                hwStartTime5 = hwStartTime8;
            } catch (Throwable th6) {
                th3 = th6;
                throw th3;
            }
        } else if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, 5000);
        }
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
            this.mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();
            this.mRequiredInstallerPackage = getRequiredInstallerLPr();
            this.mRequiredUninstallerPackage = getRequiredUninstallerLPr();
            this.mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();
            if (this.mIntentFilterVerifierComponent != null) {
                this.mIntentFilterVerifier = new IntentVerifierProxy(this.mContext, this.mIntentFilterVerifierComponent);
            } else {
                this.mIntentFilterVerifier = null;
            }
            this.mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.services", -1);
            this.mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.shared", -1);
        } else {
            this.mRequiredVerifierPackage = null;
            this.mRequiredInstallerPackage = null;
            this.mRequiredUninstallerPackage = null;
            this.mIntentFilterVerifierComponent = null;
            this.mIntentFilterVerifier = null;
            this.mServicesSystemSharedLibraryPackageName = null;
            this.mSharedSystemSharedLibraryPackageName = null;
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
            PackageParser.Package pkg2 = it.next();
            if (!pkg2.isSystem()) {
                int length = userIds.length;
                int i14 = 0;
                while (i14 < length) {
                    int userId = userIds[i14];
                    PackageSetting ps4 = (PackageSetting) pkg2.mExtras;
                    if (ps4 == null || !ps4.getInstantApp(userId)) {
                        it2 = it;
                        storageFlags2 = storageFlags3;
                    } else if (!ps4.getInstalled(userId)) {
                        it2 = it;
                        storageFlags2 = storageFlags3;
                    } else {
                        it2 = it;
                        storageFlags2 = storageFlags3;
                        this.mInstantAppRegistry.addInstantAppLPw(userId, ps4.appId);
                    }
                    i14++;
                    deferPackages = deferPackages;
                    it = it2;
                    storageFlags3 = storageFlags2;
                }
            }
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Set ephemeral resolver: " + instantAppResolverComponent);
            }
            this.mInstantAppResolverConnection = new InstantAppResolverConnection(this.mContext, (ComponentName) instantAppResolverComponent.first, (String) instantAppResolverComponent.second);
            this.mInstantAppResolverSettingsComponent = getInstantAppResolverSettingsLPr((ComponentName) instantAppResolverComponent.first);
            str = null;
        } else {
            str = null;
            this.mInstantAppResolverConnection = null;
            this.mInstantAppResolverSettingsComponent = null;
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages = new HashMap<>();
        for (int userId2 : userIds) {
            userPackages.put(Integer.valueOf(userId2), getInstalledPackages(0, userId2).getList());
        }
        this.mDexManager.load(userPackages);
        if (this.mIsUpgrade) {
            MetricsLogger.histogram((Context) null, "ota_package_manager_init_time", (int) (SystemClock.uptimeMillis() - startTime));
        }
        this.mSettings.clearReservedUidMap();
        try {
            this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
            this.mInstaller.setWarnIfHeld(this.mPackages);
            PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
            this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
            Trace.traceEnd(262144);
        } catch (Throwable th7) {
            th2 = th7;
            throw th2;
        }
        vendorAppDir = new File(Environment.getVendorDirectory(), "app");
        try {
            vendorAppDir2 = vendorAppDir.getCanonicalFile();
        } catch (IOException e7) {
            vendorAppDir2 = vendorAppDir;
        }
        mHwPMSEx.scanNonSystemPartitionDir(scanFlags);
        mHwPMSEx.scanRemovableAppDir(scanFlags);
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        try {
            privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        } catch (IOException e8) {
            privilegedOdmAppDir2 = privilegedOdmAppDir;
        }
        privilegedOdmAppDir3 = privilegedOdmAppDir2;
        privilegedVendorAppDir2 = privilegedVendorAppDir;
        vendorAppDir3 = vendorAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        try {
            odmAppDir2 = odmAppDir.getCanonicalFile();
        } catch (IOException e9) {
            odmAppDir2 = odmAppDir;
        }
        odmAppDir3 = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir2 = new File(Environment.getOemDirectory(), "app");
        vendorAppDir4 = oemAppDir2;
        scanDirTracedLI(oemAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        try {
            privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        } catch (IOException e10) {
            privilegedProductAppDir2 = privilegedProductAppDir;
        }
        privilegedProductAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        try {
            productAppDir2 = productAppDir.getCanonicalFile();
        } catch (IOException e11) {
            productAppDir2 = productAppDir;
        }
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        try {
            privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        } catch (IOException e12) {
            privilegedProductServicesAppDir2 = privilegedProductServicesAppDir;
        }
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        try {
            productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        } catch (IOException e13) {
            productServicesAppDir2 = productServicesAppDir;
        }
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps3 = new ArrayList<>();
        List<String> stubSystemApps3 = new ArrayList<>();
        if (!this.mOnlyCore) {
            Iterator<PackageParser.Package> pkgIterator2 = this.mPackages.values().iterator();
            while (pkgIterator2.hasNext()) {
                PackageParser.Package pkg3 = pkgIterator2.next();
                if (pkg3.isStub) {
                    stubSystemApps3.add(pkg3.packageName);
                }
                if (mHwPMSEx.isSystemAppGrantByMdm(pkg3.packageName)) {
                    bool2 = bool;
                    MDM_SYS_APP_PREALOAD_LIST.put(pkg3.packageName, bool2);
                } else {
                    bool2 = bool;
                }
                if (isUpgradeAndEmuiVersionUpgrade() && mHwPMSEx.migrateAppUninstalledState(pkg3.packageName)) {
                    Slog.i(TAG, "migrate uninstalled state for renamed package app, newPkgName: " + pkg3.packageName);
                }
                bool = bool2;
            }
            Iterator<PackageSetting> psit = this.mSettings.mPackages.values().iterator();
            while (psit.hasNext()) {
                PackageSetting ps5 = psit.next();
                if ((ps5.pkgFlags & 1) == 0) {
                    pkgIterator = pkgIterator2;
                    stubSystemApps2 = stubSystemApps3;
                    frameworkDir2 = frameworkDir;
                    hwStartTime6 = hwStartTime4;
                } else {
                    PackageParser.Package scannedPkg = this.mPackages.get(ps5.name);
                    pkgIterator = pkgIterator2;
                    boolean isSystemAppGrantByMdm = mHwPMSEx.isSystemAppGrantByMdm(ps5.name);
                    if (scannedPkg != null) {
                        stubSystemApps2 = stubSystemApps3;
                        if (this.mSettings.isDisabledSystemPackageLPr(ps5.name)) {
                            StringBuilder sb3 = new StringBuilder();
                            sb3.append("Expecting better updated system app for ");
                            sb3.append(ps5.name);
                            sb3.append("; removing system app.  Last known codePath=");
                            sb3.append(ps5.codePathString);
                            sb3.append(", versionCode=");
                            frameworkDir2 = frameworkDir;
                            hwStartTime6 = hwStartTime4;
                            try {
                                sb3.append(ps5.versionCode);
                                sb3.append("; scanned versionCode=");
                                sb3.append(scannedPkg.getLongVersionCode());
                                PackageManagerServiceUtils.logCriticalInfo(5, sb3.toString());
                                removePackageLI(scannedPkg, true);
                                this.mExpectingBetter.put(ps5.name, ps5.codePath);
                            } catch (Throwable th8) {
                                th3 = th8;
                                throw th3;
                            }
                        } else {
                            frameworkDir2 = frameworkDir;
                            hwStartTime6 = hwStartTime4;
                        }
                    } else {
                        stubSystemApps2 = stubSystemApps3;
                        frameworkDir2 = frameworkDir;
                        hwStartTime6 = hwStartTime4;
                        if (this.mSettings.isDisabledSystemPackageLPr(ps5.name)) {
                            PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps5.name);
                            if (disabledPs.codePath != null && disabledPs.codePath.exists()) {
                                if (disabledPs.pkg != null) {
                                    if (isSystemAppGrantByMdm) {
                                        MDM_SYS_APP_PREALOAD_LIST.put(ps5.name, bool);
                                    }
                                    this.mExpectingBetter.put(disabledPs.name, disabledPs.codePath);
                                }
                            }
                            possiblyDeletedUpdatedSystemApps3.add(ps5.name);
                        } else if (!isSystemAppGrantByMdm) {
                            Optional<HwRenamedPackagePolicy> hwRenamedPackagePolicyOptional = mHwPMSEx.getRenamedPackagePolicyByOriginalName(ps5.name);
                            if (!isUpgradeAndEmuiVersionUpgrade() || !hwRenamedPackagePolicyOptional.isPresent()) {
                                psit.remove();
                                isSettingsDirty = true;
                            } else {
                                Slog.i(TAG, "PACKAGE_NAME_CHANGE:" + ps5.name + "do not call the psit.remove, keep it to migrate");
                            }
                            PackageManagerServiceUtils.logCriticalInfo(5, "System package " + ps5.name + " no longer exists; it's data will be wiped");
                        }
                        frameworkDir = frameworkDir2;
                        pkgIterator2 = pkgIterator;
                        stubSystemApps3 = stubSystemApps2;
                        hwStartTime4 = hwStartTime6;
                    }
                }
                frameworkDir = frameworkDir2;
                pkgIterator2 = pkgIterator;
                stubSystemApps3 = stubSystemApps2;
                hwStartTime4 = hwStartTime6;
            }
            stubSystemApps = stubSystemApps3;
            hwStartTime5 = hwStartTime4;
        } else {
            stubSystemApps = stubSystemApps3;
            hwStartTime5 = hwStartTime4;
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb4 = new StringBuilder();
        sb4.append("Finished scanning system apps. Time: ");
        sb4.append(systemScanTime);
        sb4.append(" ms, packageCount: ");
        sb4.append(systemPackagesCount);
        sb4.append(" , timePerPackage: ");
        sb4.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb4.append(" , cached: ");
        sb4.append(cachedSystemApps);
        Slog.i(TAG, sb4.toString());
        if (this.mIsUpgrade || systemPackagesCount <= 0) {
            r6 = null;
        } else {
            r6 = null;
            MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        }
        if (!this.mOnlyCore) {
            EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis());
            possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
            scanDirTracedLI(sAppInstallDir, 0, this.mSettings.isPackageSettingsError() ? scanFlags : scanFlags | 128, 0);
            i5 = possiblyDeletedUpdatedSystemApps.size() - 1;
            while (i5 >= 0) {
            }
            i6 = 5;
            i = 0;
            i = 0;
            i7 = 0;
            while (i7 < this.mExpectingBetter.size()) {
            }
            installSystemStubPackages(stubSystemApps, scanFlags);
            int cachedNonSystemApps2 = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps;
            long dataScanTime2 = (SystemClock.uptimeMillis() - systemScanTime) - startTime;
            int dataPackagesCount2 = this.mPackages.size() - systemPackagesCount;
            StringBuilder sb22 = new StringBuilder();
            sb22.append("Finished scanning non-system apps. Time: ");
            sb22.append(dataScanTime2);
            sb22.append(" ms, packageCount: ");
            sb22.append(dataPackagesCount2);
            sb22.append(" , timePerPackage: ");
            sb22.append(dataPackagesCount2 != 0 ? 0 : dataScanTime2 / ((long) dataPackagesCount2));
            sb22.append(" , cached: ");
            sb22.append(cachedNonSystemApps2);
            Slog.i(TAG, sb22.toString());
            if (this.mIsUpgrade) {
            }
            r7 = null;
        } else {
            i = 0;
            r7 = r6;
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages2 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags32 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages2, storageFlags32) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime82 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime82);
        hwStartTime5 = hwStartTime82;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages2);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps32 = new ArrayList<>();
        List<String> stubSystemApps32 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb42 = new StringBuilder();
        sb42.append("Finished scanning system apps. Time: ");
        sb42.append(systemScanTime);
        sb42.append(" ms, packageCount: ");
        sb42.append(systemPackagesCount);
        sb42.append(" , timePerPackage: ");
        sb42.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb42.append(" , cached: ");
        sb42.append(cachedSystemApps);
        Slog.i(TAG, sb42.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages22 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags322 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages22, storageFlags322) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime822 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime822);
        hwStartTime5 = hwStartTime822;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages22);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        odmAppDir3 = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir22 = new File(Environment.getOemDirectory(), "app");
        vendorAppDir4 = oemAppDir22;
        scanDirTracedLI(oemAppDir22, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        privilegedProductAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps322 = new ArrayList<>();
        List<String> stubSystemApps322 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb422 = new StringBuilder();
        sb422.append("Finished scanning system apps. Time: ");
        sb422.append(systemScanTime);
        sb422.append(" ms, packageCount: ");
        sb422.append(systemPackagesCount);
        sb422.append(" , timePerPackage: ");
        sb422.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb422.append(" , cached: ");
        sb422.append(cachedSystemApps);
        Slog.i(TAG, sb422.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags3222 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages222, storageFlags3222) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime8222 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime8222);
        hwStartTime5 = hwStartTime8222;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages222);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        if (fileList != null) {
            try {
                Iterator<File> it3 = fileList.iterator();
                while (it3.hasNext()) {
                    arrayMap2 = arrayMap;
                    obj = obj2;
                    try {
                        scanDirTracedLI(it3.next(), this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
                        obj2 = obj;
                        arrayMap = arrayMap2;
                        ver = ver;
                        hwStartTime = hwStartTime;
                    } catch (Throwable th9) {
                        th3 = th9;
                        throw th3;
                    }
                }
                hwStartTime2 = hwStartTime;
                ver2 = ver;
                obj = obj2;
                z = true;
                arrayMap2 = arrayMap;
            } catch (Throwable th10) {
                arrayMap2 = arrayMap;
                obj = obj2;
                th3 = th10;
                throw th3;
            }
        } else {
            hwStartTime2 = hwStartTime;
            ver2 = ver;
            obj = obj2;
            z = true;
            arrayMap2 = arrayMap;
        }
        try {
            scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
            scanDirTracedLI(new File(PRODUCT_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
            scanDirTracedLI(new File(PRODUCT_SERVICES_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
            scanDirTracedLI(new File(ODM_OVERLAY_DIR), this.mDefParseFlags | 16, 8388608 | scanFlags | 131072, 0);
            scanDirTracedLI(new File(OEM_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        } catch (Throwable th11) {
            th3 = th11;
            throw th3;
        }
        try {
            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system overlay", hwStartTime2);
            this.mParallelPackageParserCallback.findStaticOverlayPackages();
            hwStartTime3 = HwPackageManagerServiceUtils.hwTimingsBegin();
            bool = z3;
        } catch (Throwable th12) {
            th3 = th12;
            throw th3;
        }
        try {
            scanDirTracedLI(frameworkDir, this.mDefParseFlags | 16, scanFlags | 1 | 131072 | 262144, 0);
            if (this.mPackages.containsKey(PLATFORM_PACKAGE_NAME)) {
                HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system framework", hwStartTime3);
                long hwStartTime9 = HwPackageManagerServiceUtils.hwTimingsBegin();
                try {
                    privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
                    scanDirTracedLI(privilegedAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 262144, 0);
                    HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system priv-app", hwStartTime9);
                    hwStartTime4 = HwPackageManagerServiceUtils.hwTimingsBegin();
                } catch (Throwable th13) {
                    th3 = th13;
                    throw th3;
                }
                try {
                    File systemAppDir3 = new File(Environment.getRootDirectory(), "app");
                    systemAppDir = systemAppDir3;
                    scanDirTracedLI(systemAppDir3, this.mDefParseFlags | 16, scanFlags | 131072, 0);
                    HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system app", hwStartTime4);
                    File privilegedVendorAppDir4 = new File(Environment.getVendorDirectory(), "priv-app");
                    try {
                        privilegedVendorAppDir = privilegedVendorAppDir4.getCanonicalFile();
                    } catch (IOException e14) {
                        privilegedVendorAppDir = privilegedVendorAppDir4;
                    }
                    vendorAppDir = new File(Environment.getVendorDirectory(), "app");
                    vendorAppDir2 = vendorAppDir.getCanonicalFile();
                    mHwPMSEx.scanNonSystemPartitionDir(scanFlags);
                    mHwPMSEx.scanRemovableAppDir(scanFlags);
                    privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
                    privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
                    privilegedOdmAppDir3 = privilegedOdmAppDir2;
                    privilegedVendorAppDir2 = privilegedVendorAppDir;
                    vendorAppDir3 = vendorAppDir2;
                    scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
                    odmAppDir = new File(Environment.getOdmDirectory(), "app");
                    odmAppDir2 = odmAppDir.getCanonicalFile();
                    odmAppDir3 = odmAppDir2;
                    scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
                    File oemAppDir222 = new File(Environment.getOemDirectory(), "app");
                    vendorAppDir4 = oemAppDir222;
                    scanDirTracedLI(oemAppDir222, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
                    privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
                    privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
                    privilegedProductAppDir3 = privilegedProductAppDir2;
                    scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
                    productAppDir = new File(Environment.getProductDirectory(), "app");
                    productAppDir2 = productAppDir.getCanonicalFile();
                    productAppDir3 = productAppDir2;
                    scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
                    privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
                    privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
                    privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
                    scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
                    productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
                    productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
                    productServicesAppDir3 = productServicesAppDir2;
                    scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
                    mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
                    List<String> possiblyDeletedUpdatedSystemApps3222 = new ArrayList<>();
                    List<String> stubSystemApps3222 = new ArrayList<>();
                    if (!this.mOnlyCore) {
                    }
                    deleteTempPackageFiles();
                    cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
                    this.mSettings.pruneSharedUsersLPw();
                    systemScanTime = SystemClock.uptimeMillis() - startTime;
                    systemPackagesCount = this.mPackages.size();
                    StringBuilder sb4222 = new StringBuilder();
                    sb4222.append("Finished scanning system apps. Time: ");
                    sb4222.append(systemScanTime);
                    sb4222.append(" ms, packageCount: ");
                    sb4222.append(systemPackagesCount);
                    sb4222.append(" , timePerPackage: ");
                    sb4222.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
                    sb4222.append(" , cached: ");
                    sb4222.append(cachedSystemApps);
                    Slog.i(TAG, sb4222.toString());
                    if (this.mIsUpgrade) {
                    }
                    r6 = null;
                    if (!this.mOnlyCore) {
                    }
                    this.mExpectingBetter.clear();
                    this.mStorageManagerPackage = getStorageManagerPackageName();
                    this.mSetupWizardPackage = getSetupWizardPackageName();
                    this.mComponentResolver.fixProtectedFilterPriorities();
                    this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
                    this.mWellbeingPackage = getWellbeingPackageName();
                    this.mDocumenterPackage = getDocumenterPackageName();
                    this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
                    this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
                    this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
                    updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
                    while (r1.hasNext()) {
                    }
                    this.mPackageUsage.read(this.mPackages);
                    this.mCompilerStats.read();
                    EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
                    Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
                    if (ver2.sdkVersion == this.mSdkVersion) {
                    }
                    if (sdkUpdated != 0) {
                    }
                    this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
                    ver2.sdkVersion = this.mSdkVersion;
                    ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
                    if (onlyCore) {
                    }
                    if (!onlyCore) {
                    }
                    Slog.d(TAG, "No need to do anything to prime domain");
                    if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
                    }
                    i2 = i;
                    List<String> deferPackages2222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
                    int storageFlags32222 = storageFlags;
                    this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages2222, storageFlags32222) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
                        private final /* synthetic */ List f$1;
                        private final /* synthetic */ int f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        public final void run() {
                            PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
                        }
                    }, "prepareAppData");
                    if (!this.mIsUpgrade) {
                    }
                    if (!onlyCore) {
                    }
                    z2 = i2;
                    this.mExistingSystemPackages.clear();
                    this.mPromoteSystemApps = z2;
                    ver2.databaseVersion = 3;
                    if (!isSettingsDirty) {
                    }
                    long hwStartTime82222 = HwPackageManagerServiceUtils.hwTimingsBegin();
                    Trace.traceBegin(262144, "write settings");
                    this.mSettings.writeLPr();
                    Trace.traceEnd(262144);
                    HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime82222);
                    hwStartTime5 = hwStartTime82222;
                    mHwPMSEx.writeCertCompatPackages(true);
                    EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
                    if (this.mOnlyCore) {
                    }
                    this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
                    int[] userIds2222 = UserManagerService.getInstance().getUserIds();
                    it = this.mPackages.values().iterator();
                    while (it.hasNext()) {
                    }
                    this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
                    instantAppResolverComponent = getInstantAppResolverLPr();
                    if (instantAppResolverComponent == null) {
                    }
                    updateInstantAppInstallerLocked(str);
                    Map<Integer, List<PackageInfo>> userPackages2222 = new HashMap<>();
                    while (r5 < r4) {
                    }
                    this.mDexManager.load(userPackages2222);
                    if (this.mIsUpgrade) {
                    }
                    this.mSettings.clearReservedUidMap();
                    this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
                    this.mInstaller.setWarnIfHeld(this.mPackages);
                    PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
                    this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
                    Trace.traceEnd(262144);
                } catch (Throwable th14) {
                    th3 = th14;
                    throw th3;
                }
            } else {
                throw new IllegalStateException("Failed to load frameworks package; check log for warnings");
            }
        } catch (Throwable th15) {
            th2 = th15;
            throw th2;
        }
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps32222 = new ArrayList<>();
        List<String> stubSystemApps32222 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb42222 = new StringBuilder();
        sb42222.append("Finished scanning system apps. Time: ");
        sb42222.append(systemScanTime);
        sb42222.append(" ms, packageCount: ");
        sb42222.append(systemPackagesCount);
        sb42222.append(" , timePerPackage: ");
        sb42222.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb42222.append(" , cached: ");
        sb42222.append(cachedSystemApps);
        Slog.i(TAG, sb42222.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages22222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags322222 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages22222, storageFlags322222) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime822222 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime822222);
        hwStartTime5 = hwStartTime822222;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages22222);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        privilegedProductAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps322222 = new ArrayList<>();
        List<String> stubSystemApps322222 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb422222 = new StringBuilder();
        sb422222.append("Finished scanning system apps. Time: ");
        sb422222.append(systemScanTime);
        sb422222.append(" ms, packageCount: ");
        sb422222.append(systemPackagesCount);
        sb422222.append(" , timePerPackage: ");
        sb422222.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb422222.append(" , cached: ");
        sb422222.append(cachedSystemApps);
        Slog.i(TAG, sb422222.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages222222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags3222222 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages222222, storageFlags3222222) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime8222222 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime8222222);
        hwStartTime5 = hwStartTime8222222;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222222 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages222222);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        privilegedOdmAppDir3 = privilegedOdmAppDir2;
        privilegedVendorAppDir2 = privilegedVendorAppDir;
        vendorAppDir3 = vendorAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        odmAppDir2 = odmAppDir.getCanonicalFile();
        odmAppDir3 = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir2222 = new File(Environment.getOemDirectory(), "app");
        vendorAppDir4 = oemAppDir2222;
        scanDirTracedLI(oemAppDir2222, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        privilegedProductAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps3222222 = new ArrayList<>();
        List<String> stubSystemApps3222222 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb4222222 = new StringBuilder();
        sb4222222.append("Finished scanning system apps. Time: ");
        sb4222222.append(systemScanTime);
        sb4222222.append(" ms, packageCount: ");
        sb4222222.append(systemPackagesCount);
        sb4222222.append(" , timePerPackage: ");
        sb4222222.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb4222222.append(" , cached: ");
        sb4222222.append(cachedSystemApps);
        Slog.i(TAG, sb4222222.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages2222222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags32222222 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages2222222, storageFlags32222222) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime82222222 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime82222222);
        hwStartTime5 = hwStartTime82222222;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2222222 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages2222222);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        i7 = i9 + 1;
        odmAppDir3 = odmAppDir4;
        privilegedProductAppDir3 = privilegedProductAppDir4;
        i6 = i8;
        vendorAppDir4 = vendorAppDir5;
        vendorAppDir3 = oemAppDir;
        mHwPMSEx.scanNonSystemPartitionDir(scanFlags);
        mHwPMSEx.scanRemovableAppDir(scanFlags);
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        privilegedOdmAppDir3 = privilegedOdmAppDir2;
        privilegedVendorAppDir2 = privilegedVendorAppDir;
        vendorAppDir3 = vendorAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        odmAppDir2 = odmAppDir.getCanonicalFile();
        odmAppDir3 = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir22222 = new File(Environment.getOemDirectory(), "app");
        vendorAppDir4 = oemAppDir22222;
        scanDirTracedLI(oemAppDir22222, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        privilegedProductAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps32222222 = new ArrayList<>();
        List<String> stubSystemApps32222222 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb42222222 = new StringBuilder();
        sb42222222.append("Finished scanning system apps. Time: ");
        sb42222222.append(systemScanTime);
        sb42222222.append(" ms, packageCount: ");
        sb42222222.append(systemPackagesCount);
        sb42222222.append(" , timePerPackage: ");
        sb42222222.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb42222222.append(" , cached: ");
        sb42222222.append(cachedSystemApps);
        Slog.i(TAG, sb42222222.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages22222222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags322222222 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages22222222, storageFlags322222222) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime822222222 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime822222222);
        hwStartTime5 = hwStartTime822222222;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222222 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages22222222);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
        mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
        List<String> possiblyDeletedUpdatedSystemApps322222222 = new ArrayList<>();
        List<String> stubSystemApps322222222 = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb422222222 = new StringBuilder();
        sb422222222.append("Finished scanning system apps. Time: ");
        sb422222222.append(systemScanTime);
        sb422222222.append(" ms, packageCount: ");
        sb422222222.append(systemPackagesCount);
        sb422222222.append(" , timePerPackage: ");
        sb422222222.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb422222222.append(" , cached: ");
        sb422222222.append(cachedSystemApps);
        Slog.i(TAG, sb422222222.toString());
        if (this.mIsUpgrade) {
        }
        r6 = null;
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        if (ver2.sdkVersion == this.mSdkVersion) {
        }
        if (sdkUpdated != 0) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver2.sdkVersion = this.mSdkVersion;
        ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
        if (onlyCore) {
        }
        if (!onlyCore) {
        }
        Slog.d(TAG, "No need to do anything to prime domain");
        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i2 = i;
        List<String> deferPackages222222222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
        int storageFlags3222222222 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages222222222, storageFlags3222222222) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        if (!onlyCore) {
        }
        z2 = i2;
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = z2;
        ver2.databaseVersion = 3;
        if (!isSettingsDirty) {
        }
        long hwStartTime8222222222 = HwPackageManagerServiceUtils.hwTimingsBegin();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime8222222222);
        hwStartTime5 = hwStartTime8222222222;
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222222222 = new HashMap<>();
        while (r5 < r4) {
        }
        this.mDexManager.load(userPackages222222222);
        if (this.mIsUpgrade) {
        }
        this.mSettings.clearReservedUidMap();
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        Trace.traceEnd(262144);
    }

    public /* synthetic */ void lambda$new$1$PackageManagerService(List deferPackages, int storageFlags) {
        TimingsTraceLog traceLog = new TimingsTraceLog("SystemServerTimingAsync", 262144);
        traceLog.traceBegin("AppDataFixup");
        try {
            this.mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, 3);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, "Trouble fixing GIDs", e);
        }
        traceLog.traceEnd();
        traceLog.traceBegin("AppDataPrepare");
        if (deferPackages != null && !deferPackages.isEmpty()) {
            int count = 0;
            Iterator it = deferPackages.iterator();
            while (it.hasNext()) {
                String pkgName = (String) it.next();
                PackageParser.Package pkg = null;
                synchronized (this.mPackages) {
                    PackageSetting ps = this.mSettings.getPackageLPr(pkgName);
                    if (ps != null && ps.getInstalled(0)) {
                        pkg = ps.pkg;
                    }
                }
                if (pkg != null) {
                    synchronized (this.mInstallLock) {
                        prepareAppDataAndMigrateLIF(pkg, 0, storageFlags, true);
                    }
                    count++;
                }
            }
            traceLog.traceEnd();
            Slog.i(TAG, "Deferred reconcileAppsData finished " + count + " packages");
        }
    }

    private boolean isUpgradeAndEmuiVersionUpgrade() {
        return this.mIsUpgrade && this.mIsEmuiVersionUpgrade;
    }

    private void installSystemStubPackages(List<String> systemStubPackageNames, int scanFlags) {
        int i = systemStubPackageNames.size();
        while (true) {
            i--;
            if (i < 0) {
                break;
            }
            String packageName = systemStubPackageNames.get(i);
            if (this.mSettings.isDisabledSystemPackageLPr(packageName)) {
                systemStubPackageNames.remove(i);
            } else {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                if (pkg == null) {
                    systemStubPackageNames.remove(i);
                } else {
                    PackageSetting ps = this.mSettings.mPackages.get(packageName);
                    if (ps == null || ps.getEnabled(0) != 3) {
                        try {
                            installStubPackageLI(pkg, 0, scanFlags);
                            ps.setEnabled(0, 0, PLATFORM_PACKAGE_NAME);
                            systemStubPackageNames.remove(i);
                        } catch (PackageManagerException e) {
                            Slog.e(TAG, "Failed to parse uncompressed system package: " + e.getMessage());
                        }
                    } else {
                        systemStubPackageNames.remove(i);
                    }
                }
            }
        }
        for (int i2 = systemStubPackageNames.size() - 1; i2 >= 0; i2 += -1) {
            String pkgName = systemStubPackageNames.get(i2);
            this.mSettings.mPackages.get(pkgName).setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            PackageManagerServiceUtils.logCriticalInfo(6, "Stub disabled; pkg: " + pkgName);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0065, code lost:
        r6 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x0066, code lost:
        if (r4 != null) goto L_0x0068;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0068, code lost:
        $closeResource(r5, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x006b, code lost:
        throw r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x00b6, code lost:
        r7 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x00b7, code lost:
        if (r6 != null) goto L_0x00b9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x00b9, code lost:
        $closeResource(r2, r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x00bc, code lost:
        throw r7;
     */
    private boolean enableCompressedPackage(PackageParser.Package stubPkg) {
        int parseFlags = this.mDefParseFlags | Integer.MIN_VALUE | 64;
        synchronized (this.mInstallLock) {
            try {
                PackageFreezer freezer = freezePackage(stubPkg.packageName, "setEnabledSetting");
                PackageParser.Package pkg = installStubPackageLI(stubPkg, parseFlags, 0);
                synchronized (this.mPackages) {
                    prepareAppDataAfterInstallLIF(pkg);
                    try {
                        updateSharedLibrariesLocked(pkg, null, this.mPackages);
                    } catch (PackageManagerException e) {
                        Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", e);
                    }
                    this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                    this.mSettings.writeLPr();
                }
                if (freezer != null) {
                    $closeResource(null, freezer);
                }
                clearAppDataLIF(pkg, -1, 39);
                this.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
            } catch (PackageManagerException e2) {
                try {
                    PackageFreezer freezer2 = freezePackage(stubPkg.packageName, "setEnabledSetting");
                    synchronized (this.mPackages) {
                        enableSystemPackageLPw(stubPkg);
                        installPackageFromSystemLIF(stubPkg.codePath, null, null, null, true);
                        if (freezer2 != null) {
                            $closeResource(null, freezer2);
                        }
                        synchronized (this.mPackages) {
                            PackageSetting stubPs = this.mSettings.mPackages.get(stubPkg.packageName);
                            if (stubPs != null) {
                                stubPs.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            }
                            this.mSettings.writeLPr();
                            return false;
                        }
                    }
                } catch (PackageManagerException pme) {
                    try {
                        Slog.wtf(TAG, "Failed to restore system package:" + stubPkg.packageName, pme);
                        synchronized (this.mPackages) {
                            PackageSetting stubPs2 = this.mSettings.mPackages.get(stubPkg.packageName);
                            if (stubPs2 != null) {
                                stubPs2.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            }
                            this.mSettings.writeLPr();
                        }
                    } catch (Throwable th) {
                        th = th;
                    }
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
        return true;
        throw th;
    }

    private static /* synthetic */ void $closeResource(Throwable x0, AutoCloseable x1) {
        if (x0 != null) {
            try {
                x1.close();
            } catch (Throwable th) {
                x0.addSuppressed(th);
            }
        } else {
            x1.close();
        }
    }

    private PackageParser.Package installStubPackageLI(PackageParser.Package stubPkg, int parseFlags, int scanFlags) throws PackageManagerException {
        if (DEBUG_COMPRESSION) {
            Slog.i(TAG, "Uncompressing system stub; pkg: " + stubPkg.packageName);
        }
        File scanFile = decompressPackage(stubPkg.packageName, stubPkg.codePath);
        if (scanFile != null) {
            synchronized (this.mPackages) {
                this.mSettings.disableSystemPackageLPw(stubPkg.packageName, true);
            }
            removePackageLI(stubPkg, true);
            try {
                return scanPackageTracedLI(scanFile, parseFlags, scanFlags, 0, (UserHandle) null);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to install compressed system package:" + stubPkg.packageName, e);
                removeCodePathLI(scanFile);
                throw e;
            }
        } else {
            throw new PackageManagerException("Unable to decompress stub at " + stubPkg.codePath);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x0098  */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d0  */
    /* JADX WARNING: Removed duplicated region for block: B:37:0x00db A[RETURN] */
    private File decompressPackage(String packageName, String codePath) {
        int ret;
        int ret2;
        File[] compressedFiles = PackageManagerServiceUtils.getCompressedFiles(codePath);
        if (compressedFiles == null || compressedFiles.length == 0) {
            if (DEBUG_COMPRESSION) {
                Slog.i(TAG, "No files to decompress: " + codePath);
            }
            return null;
        }
        File dstCodePath = getNextCodePath(Environment.getDataAppDirectory(null), packageName);
        try {
            Os.mkdir(dstCodePath.getAbsolutePath(), 493);
            Os.chmod(dstCodePath.getAbsolutePath(), 493);
            int length = compressedFiles.length;
            ret = 1;
            int ret3 = 0;
            while (true) {
                if (ret3 >= length) {
                    break;
                }
                try {
                    File srcFile = compressedFiles[ret3];
                    String srcFileName = srcFile.getName();
                    String dstFileName = srcFileName.substring(0, srcFileName.length() - COMPRESSED_EXTENSION.length());
                    ret = PackageManagerServiceUtils.decompressFile(srcFile, new File(dstCodePath, dstFileName));
                    if (ret != 1) {
                        PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", file: " + dstFileName);
                        break;
                    }
                    ret3++;
                } catch (ErrnoException e) {
                    e = e;
                    PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", err: " + e.errno);
                    if (ret == 1) {
                    }
                    if (ret == 1) {
                    }
                }
            }
        } catch (ErrnoException e2) {
            e = e2;
            ret = 1;
            PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", err: " + e.errno);
            if (ret == 1) {
            }
            if (ret == 1) {
            }
        }
        if (ret == 1) {
            File libraryRoot = new File(dstCodePath, "lib");
            NativeLibraryHelper.Handle handle = null;
            try {
                handle = NativeLibraryHelper.Handle.create(dstCodePath);
                ret2 = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, (String) null);
            } catch (IOException e3) {
                PackageManagerServiceUtils.logCriticalInfo(6, "Failed to extract native libraries; pkg: " + packageName);
                ret2 = RequestStatus.SYS_ETIMEDOUT;
            } catch (Throwable th) {
                IoUtils.closeQuietly(handle);
                throw th;
            }
            IoUtils.closeQuietly(handle);
        }
        if (ret == 1) {
            return dstCodePath;
        }
        if (!dstCodePath.exists()) {
            return null;
        }
        removeCodePathLI(dstCodePath);
        return null;
    }

    @GuardedBy({"mPackages"})
    private void updateInstantAppInstallerLocked(String modifiedPackage) {
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        if (activityInfo == null || activityInfo.getComponentName().getPackageName().equals(modifiedPackage)) {
            setUpInstantAppInstallerActivityLP(getInstantAppInstallerLPr());
        }
    }

    private static File preparePackageParserCache(boolean isUpgrade) {
        Slog.i(TAG, "preparePackageParserCache, isUpgrade= " + isUpgrade);
        if (Build.IS_ENG) {
            return null;
        }
        if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
            Slog.i(TAG, "Disabling package parser cache due to system property.");
            return null;
        }
        File cacheBaseDir = Environment.getPackageCacheDirectory();
        if (!FileUtils.createDir(cacheBaseDir)) {
            return null;
        }
        String cacheName = SystemProperties.digestOf(new String[]{"ro.build.fingerprint", "persist.sys.isolated_storage", "sys.isolated_storage_snapshot"});
        File[] listFilesOrEmpty = FileUtils.listFilesOrEmpty(cacheBaseDir);
        for (File cacheDir : listFilesOrEmpty) {
            if (!Objects.equals(cacheName, cacheDir.getName()) || isUpgrade) {
                Slog.d(TAG, "Destroying unknown cache " + cacheDir.getName());
                FileUtils.deleteContentsAndDir(cacheDir);
            } else {
                Slog.d(TAG, "Keeping known cache " + cacheDir.getName());
            }
        }
        File cacheDir2 = FileUtils.createDir(cacheBaseDir, cacheName);
        if (cacheDir2 == null) {
            Slog.wtf(TAG, "Cache directory cannot be created - wiping base dir " + cacheBaseDir);
            FileUtils.deleteContentsAndDir(cacheBaseDir);
            return null;
        } else if (!Build.IS_USERDEBUG || !Build.VERSION.INCREMENTAL.startsWith("eng.")) {
            return cacheDir2;
        } else {
            Slog.w(TAG, "Wiping cache directory because the system partition changed.");
            if (cacheDir2.lastModified() >= new File(Environment.getRootDirectory(), "framework").lastModified()) {
                return cacheDir2;
            }
            FileUtils.deleteContents(cacheBaseDir);
            return FileUtils.createDir(cacheBaseDir, cacheName);
        }
    }

    public boolean isFirstBoot() {
        return this.mFirstBoot;
    }

    public boolean isOnlyCoreApps() {
        return this.mOnlyCore;
    }

    public boolean isDeviceUpgrading() {
        return this.mIsUpgrade || SystemProperties.getBoolean("persist.pm.mock-upgrade", false);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean isUpgrade() {
        return isDeviceUpgrading();
    }

    private String getRequiredButNotReallyRequiredVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        if (matches.size() == 0) {
            Log.e(TAG, "There should probably be a verifier, but, none were found");
            return null;
        }
        throw new RuntimeException("There must be exactly one verifier; found " + matches);
    }

    private String getRequiredSharedLibraryLPr(String name, int version) {
        String packageName;
        synchronized (this.mPackages) {
            SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(name, (long) version);
            if (libraryInfo != null) {
                packageName = libraryInfo.getPackageName();
                if (packageName == null) {
                    throw new IllegalStateException("Expected a package for shared library " + name);
                }
            } else {
                throw new IllegalStateException("Missing required shared library:" + name);
            }
        }
        return packageName;
    }

    private String getRequiredInstallerLPr() {
        Intent intent = new Intent("android.intent.action.INSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.parse("content://com.example/foo.apk"), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one installer; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The installer must be a privileged app");
        }
    }

    private String getRequiredUninstallerLPr() {
        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setData(Uri.fromParts("package", "foo.bar", null));
        ResolveInfo resolveInfo = resolveIntent(intent, null, 1835008, 0);
        if (resolveInfo != null && !this.mResolveActivity.name.equals(resolveInfo.getComponentInfo().name)) {
            return resolveInfo.getComponentInfo().packageName;
        }
        throw new RuntimeException("There must be exactly one uninstaller; found " + resolveInfo);
    }

    private String getRequiredPermissionControllerLPr() {
        Intent intent = new Intent("android.intent.action.MANAGE_PERMISSIONS");
        intent.addCategory("android.intent.category.DEFAULT");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one permissions manager; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The permissions manager must be a privileged app");
        }
    }

    private ComponentName getIntentFilterVerifierComponentNameLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        ResolveInfo best = null;
        int N = matches.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo cur = matches.get(i);
            if (checkPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", cur.getComponentInfo().packageName, 0) == 0 && (best == null || cur.priority > best.priority)) {
                best = cur;
            }
        }
        if (best != null) {
            return best.getComponentInfo().getComponentName();
        }
        Slog.w(TAG, "Intent filter verifier not found");
        return null;
    }

    public ComponentName getInstantAppResolverComponent() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Pair<ComponentName, String> instantAppResolver = getInstantAppResolverLPr();
            if (instantAppResolver == null) {
                return null;
            }
            return (ComponentName) instantAppResolver.first;
        }
    }

    private Pair<ComponentName, String> getInstantAppResolverLPr() {
        String[] packageArray = this.mContext.getResources().getStringArray(17236020);
        if (packageArray.length != 0 || Build.IS_DEBUGGABLE) {
            List<ResolveInfo> resolvers = queryIntentServicesInternal(new Intent("android.intent.action.RESOLVE_INSTANT_APP_PACKAGE"), null, (!Build.IS_DEBUGGABLE ? 1048576 : 0) | 786432, 0, Binder.getCallingUid(), false);
            int N = resolvers.size();
            if (N == 0) {
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, "Ephemeral resolver NOT found; no matching intent filters");
                }
                return null;
            }
            Set<String> possiblePackages = new ArraySet<>(Arrays.asList(packageArray));
            for (int i = 0; i < N; i++) {
                ResolveInfo info = resolvers.get(i);
                if (info.serviceInfo != null) {
                    String packageName = info.serviceInfo.packageName;
                    if (possiblePackages.contains(packageName) || Build.IS_DEBUGGABLE) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Ephemeral resolver found; pkg: " + packageName + ", info:" + info);
                        }
                        return new Pair<>(new ComponentName(packageName, info.serviceInfo.name), "android.intent.action.RESOLVE_INSTANT_APP_PACKAGE");
                    } else if (DEBUG_INSTANT) {
                        Slog.d(TAG, "Ephemeral resolver not in allowed package list; pkg: " + packageName + ", info:" + info);
                    }
                }
            }
            if (!DEBUG_INSTANT) {
                return null;
            }
            Slog.v(TAG, "Ephemeral resolver NOT found");
            return null;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Ephemeral resolver NOT found; empty package list");
        }
        return null;
    }

    @GuardedBy({"mPackages"})
    private ActivityInfo getInstantAppInstallerLPr() {
        String[] orderedActions;
        if (Build.IS_ENG) {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE_TEST", "android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        } else {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        }
        int resolveFlags = 786944 | (!Build.IS_ENG ? 1048576 : 0);
        Intent intent = new Intent();
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = null;
        for (String action : orderedActions) {
            intent.setAction(action);
            matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
            if (!matches.isEmpty()) {
                break;
            }
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Instant App installer not found with " + action);
            }
        }
        Iterator<ResolveInfo> iter = matches.iterator();
        while (iter.hasNext()) {
            PackageSetting ps = this.mSettings.mPackages.get(iter.next().activityInfo.packageName);
            if (ps == null || (!ps.getPermissionsState().hasPermission("android.permission.INSTALL_PACKAGES", 0) && !Build.IS_ENG)) {
                iter.remove();
            }
        }
        if (matches.size() == 0) {
            return null;
        }
        if (matches.size() == 1) {
            return (ActivityInfo) matches.get(0).getComponentInfo();
        }
        throw new RuntimeException("There must be at most one ephemeral installer; found " + matches);
    }

    private ComponentName getInstantAppResolverSettingsLPr(ComponentName resolver) {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.intent.action.INSTANT_APP_RESOLVER_SETTINGS").addCategory("android.intent.category.DEFAULT").setPackage(resolver.getPackageName()), null, 786432, 0);
        if (matches.isEmpty()) {
            return null;
        }
        return matches.get(0).getComponentInfo().getComponentName();
    }

    @GuardedBy({"mPackages"})
    private void primeDomainVerificationsLPw(int userId) {
        primeDomainVerificationsLPw(userId, 0);
    }

    private void primeDomainVerificationsLPw(int userId, int flag) {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Priming domain verifications in user " + userId);
        }
        Iterator<String> it = SystemConfig.getInstance().getLinkedApps().iterator();
        while (it.hasNext()) {
            String packageName = it.next();
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "Unknown package " + packageName + " in sysconfig <app-link>");
            } else if (!pkg.isSystem()) {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
            } else {
                ArraySet<String> domains = null;
                Iterator it2 = pkg.activities.iterator();
                while (it2.hasNext()) {
                    Iterator it3 = ((PackageParser.Activity) it2.next()).intents.iterator();
                    while (it3.hasNext()) {
                        PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it3.next();
                        if (hasValidDomains(filter)) {
                            if (domains == null) {
                                domains = new ArraySet<>();
                            }
                            domains.addAll(filter.getHostsList());
                        }
                    }
                }
                if (domains == null || domains.size() <= 0) {
                    Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "      + " + packageName);
                    }
                    if (this.mIsUpgrade && flag == 1) {
                        updateIntentFilterVerification(packageName, domains, userId);
                    } else if (flag == 0) {
                        IntentFilterVerificationInfo ivi = this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domains);
                        if (ivi != null) {
                            ivi.setStatus(0);
                            this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                        } else {
                            return;
                        }
                    } else {
                        Slog.w(TAG, "Unknown flag " + flag + " in sysconfig <app-link>");
                    }
                }
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        scheduleWriteSettingsLocked();
    }

    private void updateIntentFilterVerification(String packageName, ArraySet<String> domains, int userId) {
        PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
        if (packageSetting != null && packageSetting.getIntentFilterVerificationInfo() == null) {
            packageSetting.setIntentFilterVerificationInfo(new IntentFilterVerificationInfo(packageName, domains));
            this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
            Slog.i(TAG, "package " + packageName + " is a new application for hota upgrade, sysconfig app-link");
        }
    }

    private boolean packageIsBrowser(String packageName, int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo info = list.get(i);
            if (info.priority >= 0 && packageName.equals(info.activityInfo.packageName)) {
                return true;
            }
        }
        return false;
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            if (!(e instanceof SecurityException) && !(e instanceof IllegalArgumentException)) {
                Slog.wtf(TAG, "Package Manager Crash", e);
            }
            throw e;
        }
    }

    /* access modifiers changed from: private */
    public boolean canViewInstantApps(int callingUid, int userId) {
        if (callingUid < 10000 || this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS") == 0) {
            return true;
        }
        if (this.mContext.checkCallingOrSelfPermission("android.permission.VIEW_INSTANT_APPS") != 0) {
            return false;
        }
        ComponentName homeComponent = getDefaultHomeActivity(userId);
        if (homeComponent != null && isCallerSameApp(homeComponent.getPackageName(), callingUid)) {
            return true;
        }
        String str = this.mAppPredictionServicePackage;
        if (str == null || !isCallerSameApp(str, callingUid)) {
            return false;
        }
        return true;
    }

    /* access modifiers changed from: private */
    public PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
        int flags2;
        if (!sUserManager.exists(userId) || ps == null || filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
            return null;
        }
        if ((flags & 8192) == 0 || !ps.isSystem()) {
            flags2 = flags;
        } else {
            flags2 = flags | 4194304;
        }
        PackageUserState state = ps.readUserState(userId);
        PackageParser.Package p = ps.pkg;
        if (p != null) {
            PermissionsState permissionsState = ps.getPermissionsState();
            PackageInfo packageInfo = PackageParser.generatePackageInfo(p, (flags2 & 256) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(userId), flags2, ps.firstInstallTime, ps.lastUpdateTime, (flags2 & 4096) == 0 || ArrayUtils.isEmpty(p.requestedPermissions) ? Collections.emptySet() : permissionsState.getPermissions(userId), state, userId);
            if (packageInfo == null) {
                return null;
            }
            ApplicationInfo applicationInfo = packageInfo.applicationInfo;
            String resolveExternalPackageNameLPr = resolveExternalPackageNameLPr(p);
            applicationInfo.packageName = resolveExternalPackageNameLPr;
            packageInfo.packageName = resolveExternalPackageNameLPr;
            return packageInfo;
        } else if ((flags2 & 8192) == 0 || !state.isAvailable(flags2)) {
            return null;
        } else {
            PackageInfo pi = new PackageInfo();
            pi.packageName = ps.name;
            pi.setLongVersionCode(ps.versionCode);
            pi.sharedUserId = ps.sharedUser != null ? ps.sharedUser.name : null;
            pi.firstInstallTime = ps.firstInstallTime;
            pi.lastUpdateTime = ps.lastUpdateTime;
            ApplicationInfo ai = new ApplicationInfo();
            ai.packageName = ps.name;
            ai.uid = UserHandle.getUid(userId, ps.appId);
            ai.primaryCpuAbi = ps.primaryCpuAbiString;
            ai.secondaryCpuAbi = ps.secondaryCpuAbiString;
            ai.setVersionCode(ps.versionCode);
            ai.flags = ps.pkgFlags;
            ai.privateFlags = ps.pkgPrivateFlags;
            pi.applicationInfo = PackageParser.generateApplicationInfo(ai, flags2, state, userId);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "ps.pkg is n/a for [" + ps.name + "]. Provides a minimum info.");
            }
            return pi;
        }
    }

    public void checkPackageStartable(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            boolean userKeyUnlocked = StorageManager.isUserKeyUnlocked(userId);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new SecurityException("Package " + packageName + " was not found!");
                } else if (ps.getInstalled(userId)) {
                    if (this.mSafeMode) {
                        if (!ps.isSystem()) {
                            throw new SecurityException("Package " + packageName + " not a system app!");
                        }
                    }
                    if (this.mFrozenPackages.contains(packageName)) {
                        throw new SecurityException("Package " + packageName + " is currently frozen!");
                    } else if (!userKeyUnlocked) {
                        if (!ps.pkg.applicationInfo.isEncryptionAware()) {
                            throw new SecurityException("Package " + packageName + " is not encryption aware!");
                        }
                    }
                } else {
                    throw new SecurityException("Package " + packageName + " was not installed for user " + userId + "!");
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isPackageAvailable(String packageName, int userId) {
        PackageUserState state;
        if (!sUserManager.exists(userId)) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "is package available");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return false;
                }
                if (!(ps == null || (state = ps.readUserState(userId)) == null)) {
                    return PackageParser.isAvailable(state);
                }
            }
            return false;
        }
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        return getPackageInfoInternal(packageName, -1, flags, Binder.getCallingUid(), userId);
    }

    public PackageInfo getPackageInfoVersioned(VersionedPackage versionedPackage, int flags, int userId) {
        return getPackageInfoInternal(versionedPackage.getPackageName(), versionedPackage.getLongVersionCode(), flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    public PackageInfo getPackageInfoInternal(String packageName, long versionCode, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get package info");
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, versionCode);
            boolean matchFactoryOnly = (2097152 & flags2) != 0;
            if (matchFactoryOnly) {
                if ((flags2 & 1073741824) != 0) {
                    return this.mApexManager.getPackageInfo(packageName2, 2);
                }
                PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(packageName2);
                if (ps != null) {
                    if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                        return null;
                    }
                    if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                        return null;
                    }
                    return generatePackageInfo(ps, flags2, userId);
                }
            }
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                return null;
            }
            if (mHwPMSEx.isHwCustHiddenInfoPackage(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getPackageInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps2 = (PackageSetting) p.mExtras;
                if (filterSharedLibPackageLPr(ps2, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (ps2 != null && filterAppAccessLPr(ps2, filterCallingUid, userId)) {
                    return null;
                }
                return generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
            } else if (!matchFactoryOnly && (4202496 & flags2) != 0) {
                PackageSetting ps3 = this.mSettings.mPackages.get(packageName2);
                if (ps3 == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps3, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps3, filterCallingUid, userId)) {
                    return null;
                }
                return generatePackageInfo(ps3, flags2, userId);
            } else if (matchFactoryOnly || (1073741824 & flags2) == 0) {
                return null;
            } else {
                return this.mApexManager.getPackageInfo(packageName2, 1);
            }
        }
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component) {
        if (!isComponentVisibleToInstantApp(component, 1) && !isComponentVisibleToInstantApp(component, 3) && !isComponentVisibleToInstantApp(component, 4)) {
            return false;
        }
        return true;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component, int type) {
        if (type == 1) {
            PackageParser.Activity activity = this.mComponentResolver.getActivity(component);
            if (activity == null) {
                return false;
            }
            return ((1048576 & activity.info.flags) != 0) && ((2097152 & activity.info.flags) == 0);
        } else if (type == 2) {
            PackageParser.Activity activity2 = this.mComponentResolver.getReceiver(component);
            if (activity2 == null) {
                return false;
            }
            return ((1048576 & activity2.info.flags) != 0) && !((2097152 & activity2.info.flags) == 0);
        } else if (type == 3) {
            PackageParser.Service service = this.mComponentResolver.getService(component);
            return (service == null || (1048576 & service.info.flags) == 0) ? false : true;
        } else if (type == 4) {
            PackageParser.Provider provider = this.mComponentResolver.getProvider(component);
            return (provider == null || (1048576 & provider.info.flags) == 0) ? false : true;
        } else if (type == 0) {
            return isComponentVisibleToInstantApp(component);
        } else {
            return false;
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public boolean filterAppAccessLPr(PackageSetting ps, int callingUid, ComponentName component, int componentType, int userId) {
        if (Process.isIsolated(callingUid)) {
            callingUid = this.mIsolatedOwners.get(callingUid);
        }
        boolean callerIsInstantApp = getInstantAppPackageName(callingUid) != null;
        if (ps == null) {
            return callerIsInstantApp;
        }
        if (isCallerSameApp(ps.name, callingUid)) {
            return false;
        }
        if (callerIsInstantApp) {
            if (ps.getInstantApp(userId)) {
                return true;
            }
            if (component == null) {
                return !ps.pkg.visibleToInstantApps;
            }
            PackageParser.Instrumentation instrumentation = this.mInstrumentation.get(component);
            if (instrumentation == null || !isCallerSameApp(instrumentation.info.targetPackage, callingUid)) {
                return !isComponentVisibleToInstantApp(component, componentType);
            }
            return false;
        } else if (!ps.getInstantApp(userId) || canViewInstantApps(callingUid, userId)) {
            return false;
        } else {
            if (component != null) {
                return true;
            }
            return !this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId);
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public boolean filterAppAccessLPr(PackageSetting ps, int callingUid, int userId) {
        return filterAppAccessLPr(ps, callingUid, null, 0, userId);
    }

    @GuardedBy({"mPackages"})
    private boolean filterSharedLibPackageLPr(PackageSetting ps, int uid, int userId, int flags) {
        int index;
        if ((flags & DumpState.DUMP_HANDLE) != 0) {
            int appId = UserHandle.getAppId(uid);
            if (appId != 1000 && appId != 2000) {
                if (appId != 0) {
                    if (checkUidPermission("android.permission.INSTALL_PACKAGES", uid) == 0) {
                        return false;
                    }
                }
            }
            return false;
        }
        if (ps != null && ps.pkg != null) {
            if (ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(ps.pkg.staticSharedLibName, ps.pkg.staticSharedLibVersion);
                if (libraryInfo == null) {
                    return false;
                }
                String[] uidPackageNames = getPackagesForUid(UserHandle.getUid(userId, UserHandle.getAppId(uid)));
                if (uidPackageNames == null) {
                    return true;
                }
                for (String uidPackageName : uidPackageNames) {
                    if (ps.name.equals(uidPackageName)) {
                        return false;
                    }
                    PackageSetting uidPs = this.mSettings.getPackageLPr(uidPackageName);
                    if (uidPs != null && (index = ArrayUtils.indexOf(uidPs.usesStaticLibraries, libraryInfo.getName())) >= 0 && uidPs.pkg.usesStaticLibrariesVersions[index] == libraryInfo.getLongVersion()) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }

    public String[] currentToCanonicalPackageNames(String[] names) {
        boolean z;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            for (int i = names.length - 1; i >= 0; i--) {
                PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                boolean translateName = false;
                if (!(ps == null || ps.realName == null)) {
                    if (ps.getInstantApp(callingUserId) && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            z = false;
                            translateName = z;
                        }
                    }
                    z = true;
                    translateName = z;
                }
                out[i] = translateName ? ps.realName : names[i];
            }
        }
        return out;
    }

    public String[] canonicalToCurrentPackageNames(String[] names) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            boolean z = true;
            int i = names.length - 1;
            while (i >= 0) {
                String cur = this.mSettings.getRenamedPackageLPr(names[i]);
                boolean translateName = false;
                if (cur != null) {
                    PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                    boolean z2 = false;
                    if (!((ps == null || !ps.getInstantApp(callingUserId)) ? false : z) || canViewInstantApps || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        z2 = true;
                    }
                    translateName = z2;
                }
                out[i] = translateName ? cur : names[i];
                i--;
                z = true;
            }
        }
        return out;
    }

    public int getPackageUid(String packageName, int flags, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageUid");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null || !p.isMatch(flags2)) {
                if ((4202496 & flags2) == 0 || (ps = this.mSettings.mPackages.get(packageName)) == null || !ps.isMatch(flags2) || filterAppAccessLPr(ps, callingUid, userId)) {
                    return -1;
                }
                return UserHandle.getUid(userId, ps.appId);
            } else if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, userId)) {
                return -1;
            } else {
                return UserHandle.getUid(userId, p.applicationInfo.uid);
            }
        }
    }

    private boolean hasTargetSdkInUidLowerThan(int uid, int higherTargetSDK) {
        int userId = UserHandle.getUserId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
            boolean z = false;
            if (obj == null) {
                return false;
            }
            if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (!ps.getInstalled(userId)) {
                    return false;
                }
                if (ps.pkg.applicationInfo.targetSdkVersion < higherTargetSDK) {
                    z = true;
                }
                return z;
            } else if (!(obj instanceof SharedUserSetting)) {
                return false;
            } else {
                SharedUserSetting sus = (SharedUserSetting) obj;
                int numPkgs = sus.packages.size();
                for (int i = 0; i < numPkgs; i++) {
                    PackageSetting ps2 = sus.packages.valueAt(i);
                    if (ps2.getInstalled(userId)) {
                        if (ps2.pkg.applicationInfo.targetSdkVersion < higherTargetSDK) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
    }

    public int[] getPackageGids(String packageName, int flags, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageGids");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null && p.isMatch(flags2)) {
                PackageSetting ps2 = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps2, callingUid, userId)) {
                    return null;
                }
                return ps2.getPermissionsState().computeGids(userId);
            } else if ((4202496 & flags2) == 0 || (ps = this.mSettings.mPackages.get(packageName)) == null || !ps.isMatch(flags2) || filterAppAccessLPr(ps, callingUid, userId)) {
                return null;
            } else {
                return ps.getPermissionsState().computeGids(userId);
            }
        }
    }

    public PermissionInfo getPermissionInfo(String name, String packageName, int flags) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETPERMISSIONINFO);
        return this.mPermissionManager.getPermissionInfo(name, packageName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String groupName, int flags) {
        List<PermissionInfo> permissionList = this.mPermissionManager.getPermissionInfoByGroup(groupName, flags, getCallingUid());
        if (permissionList == null) {
            return null;
        }
        return new ParceledListSlice<>(permissionList);
    }

    public PermissionGroupInfo getPermissionGroupInfo(String groupName, int flags) {
        return this.mPermissionManager.getPermissionGroupInfo(groupName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
        List<PermissionGroupInfo> permissionList = this.mPermissionManager.getAllPermissionGroups(flags, getCallingUid());
        return permissionList == null ? ParceledListSlice.emptyList() : new ParceledListSlice<>(permissionList);
    }

    @GuardedBy({"mPackages"})
    private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int filterCallingUid, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId) || (ps = this.mSettings.mPackages.get(packageName)) == null || filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags) || filterAppAccessLPr(ps, filterCallingUid, userId)) {
            return null;
        }
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        ApplicationInfo ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
        if (ai != null) {
            ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
        }
        return ai;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        return getApplicationInfoInternal(packageName, flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    public ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForApplication(flags, userId, packageName);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
        }
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, -1);
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (mHwPMSEx.isHwCustHiddenInfoPackage(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getApplicationInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName2);
                if (ps == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                    return null;
                }
                ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags2, ps.readUserState(userId), userId);
                if (ai != null) {
                    ai.packageName = resolveExternalPackageNameLPr(p);
                }
                return ai;
            }
            if (!PLATFORM_PACKAGE_NAME.equals(packageName2)) {
                if (!"system".equals(packageName2)) {
                    if ((4202496 & flags2) == 0) {
                        return null;
                    }
                    return generateApplicationInfoFromSettingsLPw(packageName2, flags2, filterCallingUid, userId);
                }
            }
            return this.mAndroidApplication;
        }
    }

    @GuardedBy({"mPackages"})
    private String normalizePackageNameLPr(String packageName) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        return normalizedPackageName != null ? normalizedPackageName : packageName;
    }

    public void deletePreloadsFileCache() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", "deletePreloadsFileCache");
        File dir = Environment.getDataPreloadsFileCacheDirectory();
        Slog.i(TAG, "Deleting preloaded file cache " + dir);
        FileUtils.deleteContents(dir);
    }

    public void freeStorageAndNotify(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", null);
        this.mHandler.post(new Runnable(volumeUuid, freeStorageSize, storageFlags, observer) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$wVxjBUhhrST_8tgGFnKwa3dHr7w */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IPackageDataObserver f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$freeStorageAndNotify$2$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
            }
        });
    }

    public /* synthetic */ void lambda$freeStorageAndNotify$2$PackageManagerService(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted((String) null, success);
            } catch (RemoteException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", TAG);
        this.mHandler.post(new Runnable(volumeUuid, freeStorageSize, storageFlags, pi) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$JzZnAIsG_0v1PIJvKY2tajsOnWg */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IntentSender f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$freeStorage$3$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
            }
        });
    }

    public /* synthetic */ void lambda$freeStorage$3$PackageManagerService(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (pi != null) {
            try {
                pi.sendIntent(null, success ? 1 : 0, null, null, null);
            } catch (IntentSender.SendIntentException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
        long j;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File file = storage.findPathForUuid(volumeUuid);
        if (file.getUsableSpace() < bytes) {
            if (ENABLE_FREE_CACHE_V2) {
                boolean internalVolume = Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid);
                boolean aggressive = (storageFlags & 1) != 0;
                long reservedBytes = storage.getStorageCacheBytes(file, storageFlags);
                if (internalVolume && (aggressive || SystemProperties.getBoolean("persist.sys.preloads.file_cache_expired", false))) {
                    deletePreloadsFileCache();
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                if (internalVolume && aggressive) {
                    FileUtils.deleteContents(this.mCacheDir);
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 256);
                } catch (Installer.InstallerException e) {
                }
                if (file.getUsableSpace() < bytes) {
                    if (internalVolume && pruneUnusedStaticSharedLibraries(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "unused_static_shared_lib_min_cache_period", 7200000))) {
                        return;
                    }
                    if (!internalVolume || !this.mInstantAppRegistry.pruneInstalledInstantApps(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "installed_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                        try {
                            j = 604800000;
                            try {
                                this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 768);
                            } catch (Installer.InstallerException e2) {
                            }
                        } catch (Installer.InstallerException e3) {
                            j = 604800000;
                        }
                        if (file.getUsableSpace() < bytes) {
                            if (internalVolume && this.mInstantAppRegistry.pruneUninstalledInstantApps(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "uninstalled_instant_app_min_cache_period", j))) {
                                return;
                            }
                        } else {
                            return;
                        }
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else {
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, 0, 0);
                } catch (Installer.InstallerException e4) {
                }
                if (file.getUsableSpace() >= bytes) {
                    return;
                }
            }
            throw new IOException("Failed to free " + bytes + " on storage device at " + file);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:44:0x00db, code lost:
        if (r12 == null) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00dd, code lost:
        r0 = r12.size();
        r7 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00e3, code lost:
        if (r7 >= r0) goto L_0x010b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00e5, code lost:
        r8 = r12.get(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x00fd, code lost:
        if (deletePackageX(r8.getPackageName(), r8.getLongVersionCode(), 0, 2) != 1) goto L_0x0108;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0105, code lost:
        if (r9.getUsableSpace() < r21) goto L_0x0108;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0107, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0108, code lost:
        r7 = r7 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:?, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:?, code lost:
        return false;
     */
    private boolean pruneUnusedStaticSharedLibraries(long neededSpace, long maxCachePeriod) throws IOException {
        long now;
        int[] allUsers;
        StorageManager storage;
        long now2;
        StorageManager storage2;
        PackageManagerService packageManagerService = this;
        StorageManager storage3 = (StorageManager) packageManagerService.mContext.getSystemService(StorageManager.class);
        File volume = storage3.findPathForUuid(StorageManager.UUID_PRIVATE_INTERNAL);
        long now3 = System.currentTimeMillis();
        synchronized (packageManagerService.mPackages) {
            try {
                int[] allUsers2 = sUserManager.getUserIds();
                int libCount = packageManagerService.mSharedLibraries.size();
                int i = 0;
                List<VersionedPackage> packagesToDelete = null;
                while (i < libCount) {
                    try {
                        LongSparseArray<SharedLibraryInfo> versionedLib = packageManagerService.mSharedLibraries.valueAt(i);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            int j = 0;
                            while (true) {
                                if (j >= versionCount) {
                                    allUsers = allUsers2;
                                    storage = storage3;
                                    now = now3;
                                    break;
                                }
                                SharedLibraryInfo libInfo = versionedLib.valueAt(j);
                                if (!libInfo.isStatic()) {
                                    allUsers = allUsers2;
                                    storage = storage3;
                                    now = now3;
                                    break;
                                }
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                String internalPackageName = packageManagerService.resolveInternalPackageNameLPr(declaringPackage.getPackageName(), declaringPackage.getLongVersionCode());
                                PackageSetting ps = packageManagerService.mSettings.getPackageLPr(internalPackageName);
                                if (ps != null) {
                                    storage2 = storage3;
                                    try {
                                        if (now3 - ps.lastUpdateTime < maxCachePeriod) {
                                            now2 = now3;
                                        } else if (ps.pkg.isSystem()) {
                                            now2 = now3;
                                        } else {
                                            if (packagesToDelete == null) {
                                                try {
                                                    packagesToDelete = new ArrayList<>();
                                                } catch (Throwable th) {
                                                    th = th;
                                                    while (true) {
                                                        try {
                                                            break;
                                                        } catch (Throwable th2) {
                                                            th = th2;
                                                        }
                                                    }
                                                    throw th;
                                                }
                                            }
                                            now2 = now3;
                                            packagesToDelete.add(new VersionedPackage(internalPackageName, declaringPackage.getLongVersionCode()));
                                        }
                                    } catch (Throwable th3) {
                                        th = th3;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                } else {
                                    storage2 = storage3;
                                    now2 = now3;
                                }
                                j++;
                                packageManagerService = this;
                                storage3 = storage2;
                                allUsers2 = allUsers2;
                                versionedLib = versionedLib;
                                now3 = now2;
                            }
                        } else {
                            allUsers = allUsers2;
                            storage = storage3;
                            now = now3;
                        }
                        i++;
                        packageManagerService = this;
                        storage3 = storage;
                        allUsers2 = allUsers;
                        now3 = now;
                    } catch (Throwable th4) {
                        th = th4;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } catch (Throwable th5) {
                th = th5;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    private int updateFlags(int flags, int userId) {
        if ((flags & 786432) != 0) {
            return flags;
        }
        if (getUserManagerInternal().isUserUnlockingOrUnlocked(userId)) {
            return flags | 786432;
        }
        return flags | 524288;
    }

    /* access modifiers changed from: package-private */
    public UserManagerInternal getUserManagerInternal() {
        if (this.mUserManagerInternal == null) {
            this.mUserManagerInternal = (UserManagerInternal) LocalServices.getService(UserManagerInternal.class);
        }
        return this.mUserManagerInternal;
    }

    private ActivityManagerInternal getActivityManagerInternal() {
        if (this.mActivityManagerInternal == null) {
            this.mActivityManagerInternal = (ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class);
        }
        return this.mActivityManagerInternal;
    }

    private ActivityTaskManagerInternal getActivityTaskManagerInternal() {
        if (this.mActivityTaskManagerInternal == null) {
            this.mActivityTaskManagerInternal = (ActivityTaskManagerInternal) LocalServices.getService(ActivityTaskManagerInternal.class);
        }
        return this.mActivityTaskManagerInternal;
    }

    /* access modifiers changed from: private */
    public DeviceIdleController.LocalService getDeviceIdleController() {
        if (this.mDeviceIdleController == null) {
            this.mDeviceIdleController = (DeviceIdleController.LocalService) LocalServices.getService(DeviceIdleController.LocalService.class);
        }
        return this.mDeviceIdleController;
    }

    private StorageManagerInternal getStorageManagerInternal() {
        if (this.mStorageManagerInternal == null) {
            this.mStorageManagerInternal = (StorageManagerInternal) LocalServices.getService(StorageManagerInternal.class);
        }
        return this.mStorageManagerInternal;
    }

    private int updateFlagsForPackage(int flags, int userId, Object cookie) {
        boolean isCallerSystemUser = UserHandle.getCallingUserId() == 0;
        if ((flags & 4194304) != 0) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, !isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId), "MATCH_ANY_USER flag requires INTERACT_ACROSS_USERS permission at " + Debug.getCallers(5));
        } else if ((flags & 8192) != 0 && isCallerSystemUser && sUserManager.hasManagedProfile(0)) {
            flags |= 4194304;
        }
        return updateFlags(flags, userId);
    }

    private int updateFlagsForApplication(int flags, int userId, Object cookie) {
        return updateFlagsForPackage(flags, userId, cookie);
    }

    private int updateFlagsForComponent(int flags, int userId, Object cookie) {
        return updateFlags(flags, userId);
    }

    private Intent updateIntentForResolve(Intent intent) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED) {
            intent.addFlags(8);
        }
        return intent;
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, false, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, wantInstantApps, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps, boolean onlyExposedExplicitly) {
        int flags2;
        if (this.mSafeMode) {
            flags |= 1048576;
        }
        if (getInstantAppPackageName(callingUid) != null) {
            if (onlyExposedExplicitly) {
                flags |= DumpState.DUMP_APEX;
            }
            flags2 = flags | DumpState.DUMP_SERVICE_PERMISSIONS | 8388608;
        } else {
            boolean allowMatchInstant = true;
            boolean wantMatchInstant = (flags & 8388608) != 0;
            if (!wantInstantApps && (!wantMatchInstant || !canViewInstantApps(callingUid, userId))) {
                allowMatchInstant = false;
            }
            flags2 = flags & -50331649;
            if (!allowMatchInstant) {
                flags2 &= -8388609;
            }
        }
        return updateFlagsForComponent(flags2, userId, intent);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        return getActivityInfoInternal(component, flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    public ActivityInfo getActivityInfoInternal(ComponentName component, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, component);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
        }
        synchronized (this.mPackages) {
            PackageParser.Activity a = this.mComponentResolver.getActivity(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getActivityInfo " + component + ": " + a);
            }
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, component, 1, userId)) {
                    return null;
                }
                return PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
            } else if (!this.mResolveComponentName.equals(component)) {
                return null;
            } else {
                return PackageParser.generateActivityInfo(this.mResolveActivity, flags2, new PackageUserState(), userId);
            }
        }
    }

    private boolean isRecentsAccessingChildProfiles(int callingUid, int targetUserId) {
        if (!getActivityTaskManagerInternal().isCallerRecents(callingUid)) {
            return false;
        }
        long token = Binder.clearCallingIdentity();
        try {
            int callingUserId = UserHandle.getUserId(callingUid);
            if (ActivityManager.getCurrentUser() != callingUserId) {
                return false;
            }
            boolean isSameProfileGroup = sUserManager.isSameProfileGroup(callingUserId, targetUserId);
            Binder.restoreCallingIdentity(token);
            return isSameProfileGroup;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public boolean activitySupportsIntent(ComponentName component, Intent intent, String resolvedType) {
        synchronized (this.mPackages) {
            if (component.equals(this.mResolveComponentName)) {
                return true;
            }
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Activity a = this.mComponentResolver.getActivity(component);
            if (a == null) {
                return false;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return false;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 1, callingUserId)) {
                return false;
            }
            for (int i = 0; i < a.intents.size(); i++) {
                if (((PackageParser.ActivityIntentInfo) a.intents.get(i)).match(intent.getAction(), resolvedType, intent.getScheme(), intent.getData(), intent.getCategories(), TAG) >= 0) {
                    return true;
                }
            }
            return false;
        }
    }

    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get receiver info");
        synchronized (this.mPackages) {
            PackageParser.Activity a = this.mComponentResolver.getReceiver(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getReceiverInfo " + component + ": " + a);
            }
            if (a == null || !this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 2, userId)) {
                return null;
            }
            return PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:15:0x0056, code lost:
        if (r30.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_SHARED_LIBRARIES") != 0) goto L_0x005f;
     */
    public ParceledListSlice<SharedLibraryInfo> getSharedLibraries(String packageName, int flags, int userId) {
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        ArrayList arrayList;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId, null);
        int checkCallingOrSelfPermission = this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES");
        boolean canSeeStaticLibraries = false;
        int i = DumpState.DUMP_HANDLE;
        if (checkCallingOrSelfPermission != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_PACKAGES") != 0) {
                if (!canRequestPackageInstallsInternal(packageName, DumpState.DUMP_HANDLE, userId, false)) {
                    if (this.mContext.checkCallingOrSelfPermission("android.permission.REQUEST_DELETE_PACKAGES") != 0) {
                    }
                }
            }
        }
        canSeeStaticLibraries = true;
        synchronized (this.mPackages) {
            List<SharedLibraryInfo> result = null;
            int libCount = this.mSharedLibraries.size();
            int i2 = 0;
            while (i2 < libCount) {
                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.valueAt(i2);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    List<SharedLibraryInfo> result2 = result;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryInfo libInfo = versionedLib.valueAt(j);
                        if (!canSeeStaticLibraries && libInfo.isStatic()) {
                            break;
                        }
                        long identity = Binder.clearCallingIdentity();
                        try {
                            if (getPackageInfoVersioned(libInfo.getDeclaringPackage(), flags2 | i, userId) != null) {
                                Binder.restoreCallingIdentity(identity);
                                String path = libInfo.getPath();
                                String packageName2 = libInfo.getPackageName();
                                List allCodePaths = libInfo.getAllCodePaths();
                                String name = libInfo.getName();
                                long longVersion = libInfo.getLongVersion();
                                int type = libInfo.getType();
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                List<VersionedPackage> packagesUsingSharedLibraryLPr = getPackagesUsingSharedLibraryLPr(libInfo, flags2, userId);
                                if (libInfo.getDependencies() == null) {
                                    arrayList = null;
                                } else {
                                    arrayList = new ArrayList(libInfo.getDependencies());
                                }
                                SharedLibraryInfo resLibInfo = new SharedLibraryInfo(path, packageName2, allCodePaths, name, longVersion, type, declaringPackage, packagesUsingSharedLibraryLPr, arrayList);
                                if (result2 == null) {
                                    result2 = new ArrayList<>();
                                }
                                result2.add(resLibInfo);
                            }
                            j++;
                            i = DumpState.DUMP_HANDLE;
                        } finally {
                            Binder.restoreCallingIdentity(identity);
                        }
                    }
                    result = result2;
                }
                i2++;
                i = DumpState.DUMP_HANDLE;
            }
            parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
        }
        return parceledListSlice;
    }

    public ParceledListSlice<SharedLibraryInfo> getDeclaredSharedLibraries(String packageName, int flags, int userId) {
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        PackageManagerService packageManagerService = this;
        packageManagerService.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_SHARED_LIBRARIES", "getDeclaredSharedLibraries");
        int callingUid = Binder.getCallingUid();
        packageManagerService.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "getDeclaredSharedLibraries");
        Preconditions.checkNotNull(packageName, "packageName cannot be null");
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        ArrayList arrayList = null;
        if (!sUserManager.exists(userId) || packageManagerService.getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (packageManagerService.mPackages) {
            List<SharedLibraryInfo> result = null;
            int libraryCount = packageManagerService.mSharedLibraries.size();
            int i = 0;
            while (i < libraryCount) {
                LongSparseArray<SharedLibraryInfo> versionedLibrary = packageManagerService.mSharedLibraries.valueAt(i);
                if (versionedLibrary != null) {
                    int versionCount = versionedLibrary.size();
                    int j = 0;
                    List<SharedLibraryInfo> result2 = result;
                    while (j < versionCount) {
                        SharedLibraryInfo libraryInfo = versionedLibrary.valueAt(j);
                        VersionedPackage declaringPackage = libraryInfo.getDeclaringPackage();
                        if (Objects.equals(declaringPackage.getPackageName(), packageName)) {
                            long identity = Binder.clearCallingIdentity();
                            try {
                                if (packageManagerService.getPackageInfoVersioned(declaringPackage, 67108864 | flags, userId) != null) {
                                    Binder.restoreCallingIdentity(identity);
                                    String path = libraryInfo.getPath();
                                    String packageName2 = libraryInfo.getPackageName();
                                    List allCodePaths = libraryInfo.getAllCodePaths();
                                    String name = libraryInfo.getName();
                                    long longVersion = libraryInfo.getLongVersion();
                                    int type = libraryInfo.getType();
                                    VersionedPackage declaringPackage2 = libraryInfo.getDeclaringPackage();
                                    List<VersionedPackage> packagesUsingSharedLibraryLPr = packageManagerService.getPackagesUsingSharedLibraryLPr(libraryInfo, flags, userId);
                                    if (libraryInfo.getDependencies() != null) {
                                        arrayList = new ArrayList(libraryInfo.getDependencies());
                                    }
                                    SharedLibraryInfo resultLibraryInfo = new SharedLibraryInfo(path, packageName2, allCodePaths, name, longVersion, type, declaringPackage2, packagesUsingSharedLibraryLPr, arrayList);
                                    if (result2 == null) {
                                        result2 = new ArrayList<>();
                                    }
                                    result2.add(resultLibraryInfo);
                                }
                            } finally {
                                Binder.restoreCallingIdentity(identity);
                            }
                        }
                        j++;
                        arrayList = null;
                        packageManagerService = this;
                    }
                    result = result2;
                }
                i++;
                arrayList = null;
                packageManagerService = this;
            }
            parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
        }
        return parceledListSlice;
    }

    @GuardedBy({"mPackages"})
    private List<VersionedPackage> getPackagesUsingSharedLibraryLPr(SharedLibraryInfo libInfo, int flags, int userId) {
        List<VersionedPackage> versionedPackages = null;
        int packageCount = this.mSettings.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            PackageSetting ps = this.mSettings.mPackages.valueAt(i);
            if (ps != null && ps.readUserState(userId).isAvailable(flags)) {
                String libName = libInfo.getName();
                if (libInfo.isStatic()) {
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0 && ps.usesStaticLibrariesVersions[libIdx] == libInfo.getLongVersion()) {
                        if (versionedPackages == null) {
                            versionedPackages = new ArrayList<>();
                        }
                        String dependentPackageName = ps.name;
                        if (ps.pkg != null && ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                            dependentPackageName = ps.pkg.manifestPackageName;
                        }
                        versionedPackages.add(new VersionedPackage(dependentPackageName, ps.versionCode));
                    }
                } else if (ps.pkg != null && (ArrayUtils.contains(ps.pkg.usesLibraries, libName) || ArrayUtils.contains(ps.pkg.usesOptionalLibraries, libName))) {
                    if (versionedPackages == null) {
                        versionedPackages = new ArrayList<>();
                    }
                    versionedPackages.add(new VersionedPackage(ps.name, ps.versionCode));
                }
            }
        }
        return versionedPackages;
    }

    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get service info");
        synchronized (this.mPackages) {
            PackageParser.Service s = this.mComponentResolver.getService(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getServiceInfo " + component + ": " + s);
            }
            if (s == null || !this.mSettings.isEnabledAndMatchLPr(s.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 3, userId)) {
                return null;
            }
            return PackageParser.generateServiceInfo(s, flags2, ps.readUserState(userId), userId);
        }
    }

    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get provider info");
        synchronized (this.mPackages) {
            PackageParser.Provider p = this.mComponentResolver.getProvider(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getProviderInfo " + component + ": " + p);
            }
            if (p == null || !this.mSettings.isEnabledAndMatchLPr(p.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 4, userId)) {
                return null;
            }
            return PackageParser.generateProviderInfo(p, flags2, ps.readUserState(userId), userId);
        }
    }

    public ModuleInfo getModuleInfo(String packageName, int flags) {
        return this.mModuleInfoProvider.getModuleInfo(packageName, flags);
    }

    public List<ModuleInfo> getInstalledModules(int flags) {
        return this.mModuleInfoProvider.getInstalledModules(flags);
    }

    public String[] getSystemSharedLibraryNames() {
        synchronized (this.mPackages) {
            Set<String> libs = null;
            int libCount = this.mSharedLibraries.size();
            for (int i = 0; i < libCount; i++) {
                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.valueAt(i);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryInfo libraryInfo = versionedLib.valueAt(j);
                        if (!libraryInfo.isStatic()) {
                            if (libs == null) {
                                libs = new ArraySet<>();
                            }
                            libs.add(libraryInfo.getName());
                        } else {
                            PackageSetting ps = this.mSettings.getPackageLPr(libraryInfo.getPackageName());
                            if (ps == null || filterSharedLibPackageLPr(ps, Binder.getCallingUid(), UserHandle.getUserId(Binder.getCallingUid()), DumpState.DUMP_HANDLE)) {
                                j++;
                            } else {
                                if (libs == null) {
                                    libs = new ArraySet<>();
                                }
                                libs.add(libraryInfo.getName());
                            }
                        }
                    }
                }
            }
            if (libs == null) {
                return null;
            }
            String[] libsArray = new String[libs.size()];
            libs.toArray(libsArray);
            return libsArray;
        }
    }

    public String getServicesSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mServicesSystemSharedLibraryPackageName;
        }
        return str;
    }

    public String getSharedSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mSharedSystemSharedLibraryPackageName;
        }
        return str;
    }

    @GuardedBy({"mPackages"})
    private void updateSequenceNumberLP(PackageSetting pkgSetting, int[] userList) {
        if (userList == null || userList.length == 0) {
            Slog.i(TAG, "updateSequenceNumberLP fail, userList is null or length = 0");
            return;
        }
        for (int i = userList.length - 1; i >= 0; i--) {
            int userId = userList[i];
            if (!pkgSetting.getInstantApp(userId)) {
                SparseArray<String> changedPackages = this.mChangedPackages.get(userId);
                if (changedPackages == null) {
                    changedPackages = new SparseArray<>();
                    this.mChangedPackages.put(userId, changedPackages);
                }
                Map<String, Integer> sequenceNumbers = this.mChangedPackagesSequenceNumbers.get(userId);
                if (sequenceNumbers == null) {
                    sequenceNumbers = new HashMap();
                    this.mChangedPackagesSequenceNumbers.put(userId, sequenceNumbers);
                }
                Integer sequenceNumber = sequenceNumbers.get(pkgSetting.name);
                if (sequenceNumber != null) {
                    changedPackages.remove(sequenceNumber.intValue());
                }
                changedPackages.put(this.mChangedPackagesSequenceNumber, pkgSetting.name);
                sequenceNumbers.put(pkgSetting.name, Integer.valueOf(this.mChangedPackagesSequenceNumber));
            }
        }
        this.mChangedPackagesSequenceNumber++;
    }

    public ChangedPackages getChangedPackages(int sequenceNumber, int userId) {
        ChangedPackages changedPackages = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (sequenceNumber >= this.mChangedPackagesSequenceNumber) {
                return null;
            }
            SparseArray<String> changedPackages2 = this.mChangedPackages.get(userId);
            if (changedPackages2 == null) {
                return null;
            }
            List<String> packageNames = new ArrayList<>(this.mChangedPackagesSequenceNumber - sequenceNumber);
            for (int i = sequenceNumber; i < this.mChangedPackagesSequenceNumber; i++) {
                String packageName = changedPackages2.get(i);
                if (packageName != null) {
                    packageNames.add(packageName);
                }
            }
            if (!packageNames.isEmpty()) {
                changedPackages = new ChangedPackages(this.mChangedPackagesSequenceNumber, packageNames);
            }
            return changedPackages;
        }
    }

    public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
        ArrayList<FeatureInfo> res;
        synchronized (this.mAvailableFeatures) {
            res = new ArrayList<>(this.mAvailableFeatures.size() + 1);
            res.addAll(this.mAvailableFeatures.values());
        }
        FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
        res.add(fi);
        return new ParceledListSlice<>(res);
    }

    public boolean hasSystemFeature(String name, int version) {
        boolean z = false;
        if (HwPackageManagerServiceUtils.isUnsupportedFeatrue(name)) {
            return false;
        }
        synchronized (this.mAvailableFeatures) {
            FeatureInfo feat = this.mAvailableFeatures.get(name);
            if (feat == null) {
                return false;
            }
            if (feat.version >= version) {
                z = true;
            }
            return z;
        }
    }

    public int checkPermission(String permName, String pkgName, int userId) {
        synchronized (this.mPackages) {
            if (this.mCheckPermissionDelegate == null) {
                return checkPermissionImpl(permName, pkgName, userId);
            }
            return this.mCheckPermissionDelegate.checkPermission(permName, pkgName, userId, new TriFunction() {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$b2Z8hEDt0dbtmX9ytdWFgSa9tc */

                public final Object apply(Object obj, Object obj2, Object obj3) {
                    return Integer.valueOf(PackageManagerService.this.checkPermissionImpl((String) obj, (String) obj2, ((Integer) obj3).intValue()));
                }
            });
        }
    }

    /* access modifiers changed from: private */
    public int checkPermissionImpl(String permName, String pkgName, int userId) {
        return this.mPermissionManager.checkPermission(permName, pkgName, getCallingUid(), userId);
    }

    public int checkUidPermission(String permName, int uid) {
        synchronized (this.mPackages) {
            if (UserHandle.isDuid(uid)) {
                return HwFrameworkSecurityPartsFactory.getInstance().getDPermissionManager().checkDPermission(uid, permName);
            } else if (this.mCheckPermissionDelegate == null) {
                return checkUidPermissionImpl(permName, uid);
            } else {
                return this.mCheckPermissionDelegate.checkUidPermission(permName, uid, new BiFunction() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$XJQWfaGM1EYfvHM2L3JN55XapIQ */

                    @Override // java.util.function.BiFunction
                    public final Object apply(Object obj, Object obj2) {
                        return Integer.valueOf(PackageManagerService.this.checkUidPermissionImpl((String) obj, ((Integer) obj2).intValue()));
                    }
                });
            }
        }
    }

    /* access modifiers changed from: private */
    public int checkUidPermissionImpl(String permName, int uid) {
        int checkUidPermission;
        synchronized (this.mPackages) {
            String[] packageNames = getPackagesForUid(uid);
            PackageParser.Package pkg = null;
            int N = packageNames == null ? 0 : packageNames.length;
            int i = 0;
            while (pkg == null && i < N) {
                pkg = this.mPackages.get(packageNames[i]);
                i++;
            }
            checkUidPermission = this.mPermissionManager.checkUidPermission(permName, pkg, uid, getCallingUid());
        }
        return checkUidPermission;
    }

    public boolean isPermissionRevokedByPolicy(String permission, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "isPermissionRevokedByPolicy for user " + userId);
        }
        boolean z = false;
        if (checkPermission(permission, packageName, userId) == 0) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            if (!isCallerSameApp(packageName, callingUid)) {
                return false;
            }
        } else if (isInstantApp(packageName, userId)) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            if ((getPermissionFlags(permission, packageName, userId) & 4) != 0) {
                z = true;
            }
            return z;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public String getPermissionControllerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredPermissionControllerPackage;
        }
        return str;
    }

    /* access modifiers changed from: package-private */
    public String getPackageInstallerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredInstallerPackage;
        }
        return str;
    }

    private boolean addDynamicPermission(PermissionInfo info, final boolean async) {
        return this.mPermissionManager.addDynamicPermission(info, async, getCallingUid(), new PermissionManagerServiceInternal.PermissionCallback() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass3 */

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionChanged() {
                if (!async) {
                    PackageManagerService.this.mSettings.writeLPr();
                } else {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }
        });
    }

    public boolean addPermission(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, false);
        }
        return addDynamicPermission;
    }

    public boolean addPermissionAsync(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, true);
        }
        return addDynamicPermission;
    }

    public void removePermission(String permName) {
        this.mPermissionManager.removeDynamicPermission(permName, getCallingUid(), this.mPermissionCallback);
    }

    public void grantRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.grantRuntimePermission(permName, packageName, checkUidPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", Binder.getCallingUid()) == 0, getCallingUid(), userId, this.mPermissionCallback);
        long start = HwPackageManagerServiceUtils.hwTimingsBeginWithTag(TAG, "notifyUidPermissionChanged for " + packageName);
        HwFrameworkSecurityPartsFactory.getInstance().getDPermissionManager().notifyUidPermissionChanged(getPackageUid(packageName, 0, userId));
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "notifyUidPermissionChanged for " + packageName, start);
    }

    public void revokeRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.revokeRuntimePermission(permName, packageName, checkUidPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", Binder.getCallingUid()) == 0, userId, this.mPermissionCallback);
    }

    public void resetRuntimePermissions() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 1000 || callingUid == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "resetRuntimePermissions");
        }
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
            int[] userIds = UserManagerService.getInstance().getUserIds();
            for (int userId : userIds) {
                int packageCount = this.mPackages.size();
                for (int i = 0; i < packageCount; i++) {
                    PackageParser.Package pkg = this.mPackages.valueAt(i);
                    if (pkg.mExtras instanceof PackageSetting) {
                        resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
                    }
                }
            }
        }
    }

    public int getPermissionFlags(String permName, String packageName, int userId) {
        return this.mPermissionManager.getPermissionFlags(permName, packageName, getCallingUid(), userId);
    }

    public void updatePermissionFlags(String permName, String packageName, int flagMask, int flagValues, boolean checkAdjustPolicyFlagPermission, int userId) {
        boolean overridePolicy;
        int callingUid = getCallingUid();
        boolean overridePolicy2 = false;
        if (callingUid == 1000 || callingUid == 0) {
            overridePolicy = false;
        } else {
            long callingIdentity = Binder.clearCallingIdentity();
            if ((flagMask & 4) != 0) {
                if (checkAdjustPolicyFlagPermission) {
                    try {
                        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "Need android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY to change policy flags");
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(callingIdentity);
                        throw th;
                    }
                } else if (!hasTargetSdkInUidLowerThan(callingUid, 29)) {
                    throw new IllegalArgumentException("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY needs  to be checked for packages targeting 29 or later when changing policy flags");
                }
                overridePolicy2 = true;
            }
            Binder.restoreCallingIdentity(callingIdentity);
            overridePolicy = overridePolicy2;
        }
        this.mPermissionManager.updatePermissionFlags(permName, packageName, flagMask, flagValues, callingUid, userId, overridePolicy, this.mPermissionCallback);
    }

    public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
        synchronized (this.mPackages) {
            if (this.mPermissionManager.updatePermissionFlagsForAllApps(flagMask, flagValues, getCallingUid(), userId, this.mPackages.values(), this.mPermissionCallback)) {
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }

    public List<String> getWhitelistedRestrictedPermissions(String packageName, int whitelistFlags, int userId) {
        Preconditions.checkNotNull(packageName);
        Preconditions.checkFlagsArgument(whitelistFlags, 7);
        Preconditions.checkArgumentNonNegative((float) userId, (String) null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", "getWhitelistedRestrictedPermissions for user " + userId);
        }
        synchronized (this.mPackages) {
            PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
            if (packageSetting == null) {
                Slog.w(TAG, "Unknown package: " + packageName);
                return null;
            }
            PackageParser.Package pkg = packageSetting.pkg;
            boolean isCallerInstallerOnRecord = false;
            boolean isCallerPrivileged = this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") == 0;
            PackageSetting installerPackageSetting = this.mSettings.mPackages.get(packageSetting.installerPackageName);
            if (installerPackageSetting != null && UserHandle.isSameApp(installerPackageSetting.appId, Binder.getCallingUid())) {
                isCallerInstallerOnRecord = true;
            }
            if ((whitelistFlags & 1) != 0) {
                if (!isCallerPrivileged) {
                    throw new SecurityException("Querying system whitelist requires android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if ((whitelistFlags & 6) != 0 && !isCallerPrivileged) {
                if (!isCallerInstallerOnRecord) {
                    throw new SecurityException("Querying upgrade or installer whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if (filterAppAccessLPr(packageSetting, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return null;
            }
            long identity = Binder.clearCallingIdentity();
            try {
                return this.mPermissionManager.getWhitelistedRestrictedPermissions(pkg, whitelistFlags, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public boolean addWhitelistedRestrictedPermission(String packageName, String permission, int whitelistFlags, int userId) {
        Preconditions.checkNotNull(permission);
        if (!checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(permission)) {
            return false;
        }
        List<String> permissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlags, userId);
        if (permissions == null) {
            permissions = new ArrayList(1);
        }
        if (permissions.indexOf(permission) >= 0) {
            return false;
        }
        permissions.add(permission);
        return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlags, userId);
    }

    private boolean checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(String permission) {
        synchronized (this.mPackages) {
            BasePermission bp = this.mPermissionManager.getPermissionTEMP(permission);
            if (bp == null) {
                Slog.w(TAG, "No such permissions: " + permission);
                return false;
            }
            if (bp.isHardOrSoftRestricted() && bp.isImmutablyRestricted()) {
                if (this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") != 0) {
                    throw new SecurityException("Cannot modify whitelisting of an immutably restricted permission: " + permission);
                }
            }
            return true;
        }
    }

    public boolean removeWhitelistedRestrictedPermission(String packageName, String permission, int whitelistFlags, int userId) {
        List<String> permissions;
        Preconditions.checkNotNull(permission);
        if (checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(permission) && (permissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlags, userId)) != null && permissions.remove(permission)) {
            return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlags, userId);
        }
        return false;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean setWhitelistedRestrictedPermissionsInner(String packageName, List<String> permissions, int whitelistFlag, int userId) {
        return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlag, userId);
    }

    private boolean setWhitelistedRestrictedPermissions(String packageName, List<String> permissions, int whitelistFlag, int userId) {
        Preconditions.checkNotNull(packageName);
        Preconditions.checkFlagsArgument(whitelistFlag, 7);
        Preconditions.checkArgument(Integer.bitCount(whitelistFlag) == 1);
        Preconditions.checkArgumentNonNegative((float) userId, (String) null);
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", "setWhitelistedRestrictedPermissions for user " + userId);
        }
        synchronized (this.mPackages) {
            PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
            if (packageSetting == null) {
                Slog.w(TAG, "Unknown package: " + packageName);
                return false;
            }
            PackageParser.Package pkg = packageSetting.pkg;
            boolean isCallerPrivileged = this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") == 0;
            PackageSetting installerPackageSetting = this.mSettings.mPackages.get(packageSetting.installerPackageName);
            boolean isCallerInstallerOnRecord = installerPackageSetting != null && UserHandle.isSameApp(installerPackageSetting.appId, Binder.getCallingUid());
            if ((whitelistFlag & 1) != 0) {
                if (!isCallerPrivileged) {
                    throw new SecurityException("Modifying system whitelist requires android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if ((whitelistFlag & 4) != 0) {
                if (!isCallerPrivileged) {
                    if (!isCallerInstallerOnRecord) {
                        throw new SecurityException("Modifying upgrade whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                    }
                }
                List<String> whitelistedPermissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlag, userId);
                if (permissions != null) {
                    if (!permissions.isEmpty()) {
                        int permissionCount = permissions.size();
                        for (int i = 0; i < permissionCount; i++) {
                            if ((whitelistedPermissions == null || !whitelistedPermissions.contains(permissions.get(i))) && !isCallerPrivileged) {
                                throw new SecurityException("Adding to upgrade whitelist requiresandroid.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                            }
                        }
                    }
                }
                if (whitelistedPermissions == null || whitelistedPermissions.isEmpty()) {
                    return true;
                }
            }
            if ((whitelistFlag & 2) != 0 && !isCallerPrivileged) {
                if (!isCallerInstallerOnRecord) {
                    throw new SecurityException("Modifying installer whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if (filterAppAccessLPr(packageSetting, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            long identity = Binder.clearCallingIdentity();
            try {
                this.mPermissionManager.setWhitelistedRestrictedPermissions(pkg, new int[]{userId}, permissions, Process.myUid(), whitelistFlag, this.mPermissionCallback);
                return true;
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    /* JADX INFO: finally extract failed */
    public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "canShowRequestPermissionRationale for user " + userId);
        }
        if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(getPackageUid(packageName, 268435456, userId)) || checkPermission(permissionName, packageName, userId) == 0) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            int flags = getPermissionFlags(permissionName, packageName, userId);
            Binder.restoreCallingIdentity(identity);
            if ((flags & 22) == 0 && (flags & 1) != 0) {
                return true;
            }
            return false;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
            throw th;
        }
    }

    public void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS", "addOnPermissionsChangeListener");
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.addListenerLocked(listener);
        }
    }

    public void removeOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                this.mOnPermissionChangeListeners.removeListenerLocked(listener);
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isProtectedBroadcast(String actionName) {
        synchronized (this.mProtectedBroadcasts) {
            if (this.mProtectedBroadcasts.contains(actionName)) {
                return true;
            }
            if (actionName == null || (!actionName.startsWith("android.net.netmon.lingerExpired") && !actionName.startsWith("com.android.server.sip.SipWakeupTimer") && !actionName.startsWith("com.android.internal.telephony.data-reconnect") && !actionName.startsWith("android.net.netmon.launchCaptivePortalApp"))) {
                return false;
            }
            return true;
        }
    }

    public int checkSignatures(String pkg1, String pkg2) {
        synchronized (this.mPackages) {
            PackageParser.Package p1 = this.mPackages.get(pkg1);
            PackageParser.Package p2 = this.mPackages.get(pkg2);
            if (!(p1 == null || p1.mExtras == null || p2 == null)) {
                if (p2.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    int callingUserId = UserHandle.getUserId(callingUid);
                    PackageSetting ps2 = (PackageSetting) p2.mExtras;
                    if (!filterAppAccessLPr((PackageSetting) p1.mExtras, callingUid, callingUserId)) {
                        if (!filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                            return PackageManagerServiceUtils.compareSignatures(p1.mSigningDetails.signatures, p2.mSigningDetails.signatures);
                        }
                    }
                    return -4;
                }
            }
            return -4;
        }
    }

    public int checkUidSignatures(int uid1, int uid2) {
        Signature[] s1;
        Signature[] s2;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int appId1 = UserHandle.getAppId(uid1);
        int appId2 = UserHandle.getAppId(uid2);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId1);
            if (obj == null) {
                return -4;
            }
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s1 = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
            } else if (!(obj instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return -4;
                }
                s1 = ps.signatures.mSigningDetails.signatures;
            }
            Object obj2 = this.mSettings.getSettingLPr(appId2);
            if (obj2 == null) {
                return -4;
            }
            if (obj2 instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s2 = ((SharedUserSetting) obj2).signatures.mSigningDetails.signatures;
            } else if (!(obj2 instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps2 = (PackageSetting) obj2;
                if (filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                    return -4;
                }
                s2 = ps2.signatures.mSigningDetails.signatures;
            }
            return PackageManagerServiceUtils.compareSignatures(s1, s2);
        }
    }

    public boolean hasSigningCertificate(String packageName, byte[] certificate, int type) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                if (p.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                        return false;
                    }
                    if (type == 0) {
                        return p.mSigningDetails.hasCertificate(certificate);
                    } else if (type != 1) {
                        return false;
                    } else {
                        return p.mSigningDetails.hasSha256Certificate(certificate);
                    }
                }
            }
            return false;
        }
    }

    public boolean hasUidSigningCertificate(int uid, byte[] certificate, int type) {
        PackageParser.SigningDetails signingDetails;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj == null) {
                return false;
            }
            if (obj instanceof SharedUserSetting) {
                if (getInstantAppPackageName(callingUid) != null) {
                    return false;
                }
                signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
            } else if (!(obj instanceof PackageSetting)) {
                return false;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return false;
                }
                signingDetails = ps.signatures.mSigningDetails;
            }
            if (type == 0) {
                return signingDetails.hasCertificate(certificate);
            } else if (type != 1) {
                return false;
            } else {
                return signingDetails.hasSha256Certificate(certificate);
            }
        }
    }

    /* access modifiers changed from: private */
    public void killUid(int appId, int userId, String reason) {
        long identity = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killUid(appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private boolean isCompatSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return isCompatSignatureUpdateNeeded(getSettingsVersionForPackage(scannedPkg));
    }

    private static boolean isCompatSignatureUpdateNeeded(Settings.VersionInfo ver) {
        return ver.databaseVersion < 2;
    }

    private boolean isRecoverSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return isRecoverSignatureUpdateNeeded(getSettingsVersionForPackage(scannedPkg));
    }

    private static boolean isRecoverSignatureUpdateNeeded(Settings.VersionInfo ver) {
        return ver.databaseVersion < 3;
    }

    public List<String> getAllPackages() {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            if (canViewInstantApps(callingUid, callingUserId)) {
                return new ArrayList(this.mPackages.keySet());
            }
            String instantAppPkgName = getInstantAppPackageName(callingUid);
            List<String> result = new ArrayList<>();
            if (instantAppPkgName != null) {
                for (PackageParser.Package pkg : this.mPackages.values()) {
                    if (pkg.visibleToInstantApps) {
                        result.add(pkg.packageName);
                    }
                }
            } else {
                for (PackageParser.Package pkg2 : this.mPackages.values()) {
                    PackageSetting ps = pkg2.mExtras != null ? (PackageSetting) pkg2.mExtras : null;
                    if (ps == null || !ps.getInstantApp(callingUserId) || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        result.add(pkg2.packageName);
                    }
                }
            }
            return result;
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public String[] getPackagesForUid(int uid) {
        return getPackagesForUid_debug(uid, false);
    }

    private String[] getPackagesForUid_debug(int uid, boolean debug) {
        SharedUserSetting sus;
        int callingUid = Binder.getCallingUid();
        int i = 0;
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int userId = UserHandle.getUserId(uid);
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            try {
                Object obj = this.mSettings.getSettingLPr(appId);
                if (!(obj instanceof SharedUserSetting)) {
                    if (obj instanceof PackageSetting) {
                        PackageSetting ps = (PackageSetting) obj;
                        if (ps.getInstalled(userId) && !filterAppAccessLPr(ps, callingUid, userId)) {
                            return new String[]{ps.name};
                        }
                    }
                    return null;
                } else if (isCallerInstantApp) {
                    return null;
                } else {
                    SharedUserSetting sus2 = (SharedUserSetting) obj;
                    String[] res = new String[sus2.packages.size()];
                    Iterator<PackageSetting> it = sus2.packages.iterator();
                    while (it.hasNext()) {
                        PackageSetting ps2 = it.next();
                        if (debug) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Check shared package; installed? ");
                            sb.append(ps2.getInstalled(userId));
                            sb.append(", shared setting: ");
                            sb.append(ps2);
                            sb.append(", package setting: ");
                            sus = sus2;
                            sb.append(this.mSettings.mPackages.get(ps2.name));
                            Slog.e(TAG, sb.toString());
                        } else {
                            sus = sus2;
                        }
                        if (this.mIsUpgrade) {
                            PackageSetting psNow = this.mSettings.mPackages.get(ps2.name);
                            if (psNow != null && psNow.appId != ps2.appId) {
                                res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                                StringBuilder sbWarn = new StringBuilder();
                                sbWarn.append("getPackagesForUid ");
                                sbWarn.append(uid);
                                sbWarn.append(" warning, found package ");
                                sbWarn.append(ps2.name);
                                sbWarn.append(" was user id ");
                                sbWarn.append(ps2.appId);
                                sbWarn.append(", but mismatch ");
                                sbWarn.append(psNow.appId);
                                sbWarn.append(" now!");
                                Slog.w(TAG, sbWarn.toString());
                                sus2 = sus;
                            }
                        }
                        if (ps2.getInstalled(userId)) {
                            res[i] = ps2.name;
                            i++;
                        } else {
                            res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                        }
                        sus2 = sus;
                    }
                    return res;
                }
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    public String getNameForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                SharedUserSetting sus = (SharedUserSetting) obj;
                return sus.name + ":" + sus.userId;
            } else if (!(obj instanceof PackageSetting)) {
                return null;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return null;
                }
                return ps.name;
            }
        }
    }

    public String[] getNamesForUids(int[] uids) {
        if (uids == null || uids.length == 0) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        String[] names = new String[uids.length];
        synchronized (this.mPackages) {
            for (int i = uids.length - 1; i >= 0; i--) {
                Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uids[i]));
                if (obj instanceof SharedUserSetting) {
                    names[i] = "shared:" + ((SharedUserSetting) obj).name;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                        names[i] = null;
                    } else {
                        names[i] = ps.name;
                    }
                } else {
                    names[i] = null;
                }
            }
        }
        return names;
    }

    public int getUidForSharedUser(String sharedUserName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || sharedUserName == null) {
            return -1;
        }
        synchronized (this.mPackages) {
            try {
                SharedUserSetting suid = this.mSettings.getSharedUserLPw(sharedUserName, 0, 0, false);
                if (suid == null) {
                    return -1;
                }
                return suid.userId;
            } catch (PackageManagerException e) {
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public int getFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                return ((SharedUserSetting) obj).pkgFlags;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                return ps.pkgFlags;
            }
        }
    }

    public int getPrivateFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                return ((SharedUserSetting) obj).pkgPrivateFlags;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                return ps.pkgPrivateFlags;
            }
        }
    }

    public boolean isUidPrivileged(int uid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
                while (it.hasNext()) {
                    if (it.next().isPrivileged()) {
                        return true;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                return ((PackageSetting) obj).isPrivileged();
            }
            return false;
        }
    }

    public String[] getAppOpPermissionPackages(String permName) {
        return this.mPermissionManager.getAppOpPermissionPackages(permName);
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        return resolveIntentInternal(intent, resolvedType, flags, userId, false, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    public ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
        try {
            Trace.traceBegin(262144, "resolveIntent");
            if (!sUserManager.exists(userId)) {
                Trace.traceEnd(262144);
                return null;
            }
            int callingUid = Binder.getCallingUid();
            int flags2 = updateFlagsForResolve(flags, userId, intent, filterCallingUid, resolveForStart);
            try {
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "resolve intent");
                Trace.traceBegin(262144, "queryIntentActivities");
                List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags2, filterCallingUid, userId, resolveForStart, true);
                Trace.traceEnd(262144);
                ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags2, query, userId);
                Trace.traceEnd(262144);
                return bestChoice;
            } catch (Throwable th) {
                th = th;
                Trace.traceEnd(262144);
                throw th;
            }
        } catch (Throwable th2) {
            th = th2;
            Trace.traceEnd(262144);
            throw th;
        }
    }

    public ResolveInfo findPersistentPreferredActivity(Intent intent, int userId) {
        ResolveInfo findPersistentPreferredActivityLP;
        if (!UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            throw new SecurityException("findPersistentPreferredActivity can only be run by the system");
        } else if (!sUserManager.exists(userId)) {
            return null;
        } else {
            int callingUid = Binder.getCallingUid();
            Intent intent2 = updateIntentForResolve(intent);
            String resolvedType = intent2.resolveTypeIfNeeded(this.mContext.getContentResolver());
            int flags = updateFlagsForResolve(0, userId, intent2, callingUid, false);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent2, resolvedType, flags, userId);
            synchronized (this.mPackages) {
                findPersistentPreferredActivityLP = findPersistentPreferredActivityLP(intent2, resolvedType, flags, query, false, userId);
            }
            return findPersistentPreferredActivityLP;
        }
    }

    public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
        int userId;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            int userId2 = UserHandle.getCallingUserId();
            if (DEBUG_PREFERRED) {
                Log.v(TAG, "setLastChosenActivity intent=" + intent + " resolvedType=" + resolvedType + " flags=" + flags + " filter=" + filter + " match=" + match + " activity=" + activity);
                filter.dump(new PrintStreamPrinter(System.out), "    ");
            }
            intent.setComponent(null);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId2);
            if (activity == null || "com.huawei.pcassistant".equals(activity.getPackageName())) {
                userId = userId2;
            } else {
                userId = userId2;
                findPreferredActivityNotLocked(intent, resolvedType, flags, query, 0, false, true, false, userId2);
            }
            addPreferredActivityInternal(filter, match, null, activity, false, userId, "Setting last chosen");
        }
    }

    public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int userId = UserHandle.getCallingUserId();
        if (DEBUG_PREFERRED) {
            Log.v(TAG, "Querying last chosen activity for " + intent);
        }
        return findPreferredActivityNotLocked(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, false, false, userId);
    }

    private boolean areWebInstantAppsDisabled(int userId) {
        return this.mWebInstantAppsDisabled.get(userId);
    }

    private boolean isInstantAppResolutionAllowed(Intent intent, List<ResolveInfo> resolvedActivities, int userId, boolean skipPackageCheck) {
        int status;
        if (this.mInstantAppResolverConnection == null || this.mInstantAppInstallerActivity == null || intent.getComponent() != null || (intent.getFlags() & 512) != 0) {
            return false;
        }
        if (!skipPackageCheck && intent.getPackage() != null) {
            return false;
        }
        if (!intent.isWebIntent()) {
            if (!(resolvedActivities == null || resolvedActivities.size() == 0) || (intent.getFlags() & 2048) == 0) {
                return false;
            }
        } else if (intent.getData() == null || TextUtils.isEmpty(intent.getData().getHost()) || areWebInstantAppsDisabled(userId)) {
            return false;
        }
        synchronized (this.mPackages) {
            int count = resolvedActivities == null ? 0 : resolvedActivities.size();
            for (int n = 0; n < count; n++) {
                ResolveInfo info = resolvedActivities.get(n);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    if (!info.handleAllWebDataURI && ((status = (int) (getDomainVerificationStatusLPr(ps, userId) >> 32)) == 2 || status == 4)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app; pkg: " + packageName + ", status: " + status);
                        }
                        return false;
                    } else if (ps.getInstantApp(userId)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app installed; pkg: " + packageName);
                        }
                        return false;
                    }
                }
            }
            return true;
        }
    }

    /* access modifiers changed from: private */
    public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(20, new InstantAppRequest(responseObj, origIntent, resolvedType, callingPackage, userId, verificationBundle, false)));
    }

    private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
        String str;
        ResolveInfo ri;
        if (query == null) {
            return null;
        }
        int N = query.size();
        if (N == 1) {
            return query.get(0);
        }
        if (N <= 1) {
            return null;
        }
        boolean debug = (intent.getFlags() & 8) != 0;
        ResolveInfo r0 = query.get(0);
        ResolveInfo r1 = query.get(1);
        if (DEBUG_INTENT_MATCHING || debug) {
            Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
        }
        if (r0.priority == r1.priority && r0.preferredOrder == r1.preferredOrder) {
            if (r0.isDefault == r1.isDefault) {
                if (mHwPMSEx.isFindPreferredActivityInCache(intent, resolvedType, userId)) {
                    ri = mHwPMSEx.findPreferredActivityInCache(intent, resolvedType, flags, query, userId);
                    str = TAG;
                } else {
                    int i = r0.priority;
                    str = TAG;
                    ri = findPreferredActivityNotLocked(intent, resolvedType, flags, query, i, true, false, debug, userId);
                }
                if (ri != null) {
                    return ri;
                }
                for (int i2 = 0; i2 < N; i2++) {
                    ResolveInfo ri2 = query.get(i2);
                    if (ri2.activityInfo == null) {
                        Slog.d(str, "chooseBestActivity activityInfo is Empty");
                    } else if (ri2.activityInfo.applicationInfo.isInstantApp()) {
                        if (((int) (getDomainVerificationStatusLPr(this.mSettings.mPackages.get(ri2.activityInfo.packageName), userId) >> 32)) != 4) {
                            return ri2;
                        }
                    } else {
                        continue;
                    }
                }
                ResolveInfo ri3 = new ResolveInfo(this.mResolveInfo);
                ri3.activityInfo = new ActivityInfo(ri3.activityInfo);
                ri3.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
                String intentPackage = intent.getPackage();
                if (!TextUtils.isEmpty(intentPackage) && allHavePackage(query, intentPackage)) {
                    ApplicationInfo appi = query.get(0).activityInfo.applicationInfo;
                    ri3.resolvePackageName = intentPackage;
                    if (userNeedsBadging(userId)) {
                        ri3.noResourceId = true;
                    } else {
                        ri3.icon = appi.icon;
                    }
                    ri3.iconResourceId = appi.icon;
                    ri3.labelRes = appi.labelRes;
                }
                ri3.activityInfo.applicationInfo = new ApplicationInfo(ri3.activityInfo.applicationInfo);
                if (userId != 0) {
                    ri3.activityInfo.applicationInfo.uid = UserHandle.getUid(userId, UserHandle.getAppId(ri3.activityInfo.applicationInfo.uid));
                }
                if (ri3.activityInfo.metaData == null) {
                    ri3.activityInfo.metaData = new Bundle();
                }
                ri3.activityInfo.metaData.putBoolean("android.dock_home", true);
                return ri3;
            }
        }
        return query.get(0);
    }

    private boolean allHavePackage(List<ResolveInfo> list, String packageName) {
        if (ArrayUtils.isEmpty(list)) {
            return false;
        }
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo ri = list.get(i);
            ActivityInfo ai = ri != null ? ri.activityInfo : null;
            if (ai == null || !packageName.equals(ai.packageName)) {
                return false;
            }
        }
        return true;
    }

    @GuardedBy({"mPackages"})
    private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
        List<PersistentPreferredActivity> pprefs;
        PackageManagerService packageManagerService = this;
        int i = flags;
        int N = query.size();
        PersistentPreferredIntentResolver ppir = packageManagerService.mSettings.mPersistentPreferredActivities.get(userId);
        if (DEBUG_PREFERRED || debug) {
            Slog.v(TAG, "Looking for presistent preferred activities...");
        }
        int i2 = 0;
        if (ppir != null) {
            pprefs = ppir.queryIntent(intent, resolvedType, (65536 & i) != 0, userId);
        } else {
            pprefs = null;
        }
        if (pprefs == null || pprefs.size() <= 0) {
            return null;
        }
        int M = pprefs.size();
        int i3 = 0;
        while (i3 < M) {
            PersistentPreferredActivity ppa = pprefs.get(i3);
            if (DEBUG_PREFERRED || debug) {
                StringBuilder sb = new StringBuilder();
                sb.append("Checking PersistentPreferredActivity ds=");
                sb.append(ppa.countDataSchemes() > 0 ? ppa.getDataScheme(i2) : "<none>");
                sb.append("\n  component=");
                sb.append(ppa.mComponent);
                Slog.v(TAG, sb.toString());
                ppa.dump(new LogPrinter(2, TAG, 3), "  ");
            }
            ActivityInfo ai = packageManagerService.getActivityInfo(ppa.mComponent, i | 512, userId);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Found persistent preferred activity:");
                if (ai != null) {
                    ai.dump(new LogPrinter(2, TAG, 3), "  ");
                } else {
                    Slog.v(TAG, "  null");
                }
            }
            if (ai != null) {
                for (int j = 0; j < N; j++) {
                    ResolveInfo ri = query.get(j);
                    if (ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri.activityInfo.name.equals(ai.name)) {
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Returning persistent preferred activity: " + ri.activityInfo.packageName + SliceClientPermissions.SliceAuthority.DELIMITER + ri.activityInfo.name);
                        }
                        return ri;
                    }
                }
                continue;
            }
            i3++;
            i2 = 0;
            packageManagerService = this;
            i = flags;
        }
        return null;
    }

    private boolean isHomeIntent(Intent intent) {
        return "android.intent.action.MAIN".equals(intent.getAction()) && intent.hasCategory("android.intent.category.HOME") && intent.hasCategory("android.intent.category.DEFAULT");
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Removed duplicated region for block: B:114:0x020a A[Catch:{ all -> 0x046f }] */
    /* JADX WARNING: Removed duplicated region for block: B:120:0x0237 A[Catch:{ all -> 0x046f }] */
    /* JADX WARNING: Removed duplicated region for block: B:145:0x02a1 A[Catch:{ all -> 0x046f }] */
    /* JADX WARNING: Removed duplicated region for block: B:148:0x02cc A[Catch:{ all -> 0x046f }] */
    /* JADX WARNING: Removed duplicated region for block: B:199:0x0446  */
    /* JADX WARNING: Removed duplicated region for block: B:227:0x04bd  */
    /* JADX WARNING: Removed duplicated region for block: B:243:0x0117 A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x0114 A[Catch:{ all -> 0x011f }] */
    public ResolveInfo findPreferredActivityNotLocked(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
        List<PreferredActivity> list;
        boolean changed;
        int M;
        List<PreferredActivity> prefs;
        int callingUid;
        PreferredActivity pa;
        boolean startupGuideEnabled;
        int match;
        boolean changed2;
        String str;
        ResolveInfo ri;
        boolean changed3;
        ResolveInfo pri;
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid2 = Binder.getCallingUid();
        boolean isDeviceProvisioned = Settings.Global.getInt(this.mContext.getContentResolver(), "device_provisioned", 0) == 1;
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid2, false);
        Intent intent2 = updateIntentForResolve(intent);
        synchronized (this.mPackages) {
            try {
                ResolveInfo pri2 = findPersistentPreferredActivityLP(intent2, resolvedType, flags2, query, debug, userId);
                if (pri2 != null) {
                    try {
                        return pri2;
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                } else {
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Looking for preferred activities...");
                    }
                    if (pir != null) {
                        list = pir.queryIntent(intent2, resolvedType, (65536 & flags2) != 0, userId);
                    } else {
                        list = null;
                    }
                    List<PreferredActivity> prefs2 = list;
                    if (prefs2 != null && prefs2.size() > 0) {
                        boolean changed4 = false;
                        try {
                            if (DEBUG_PREFERRED || debug) {
                                Slog.v(TAG, "Figuring out best match...");
                            }
                            int N = query.size();
                            int j = 0;
                            int match2 = 0;
                            while (j < N) {
                                try {
                                    ri = query.get(j);
                                    if (!DEBUG_PREFERRED) {
                                        if (!debug) {
                                            pri = pri2;
                                            changed3 = changed4;
                                            if (ri.match <= match2) {
                                                match2 = ri.match;
                                            }
                                            j++;
                                            pri2 = pri;
                                            changed4 = changed3;
                                        }
                                    }
                                    pri = pri2;
                                } catch (Throwable th2) {
                                    th = th2;
                                    if (changed4) {
                                    }
                                    throw th;
                                }
                                try {
                                    StringBuilder sb = new StringBuilder();
                                    changed3 = changed4;
                                    try {
                                        sb.append("Match for ");
                                        sb.append(ri.activityInfo);
                                        sb.append(": 0x");
                                        sb.append(Integer.toHexString(match2));
                                        Slog.v(TAG, sb.toString());
                                        if (ri.match <= match2) {
                                        }
                                        j++;
                                        pri2 = pri;
                                        changed4 = changed3;
                                    } catch (Throwable th3) {
                                        th = th3;
                                        changed4 = changed3;
                                        if (changed4) {
                                        }
                                        throw th;
                                    }
                                } catch (Throwable th4) {
                                    th = th4;
                                    if (changed4) {
                                    }
                                    throw th;
                                }
                            }
                            try {
                                if (DEBUG_PREFERRED || debug) {
                                    Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match2));
                                }
                                ComponentName startupGuideComp = new ComponentName("com.huawei.hwstartupguide", "com.huawei.hwstartupguide.LanguageSelectActivity");
                                boolean startupGuideEnabled2 = false;
                                if (isHomeIntent(intent2)) {
                                    try {
                                        startupGuideEnabled2 = this.mSettings.getComponentEnabledSettingLPr(startupGuideComp, userId) == 1;
                                    } catch (IllegalArgumentException e) {
                                        Slog.e(TAG, "setup wizard not exist.");
                                    }
                                }
                                int match3 = 268369920 & match2;
                                int M2 = prefs2.size();
                                int i = 0;
                                boolean changed5 = changed4;
                                while (i < M2) {
                                    try {
                                        PreferredActivity pa2 = prefs2.get(i);
                                        if (!DEBUG_PREFERRED) {
                                            if (!debug) {
                                                prefs = prefs2;
                                                M = M2;
                                                callingUid = callingUid2;
                                                pa = pa2;
                                                changed = changed5;
                                                if (pa.mPref.mMatch == match3) {
                                                    if (!DEBUG_PREFERRED) {
                                                        if (debug) {
                                                        }
                                                        match = match3;
                                                        startupGuideEnabled = startupGuideEnabled2;
                                                    }
                                                    Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa.mPref.mMatch));
                                                    match = match3;
                                                    startupGuideEnabled = startupGuideEnabled2;
                                                } else if (!always || pa.mPref.mAlways) {
                                                    ActivityInfo ai = getActivityInfo(pa.mPref.mComponent, flags2 | 512 | 524288 | 262144, userId);
                                                    if (!DEBUG_PREFERRED) {
                                                        if (!debug) {
                                                            match = match3;
                                                            boolean excludeSetupWizardHomeActivity = !isHomeIntent(intent2) && (!isDeviceProvisioned || startupGuideEnabled2);
                                                            if (ai == null) {
                                                                int j2 = 0;
                                                                while (j2 < N) {
                                                                    ResolveInfo ri2 = query.get(j2);
                                                                    startupGuideEnabled = startupGuideEnabled2;
                                                                    if (ri2.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                                                                        if (ri2.activityInfo.name.equals(ai.name)) {
                                                                            if (removeMatches) {
                                                                                pir.removeFilter(pa);
                                                                                changed4 = true;
                                                                                try {
                                                                                    if (DEBUG_PREFERRED) {
                                                                                        Slog.v(TAG, "Removing match " + pa.mPref.mComponent);
                                                                                    }
                                                                                    changed5 = true;
                                                                                    i++;
                                                                                    callingUid2 = callingUid;
                                                                                    match3 = match;
                                                                                    startupGuideComp = startupGuideComp;
                                                                                    prefs2 = prefs;
                                                                                    M2 = M;
                                                                                    startupGuideEnabled2 = startupGuideEnabled;
                                                                                } catch (Throwable th5) {
                                                                                    th = th5;
                                                                                    if (changed4) {
                                                                                    }
                                                                                    throw th;
                                                                                }
                                                                            } else {
                                                                                if (!HwPackageManagerServiceUtils.isSkipPreferredSetCheck(intent2) && always && !pa.mPref.sameSet(query, excludeSetupWizardHomeActivity)) {
                                                                                    if (!pa.mPref.isSuperset(query, excludeSetupWizardHomeActivity)) {
                                                                                        Slog.i(TAG, "Result set changed, dropping preferred activity for " + intent2 + " type " + resolvedType);
                                                                                        if (DEBUG_PREFERRED) {
                                                                                            Slog.v(TAG, "Removing preferred activity since set changed " + pa.mPref.mComponent);
                                                                                        }
                                                                                        pir.removeFilter(pa);
                                                                                        pir.addFilter(new PreferredActivity(pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false));
                                                                                        if (1 != 0) {
                                                                                            try {
                                                                                                if (DEBUG_PREFERRED) {
                                                                                                    Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                                                                }
                                                                                                scheduleWritePackageRestrictionsLocked(userId);
                                                                                            } catch (Throwable th6) {
                                                                                                th = th6;
                                                                                                throw th;
                                                                                            }
                                                                                        }
                                                                                        return null;
                                                                                    } else if (!excludeSetupWizardHomeActivity) {
                                                                                        if (DEBUG_PREFERRED) {
                                                                                            Slog.i(TAG, "Result set changed, but PreferredActivity is still valid as only non-preferred components were removed for " + intent2 + " type " + resolvedType);
                                                                                        }
                                                                                        PreferredActivity freshPa = new PreferredActivity(pa, pa.mPref.mMatch, pa.mPref.discardObsoleteComponents(query), pa.mPref.mComponent, pa.mPref.mAlways);
                                                                                        pir.removeFilter(pa);
                                                                                        pir.addFilter(freshPa);
                                                                                        changed2 = true;
                                                                                        if (DEBUG_PREFERRED || debug) {
                                                                                            Slog.v(TAG, "Returning preferred activity: " + ri2.activityInfo.packageName + SliceClientPermissions.SliceAuthority.DELIMITER + ri2.activityInfo.name);
                                                                                        }
                                                                                        if (changed2) {
                                                                                            if (DEBUG_PREFERRED) {
                                                                                                Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                                                            }
                                                                                            scheduleWritePackageRestrictionsLocked(userId);
                                                                                        }
                                                                                        return ri2;
                                                                                    } else if (DEBUG_PREFERRED) {
                                                                                        Slog.i(TAG, "Do not remove preferred activity for launcher during SetupWizard");
                                                                                    }
                                                                                }
                                                                                changed2 = changed;
                                                                                Slog.v(TAG, "Returning preferred activity: " + ri2.activityInfo.packageName + SliceClientPermissions.SliceAuthority.DELIMITER + ri2.activityInfo.name);
                                                                                if (changed2) {
                                                                                }
                                                                                return ri2;
                                                                            }
                                                                        }
                                                                    }
                                                                    j2++;
                                                                    startupGuideEnabled2 = startupGuideEnabled;
                                                                }
                                                                startupGuideEnabled = startupGuideEnabled2;
                                                            } else if (excludeSetupWizardHomeActivity) {
                                                                startupGuideEnabled = startupGuideEnabled2;
                                                            } else {
                                                                Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                                                                pir.removeFilter(pa);
                                                                changed5 = true;
                                                                startupGuideEnabled = startupGuideEnabled2;
                                                                i++;
                                                                callingUid2 = callingUid;
                                                                match3 = match;
                                                                startupGuideComp = startupGuideComp;
                                                                prefs2 = prefs;
                                                                M2 = M;
                                                                startupGuideEnabled2 = startupGuideEnabled;
                                                            }
                                                        }
                                                    }
                                                    Slog.v(TAG, "Found preferred activity:");
                                                    if (ai != null) {
                                                        match = match3;
                                                        ai.dump(new LogPrinter(2, TAG, 3), "  ");
                                                    } else {
                                                        match = match3;
                                                        Slog.v(TAG, "  null");
                                                    }
                                                    if (!isHomeIntent(intent2)) {
                                                    }
                                                    if (ai == null) {
                                                    }
                                                } else {
                                                    if (!DEBUG_PREFERRED) {
                                                        if (debug) {
                                                        }
                                                        match = match3;
                                                        startupGuideEnabled = startupGuideEnabled2;
                                                    }
                                                    Slog.v(TAG, "Skipping mAlways=false entry");
                                                    match = match3;
                                                    startupGuideEnabled = startupGuideEnabled2;
                                                }
                                                changed5 = changed;
                                                i++;
                                                callingUid2 = callingUid;
                                                match3 = match;
                                                startupGuideComp = startupGuideComp;
                                                prefs2 = prefs;
                                                M2 = M;
                                                startupGuideEnabled2 = startupGuideEnabled;
                                            }
                                        }
                                        prefs = prefs2;
                                        try {
                                            StringBuilder sb2 = new StringBuilder();
                                            M = M2;
                                            sb2.append("Checking PreferredActivity ds=");
                                            if (pa2.countDataSchemes() > 0) {
                                                pa = pa2;
                                                callingUid = callingUid2;
                                                try {
                                                    str = pa.getDataScheme(0);
                                                } catch (Throwable th7) {
                                                    th = th7;
                                                    changed4 = changed5;
                                                }
                                            } else {
                                                pa = pa2;
                                                callingUid = callingUid2;
                                                str = "<none>";
                                            }
                                            try {
                                                sb2.append(str);
                                                sb2.append("\n  component=");
                                                sb2.append(pa.mPref.mComponent);
                                                Slog.v(TAG, sb2.toString());
                                                changed = changed5;
                                            } catch (Throwable th8) {
                                                th = th8;
                                                changed4 = changed5;
                                                if (changed4) {
                                                }
                                                throw th;
                                            }
                                            try {
                                                pa.dump(new LogPrinter(2, TAG, 3), "  ");
                                                if (pa.mPref.mMatch == match3) {
                                                }
                                                changed5 = changed;
                                                i++;
                                                callingUid2 = callingUid;
                                                match3 = match;
                                                startupGuideComp = startupGuideComp;
                                                prefs2 = prefs;
                                                M2 = M;
                                                startupGuideEnabled2 = startupGuideEnabled;
                                            } catch (Throwable th9) {
                                                th = th9;
                                                changed4 = changed;
                                                if (changed4) {
                                                }
                                                throw th;
                                            }
                                        } catch (Throwable th10) {
                                            th = th10;
                                            changed4 = changed5;
                                            if (changed4) {
                                            }
                                            throw th;
                                        }
                                    } catch (Throwable th11) {
                                        th = th11;
                                        changed4 = changed5;
                                        if (changed4) {
                                            if (DEBUG_PREFERRED) {
                                                Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                            }
                                            scheduleWritePackageRestrictionsLocked(userId);
                                        }
                                        throw th;
                                    }
                                }
                                if (changed5) {
                                    if (DEBUG_PREFERRED) {
                                        Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                    }
                                    scheduleWritePackageRestrictionsLocked(userId);
                                }
                            } catch (Throwable th12) {
                                th = th12;
                                changed4 = changed4;
                                if (changed4) {
                                }
                                throw th;
                            }
                        } catch (Throwable th13) {
                            th = th13;
                            if (changed4) {
                            }
                            throw th;
                        }
                    }
                    return mHwPMSEx.hwFindPreferredActivity(intent2, query);
                }
            } catch (Throwable th14) {
                th = th14;
                throw th;
            }
        }
    }

    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        boolean z = true;
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (matches.get(i).getTargetUserId() == targetUserId) {
                    return true;
                }
            }
        }
        if (intent == null || !intent.hasWebURI()) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        UserInfo parent = getProfileParent(sourceUserId);
        synchronized (this.mPackages) {
            if (getCrossProfileDomainPreferredLpr(intent, resolvedType, updateFlagsForResolve(0, parent.id, intent, callingUid, false), sourceUserId, parent.id) == null) {
                z = false;
            }
        }
        return z;
    }

    private UserInfo getProfileParent(int userId) {
        long identity = Binder.clearCallingIdentity();
        try {
            return sUserManager.getProfileParent(userId);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private List<CrossProfileIntentFilter> getMatchingCrossProfileIntentFilters(Intent intent, String resolvedType, int userId) {
        CrossProfileIntentResolver resolver = this.mSettings.mCrossProfileIntentResolvers.get(userId);
        if (resolver != null) {
            return resolver.queryIntent(intent, resolvedType, false, userId);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        try {
            Trace.traceBegin(262144, "queryIntentActivities");
            List<ResolveInfo> result = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
            mHwPMSEx.filterResolveInfo(intent, resolvedType, result);
            return new ParceledListSlice<>(result);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: private */
    public String getInstantAppPackageName(int callingUid) {
        synchronized (this.mPackages) {
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(callingUid));
            String str = null;
            if (!(obj instanceof PackageSetting)) {
                return null;
            }
            PackageSetting ps = (PackageSetting) obj;
            if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                str = ps.pkg.packageName;
            }
            return str;
        }
    }

    /* access modifiers changed from: protected */
    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, Binder.getCallingUid(), userId, false, true);
    }

    /* JADX INFO: Multiple debug info for r0v21 'pkg'  java.util.List<android.content.pm.ResolveInfo>: [D('xpResolveInfo' android.content.pm.ResolveInfo), D('result' java.util.List<android.content.pm.ResolveInfo>)] */
    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:114:0x01de A[Catch:{ all -> 0x02ba }] */
    /* JADX WARNING: Removed duplicated region for block: B:157:0x02ab  */
    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        Intent intent2;
        ComponentName comp;
        ArrayMap<String, PackageParser.Package> arrayMap;
        String instantAppPkgName;
        int flags2;
        Intent intent3;
        List<ResolveInfo> result;
        List<ResolveInfo> result2;
        boolean addInstant;
        boolean isVisibleToUser;
        boolean sortResult;
        CrossProfileDomainInfo xpDomainInfo;
        ResolveInfo xpResolveInfo;
        Intent intent4;
        int i;
        PackageManagerService packageManagerService;
        int flags3;
        ComponentName comp2;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        String instantAppPkgName2 = getInstantAppPackageName(filterCallingUid);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activities");
        String pkgName = intent.getPackage();
        ComponentName comp3 = intent.getComponent();
        if (comp3 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp3;
        } else {
            Intent intent5 = intent.getSelector();
            comp = intent5.getComponent();
            intent2 = intent5;
        }
        int flags4 = updateFlagsForResolve(flags, userId, intent2, filterCallingUid, resolveForStart, (comp == null && pkgName == null) ? false : true);
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ActivityInfo ai = getActivityInfo(comp, flags4, userId);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags4) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags4) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags4) != 0;
                boolean isCallerInstantApp = instantAppPkgName2 != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName2);
                flags3 = flags4;
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                comp2 = comp;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (!(!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (!isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !(isTargetVisibleToInstantApp && (ai.flags & 2097152) == 0))))))) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.activityInfo = ai;
                    list.add(ri);
                }
            } else {
                flags3 = flags4;
                comp2 = comp;
            }
            return applyPostResolutionFilter(list, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
        }
        boolean xpDomainInfo2 = false;
        boolean addInstant2 = false;
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            if (pkgName == null) {
                try {
                    List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent2, resolvedType, userId);
                    ResolveInfo xpResolveInfo2 = querySkipCurrentProfileIntents(matchingFilters, intent2, resolvedType, flags4, userId);
                    if (xpResolveInfo2 != null) {
                        try {
                            List<ResolveInfo> xpResult = new ArrayList<>(1);
                            xpResult.add(xpResolveInfo2);
                            arrayMap = arrayMap2;
                            try {
                                List<ResolveInfo> applyPostResolutionFilter = applyPostResolutionFilter(filterIfNotSystemUser(xpResult, userId), instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
                                return applyPostResolutionFilter;
                            } catch (Throwable th) {
                                th = th;
                                throw th;
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            arrayMap = arrayMap2;
                            throw th;
                        }
                    } else {
                        arrayMap = arrayMap2;
                        try {
                            try {
                                result2 = filterIfNotSystemUser(this.mComponentResolver.queryActivities(intent2, resolvedType, flags4, userId), userId);
                                addInstant = isInstantAppResolutionAllowed(intent2, result2, userId, false);
                            } catch (Throwable th3) {
                                th = th3;
                                throw th;
                            }
                        } catch (Throwable th4) {
                            th = th4;
                            throw th;
                        }
                        try {
                            isVisibleToUser = false;
                            result = result2;
                            flags2 = flags4;
                        } catch (Throwable th5) {
                            th = th5;
                            throw th;
                        }
                        try {
                            ResolveInfo xpResolveInfo3 = queryCrossProfileIntents(matchingFilters, intent2, resolvedType, flags4, userId, hasNonNegativePriority(result2));
                            if (xpResolveInfo3 != null) {
                                try {
                                    if (isUserEnabled(xpResolveInfo3.targetUserId)) {
                                        if (filterIfNotSystemUser(Collections.singletonList(xpResolveInfo3), userId).size() > 0) {
                                            isVisibleToUser = true;
                                        }
                                        if (isVisibleToUser) {
                                            result.add(xpResolveInfo3);
                                            sortResult = true;
                                            if (!intent2.hasWebURI()) {
                                                UserInfo parent = getProfileParent(userId);
                                                if (parent != null) {
                                                    try {
                                                        xpResolveInfo = xpResolveInfo3;
                                                        xpDomainInfo = getCrossProfileDomainPreferredLpr(intent2, resolvedType, flags2, userId, parent.id);
                                                    } catch (Throwable th6) {
                                                        th = th6;
                                                        throw th;
                                                    }
                                                } else {
                                                    xpResolveInfo = xpResolveInfo3;
                                                    xpDomainInfo = null;
                                                }
                                                if (xpDomainInfo != null) {
                                                    if (xpResolveInfo != null) {
                                                        result.remove(xpResolveInfo);
                                                    }
                                                    try {
                                                        if (result.size() != 0 || addInstant) {
                                                            intent4 = intent2;
                                                            instantAppPkgName = instantAppPkgName2;
                                                            i = userId;
                                                            packageManagerService = this;
                                                        } else {
                                                            result.add(xpDomainInfo.resolveInfo);
                                                            try {
                                                                List<ResolveInfo> applyPostResolutionFilter2 = applyPostResolutionFilter(result, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
                                                                return applyPostResolutionFilter2;
                                                            } catch (Throwable th7) {
                                                                th = th7;
                                                                throw th;
                                                            }
                                                        }
                                                    } catch (Throwable th8) {
                                                        th = th8;
                                                        throw th;
                                                    }
                                                } else {
                                                    intent4 = intent2;
                                                    instantAppPkgName = instantAppPkgName2;
                                                    i = userId;
                                                    packageManagerService = this;
                                                    try {
                                                        if (result.size() <= 1 && !addInstant) {
                                                            List<ResolveInfo> applyPostResolutionFilter3 = applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent4);
                                                            return applyPostResolutionFilter3;
                                                        }
                                                    } catch (Throwable th9) {
                                                        th = th9;
                                                        throw th;
                                                    }
                                                }
                                                intent3 = intent4;
                                                try {
                                                    xpDomainInfo2 = true;
                                                    result = filterCandidatesWithDomainPreferredActivitiesLPr(intent4, flags2, result, xpDomainInfo, userId);
                                                } catch (Throwable th10) {
                                                    th = th10;
                                                    throw th;
                                                }
                                            } else {
                                                instantAppPkgName = instantAppPkgName2;
                                                intent3 = intent2;
                                                xpDomainInfo2 = sortResult;
                                            }
                                            addInstant2 = addInstant;
                                        }
                                    }
                                } catch (Throwable th11) {
                                    th = th11;
                                    throw th;
                                }
                            }
                            sortResult = false;
                            try {
                                if (!intent2.hasWebURI()) {
                                }
                                addInstant2 = addInstant;
                            } catch (Throwable th12) {
                                th = th12;
                                throw th;
                            }
                        } catch (Throwable th13) {
                            th = th13;
                            throw th;
                        }
                    }
                } catch (Throwable th14) {
                    th = th14;
                    arrayMap = arrayMap2;
                    throw th;
                }
            } else {
                flags2 = flags4;
                arrayMap = arrayMap2;
                instantAppPkgName = instantAppPkgName2;
                intent3 = intent2;
                try {
                    PackageParser.Package pkg = this.mPackages.get(pkgName);
                    List<ResolveInfo> result3 = null;
                    if (pkg != null) {
                        try {
                            result3 = filterIfNotSystemUser(this.mComponentResolver.queryActivities(intent3, resolvedType, flags2, pkg.activities, userId), userId);
                        } catch (Throwable th15) {
                            th = th15;
                            throw th;
                        }
                    }
                    if (result3 != null) {
                        if (result3.size() != 0) {
                            result = result3;
                        }
                    }
                    addInstant2 = isInstantAppResolutionAllowed(intent3, null, userId, true);
                    if (result3 == null) {
                        result = new ArrayList<>();
                    } else {
                        result = result3;
                    }
                } catch (Throwable th16) {
                    th = th16;
                    throw th;
                }
            }
            if (addInstant2) {
                result = maybeAddInstantAppInstaller(result, intent3, resolvedType, flags2, userId, resolveForStart);
            }
            if (xpDomainInfo2) {
                Collections.sort(result, ComponentResolver.RESOLVE_PRIORITY_SORTER);
            }
            return applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent3);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:27:0x00a6  */
    /* JADX WARNING: Removed duplicated region for block: B:30:0x00e9  */
    /* JADX WARNING: Removed duplicated region for block: B:41:0x0138  */
    /* JADX WARNING: Removed duplicated region for block: B:49:0x016a  */
    private List<ResolveInfo> maybeAddInstantAppInstaller(List<ResolveInfo> result, Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        ResolveInfo localInstantApp;
        int status;
        InstantAppRequest requestObject;
        PackageSetting ps;
        ResolveInfo ephemeralInstaller;
        if (!((flags & 8388608) != 0)) {
            List<ResolveInfo> instantApps = this.mComponentResolver.queryActivities(intent, resolvedType, 8388608 | flags | 64 | DumpState.DUMP_SERVICE_PERMISSIONS, userId);
            for (int i = instantApps.size() - 1; i >= 0; i--) {
                ResolveInfo info = instantApps.get(i);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps2 = this.mSettings.mPackages.get(packageName);
                if (ps2.getInstantApp(userId)) {
                    if (((int) (getDomainVerificationStatusLPr(ps2, userId) >> 32)) == 3) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Instant app marked to never run; pkg: " + packageName);
                        }
                        localInstantApp = null;
                        status = 1;
                    } else {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Found installed instant app; pkg: " + packageName);
                        }
                        localInstantApp = info;
                        status = 0;
                    }
                    if (status == 0) {
                        requestObject = null;
                    } else if (localInstantApp == null) {
                        Trace.traceBegin(262144, "resolveEphemeral");
                        InstantAppRequest auxiliaryResponse = InstantAppResolver.doInstantAppResolutionPhaseOne(this.mInstantAppResolverConnection, new InstantAppRequest((AuxiliaryResolveInfo) null, intent, resolvedType, (String) null, userId, (Bundle) null, resolveForStart));
                        Trace.traceEnd(262144);
                        requestObject = auxiliaryResponse;
                    } else {
                        ApplicationInfo ai = localInstantApp.activityInfo.applicationInfo;
                        requestObject = new AuxiliaryResolveInfo((ComponentName) null, ai.packageName, ai.longVersionCode, (String) null);
                    }
                    if ((!intent.isWebIntent() && requestObject == null) || (ps = this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName)) == null || !ps.readUserState(userId).isEnabled(this.mInstantAppInstallerActivity, 0)) {
                        return result;
                    }
                    ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
                    ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
                    ephemeralInstaller.match = 5799936;
                    ephemeralInstaller.filter = new IntentFilter();
                    if (intent.getAction() != null) {
                        ephemeralInstaller.filter.addAction(intent.getAction());
                    }
                    if (!(intent.getData() == null || intent.getData().getPath() == null)) {
                        ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
                    }
                    ephemeralInstaller.isInstantAppAvailable = true;
                    ephemeralInstaller.isDefault = true;
                    ephemeralInstaller.auxiliaryInfo = requestObject;
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    result.add(ephemeralInstaller);
                    return result;
                }
            }
        }
        localInstantApp = null;
        status = 0;
        if (status == 0) {
        }
        if (!intent.isWebIntent()) {
        }
        ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
        ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
        ephemeralInstaller.match = 5799936;
        ephemeralInstaller.filter = new IntentFilter();
        if (intent.getAction() != null) {
        }
        ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
        ephemeralInstaller.isInstantAppAvailable = true;
        ephemeralInstaller.isDefault = true;
        ephemeralInstaller.auxiliaryInfo = requestObject;
        if (DEBUG_INSTANT) {
        }
        result.add(ephemeralInstaller);
        return result;
    }

    private static class CrossProfileDomainInfo {
        int bestDomainVerificationStatus;
        ResolveInfo resolveInfo;

        private CrossProfileDomainInfo() {
        }
    }

    private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
        List<ResolveInfo> resultTargetUser;
        if (!sUserManager.hasUserRestriction("allow_parent_profile_app_linking", sourceUserId)) {
            return null;
        }
        List<ResolveInfo> resultTargetUser2 = this.mComponentResolver.queryActivities(intent, resolvedType, flags, parentUserId);
        if (resultTargetUser2 == null) {
            return null;
        }
        if (resultTargetUser2.isEmpty()) {
            return null;
        }
        CrossProfileDomainInfo result = null;
        int size = resultTargetUser2.size();
        int i = 0;
        while (i < size) {
            ResolveInfo riTargetUser = resultTargetUser2.get(i);
            if (riTargetUser.handleAllWebDataURI) {
                resultTargetUser = resultTargetUser2;
            } else {
                PackageSetting ps = this.mSettings.mPackages.get(riTargetUser.activityInfo.packageName);
                if (ps == null) {
                    resultTargetUser = resultTargetUser2;
                } else {
                    int status = (int) (getDomainVerificationStatusLPr(ps, parentUserId) >> 32);
                    if (result == null) {
                        resultTargetUser = resultTargetUser2;
                        CrossProfileDomainInfo result2 = new CrossProfileDomainInfo();
                        result2.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), sourceUserId, parentUserId);
                        result2.bestDomainVerificationStatus = status;
                        result = result2;
                    } else {
                        resultTargetUser = resultTargetUser2;
                        result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
                    }
                }
            }
            i++;
            resultTargetUser2 = resultTargetUser;
        }
        if (result == null || result.bestDomainVerificationStatus != 3) {
            return result;
        }
        return null;
    }

    private int bestDomainVerificationStatus(int status1, int status2) {
        if (status1 == 3) {
            return status2;
        }
        if (status2 == 3) {
            return status1;
        }
        return (int) MathUtils.max(status1, status2);
    }

    private boolean isUserEnabled(int userId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            return userInfo != null && userInfo.isEnabled();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private List<ResolveInfo> filterIfNotSystemUser(List<ResolveInfo> resolveInfos, int userId) {
        if (userId == 0) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            if ((resolveInfos.get(i).activityInfo.flags & 536870912) != 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private List<ResolveInfo> applyPostResolutionFilter(List<ResolveInfo> resolveInfos, String ephemeralPkgName, boolean allowDynamicSplits, int filterCallingUid, boolean resolveForStart, int userId, Intent intent) {
        boolean blockInstant = intent.isWebIntent() && areWebInstantAppsDisabled(userId);
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            if (!info.isInstantAppAvailable || !blockInstant) {
                if (allowDynamicSplits && info.activityInfo != null && info.activityInfo.splitName != null) {
                    if (!ArrayUtils.contains(info.activityInfo.applicationInfo.splitNames, info.activityInfo.splitName)) {
                        if (this.mInstantAppInstallerActivity == null) {
                            if (DEBUG_INSTALL) {
                                Slog.v(TAG, "No installer - not adding it to the ResolveInfo list");
                            }
                            resolveInfos.remove(i);
                        } else if (!blockInstant || !isInstantApp(info.activityInfo.packageName, userId)) {
                            if (DEBUG_INSTALL) {
                                Slog.v(TAG, "Adding installer to the ResolveInfo list");
                            }
                            ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                            installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(findInstallFailureActivity(info.activityInfo.packageName, filterCallingUid, userId), info.activityInfo.packageName, info.activityInfo.applicationInfo.longVersionCode, info.activityInfo.splitName);
                            installerInfo.filter = new IntentFilter();
                            installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                            installerInfo.labelRes = info.resolveLabelResId();
                            installerInfo.icon = info.resolveIconResId();
                            installerInfo.isInstantAppAvailable = true;
                            resolveInfos.set(i, installerInfo);
                        } else {
                            resolveInfos.remove(i);
                        }
                    }
                }
                if (ephemeralPkgName != null && !ephemeralPkgName.equals(info.activityInfo.packageName) && ((!resolveForStart || !((intent.isWebIntent() || (intent.getFlags() & 2048) != 0) && intent.getPackage() == null && intent.getComponent() == null)) && (info.activityInfo.applicationInfo.isInstantApp() || (info.activityInfo.flags & 1048576) == 0))) {
                    resolveInfos.remove(i);
                }
            } else {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private ComponentName findInstallFailureActivity(String packageName, int filterCallingUid, int userId) {
        Intent failureActivityIntent = new Intent("android.intent.action.INSTALL_FAILURE");
        failureActivityIntent.setPackage(packageName);
        List<ResolveInfo> result = queryIntentActivitiesInternal(failureActivityIntent, null, 0, filterCallingUid, userId, false, false);
        int NR = result.size();
        if (NR <= 0) {
            return null;
        }
        for (int i = 0; i < NR; i++) {
            ResolveInfo info = result.get(i);
            if (info.activityInfo.splitName == null) {
                return new ComponentName(packageName, info.activityInfo.name);
            }
        }
        return null;
    }

    private boolean hasNonNegativePriority(List<ResolveInfo> resolveInfos) {
        return resolveInfos.size() > 0 && resolveInfos.get(0).priority >= 0;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:118:0x026d, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED != false) goto L_0x0273;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x0271, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x02b6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x0273, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Filtered results with preferred activities. New candidates count: " + r0.size());
        r0 = r0.iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0295, code lost:
        if (r0.hasNext() == false) goto L_0x02b6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0297, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "  + " + r0.next().activityInfo);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x02b6, code lost:
        return r0;
     */
    private List<ResolveInfo> filterCandidatesWithDomainPreferredActivitiesLPr(Intent intent, int matchFlags, List<ResolveInfo> candidates, CrossProfileDomainInfo xpDomainInfo, int userId) {
        int maxMatchPrio;
        PackageManagerService packageManagerService = this;
        List<ResolveInfo> list = candidates;
        int i = userId;
        boolean debug = (intent.getFlags() & 8) != 0;
        if (DEBUG_PREFERRED || DEBUG_DOMAIN_VERIFICATION) {
            Slog.v(TAG, "Filtering results with preferred activities. Candidates count: " + candidates.size());
        }
        ArrayList<ResolveInfo> result = new ArrayList<>();
        ArrayList<ResolveInfo> alwaysList = new ArrayList<>();
        ArrayList<ResolveInfo> undefinedList = new ArrayList<>();
        ArrayList<ResolveInfo> alwaysAskList = new ArrayList<>();
        ArrayList<ResolveInfo> neverList = new ArrayList<>();
        ArrayList<ResolveInfo> matchAllList = new ArrayList<>();
        synchronized (packageManagerService.mPackages) {
            try {
                int count = candidates.size();
                int n = 0;
                while (n < count) {
                    try {
                        ResolveInfo info = list.get(n);
                        PackageSetting ps = packageManagerService.mSettings.mPackages.get(info.activityInfo.packageName);
                        if (ps != null) {
                            if (info.handleAllWebDataURI) {
                                matchAllList.add(info);
                            } else {
                                long packedStatus = packageManagerService.getDomainVerificationStatusLPr(ps, i);
                                int status = (int) (packedStatus >> 32);
                                int linkGeneration = (int) (packedStatus & -1);
                                if (status == 2) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + always: " + info.activityInfo.packageName + " : linkgen=" + linkGeneration);
                                    }
                                    info.preferredOrder = linkGeneration;
                                    alwaysList.add(info);
                                } else if (status == 3) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + never: " + info.activityInfo.packageName);
                                    }
                                    neverList.add(info);
                                } else if (status == 4) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + always-ask: " + info.activityInfo.packageName);
                                    }
                                    alwaysAskList.add(info);
                                } else {
                                    if (status != 0) {
                                        if (status != 1) {
                                        }
                                    }
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + ask: " + info.activityInfo.packageName);
                                    }
                                    undefinedList.add(info);
                                }
                            }
                        }
                        n++;
                        packageManagerService = this;
                        list = candidates;
                        i = userId;
                        count = count;
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                }
                boolean includeBrowser = false;
                if (alwaysList.size() > 0) {
                    result.addAll(alwaysList);
                } else {
                    result.addAll(undefinedList);
                    if (!(xpDomainInfo == null || xpDomainInfo.bestDomainVerificationStatus == 3)) {
                        result.add(xpDomainInfo.resolveInfo);
                    }
                    includeBrowser = true;
                }
                if (alwaysAskList.size() > 0) {
                    Iterator<ResolveInfo> it = result.iterator();
                    while (it.hasNext()) {
                        it.next().preferredOrder = 0;
                    }
                    result.addAll(alwaysAskList);
                    includeBrowser = true;
                }
                if (includeBrowser) {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "   ...including browsers in candidate set");
                    }
                    if ((matchFlags & 131072) != 0) {
                        result.addAll(matchAllList);
                    } else {
                        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
                        ResolveInfo defaultBrowserMatch = null;
                        int numCandidates = matchAllList.size();
                        int maxMatchPrio2 = 0;
                        int n2 = 0;
                        while (n2 < numCandidates) {
                            ResolveInfo info2 = matchAllList.get(n2);
                            if (info2.priority > maxMatchPrio2) {
                                maxMatchPrio2 = info2.priority;
                            }
                            if (info2.activityInfo.packageName.equals(defaultBrowserPackageName)) {
                                if (defaultBrowserMatch != null) {
                                    maxMatchPrio = maxMatchPrio2;
                                    if (defaultBrowserMatch.priority >= info2.priority) {
                                    }
                                } else {
                                    maxMatchPrio = maxMatchPrio2;
                                }
                                if (debug) {
                                    Slog.v(TAG, "Considering default browser match " + info2);
                                }
                                defaultBrowserMatch = info2;
                            } else {
                                maxMatchPrio = maxMatchPrio2;
                            }
                            n2++;
                            maxMatchPrio2 = maxMatchPrio;
                        }
                        if (defaultBrowserMatch != null && defaultBrowserMatch.priority >= maxMatchPrio2) {
                            if (!TextUtils.isEmpty(defaultBrowserPackageName)) {
                                try {
                                    if (!mHwPMSEx.isMultiScreenCollaborationEnabled(intent)) {
                                        if (debug) {
                                            Slog.v(TAG, "Default browser match " + defaultBrowserMatch);
                                        }
                                        result.add(defaultBrowserMatch);
                                    }
                                } catch (Throwable th2) {
                                    th = th2;
                                    throw th;
                                }
                            }
                        }
                        result.addAll(matchAllList);
                    }
                    if (result.size() == 0) {
                        result.addAll(candidates);
                        result.removeAll(neverList);
                    }
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
    }

    private long getDomainVerificationStatusLPr(PackageSetting ps, int userId) {
        long result = ps.getDomainVerificationStatusForUser(userId);
        if ((result >> 32) != 0 || ps.getIntentFilterVerificationInfo() == null) {
            return result;
        }
        return ((long) ps.getIntentFilterVerificationInfo().getStatus()) << 32;
    }

    private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
        ResolveInfo resolveInfo;
        if (matchingFilters == null) {
            return null;
        }
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            if ((filter.getFlags() & 2) != 0 && (resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId)) != null) {
                return resolveInfo;
            }
        }
        return null;
    }

    private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
        if (matchingFilters == null) {
            return null;
        }
        SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            int targetUserId = filter.getTargetUserId();
            boolean skipCurrentProfileIfNoMatchFound = false;
            boolean skipCurrentProfile = (filter.getFlags() & 2) != 0;
            if ((filter.getFlags() & 4) != 0) {
                skipCurrentProfileIfNoMatchFound = true;
            }
            if (!skipCurrentProfile && !alreadyTriedUserIds.get(targetUserId) && (!skipCurrentProfileIfNoMatchFound || !matchInCurrentProfile)) {
                ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null) {
                    return resolveInfo;
                }
                alreadyTriedUserIds.put(targetUserId, true);
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
        int targetUserId = filter.getTargetUserId();
        List<ResolveInfo> resultTargetUser = this.mComponentResolver.queryActivities(intent, resolvedType, flags, targetUserId);
        if (resultTargetUser == null || !isUserEnabled(targetUserId)) {
            return null;
        }
        for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
            if ((resultTargetUser.get(i).activityInfo.applicationInfo.flags & 1073741824) == 0) {
                return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfoUnchecked(IntentFilter filter, int sourceUserId, int targetUserId) {
        String className;
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        long ident = Binder.clearCallingIdentity();
        try {
            boolean targetIsProfile = sUserManager.getUserInfo(targetUserId).isManagedProfile();
            if (targetIsProfile) {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE;
            } else {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_PARENT;
            }
            ActivityInfo forwardingActivityInfo = getActivityInfo(new ComponentName(this.mAndroidApplication.packageName, className), 0, sourceUserId);
            if (!targetIsProfile) {
                if (forwardingActivityInfo != null) {
                    forwardingActivityInfo.showUserIcon = targetUserId;
                } else {
                    Slog.i(TAG, "get forwarding Activity Info is null. sourceUserId:" + sourceUserId);
                }
                forwardingResolveInfo.noResourceId = true;
            }
            forwardingResolveInfo.activityInfo = forwardingActivityInfo;
            forwardingResolveInfo.priority = 0;
            forwardingResolveInfo.preferredOrder = 0;
            forwardingResolveInfo.match = 0;
            forwardingResolveInfo.isDefault = true;
            forwardingResolveInfo.filter = filter;
            forwardingResolveInfo.targetUserId = targetUserId;
            return forwardingResolveInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
    }

    /* JADX WARNING: Code restructure failed: missing block: B:37:0x00e6, code lost:
        if (r10 == null) goto L_0x00e9;
     */
    private List<ResolveInfo> queryIntentActivityOptionsInternal(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        String resultsAction;
        int specificsPos;
        String resultsAction2;
        Iterator<String> it;
        String resultsAction3;
        String resultsAction4;
        int specificsPos2;
        String resultsAction5;
        int callingUid;
        String str;
        ActivityInfo ai;
        ResolveInfo ri;
        Intent[] intentArr = specifics;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid2 = Binder.getCallingUid();
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid2, false);
        this.mPermissionManager.enforceCrossUserPermission(callingUid2, userId, false, false, "query intent activity options");
        if (intent == null) {
            return Collections.emptyList();
        }
        String resultsAction6 = intent.getAction();
        List<ResolveInfo> results = queryIntentActivitiesInternal(intent, resolvedType, flags2 | 64, userId);
        String str2 = ": ";
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Query " + intent + str2 + results);
        }
        int specificsPos3 = 0;
        if (intentArr != null) {
            int i = 0;
            while (i < intentArr.length) {
                Intent sintent = intentArr[i];
                if (sintent == null) {
                    resultsAction5 = resultsAction6;
                    callingUid = callingUid2;
                } else {
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i + str2 + sintent);
                    }
                    String action = sintent.getAction();
                    if (resultsAction6 != null && resultsAction6.equals(action)) {
                        action = null;
                    }
                    ResolveInfo ri2 = null;
                    ComponentName comp = sintent.getComponent();
                    if (comp == null) {
                        ResolveInfo ri3 = resolveIntent(sintent, specificTypes != null ? specificTypes[i] : null, flags2, userId);
                        if (ri3 == null) {
                            resultsAction5 = resultsAction6;
                            callingUid = callingUid2;
                        } else {
                            callingUid = callingUid2;
                            ResolveInfo resolveInfo = this.mResolveInfo;
                            ai = ri3.activityInfo;
                            ri2 = ri3;
                            resultsAction5 = resultsAction6;
                            comp = new ComponentName(ai.applicationInfo.packageName, ai.name);
                        }
                    } else {
                        resultsAction5 = resultsAction6;
                        callingUid = callingUid2;
                        ai = getActivityInfo(comp, flags2, userId);
                    }
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i + str2 + ai);
                    }
                    int N = results.size();
                    int j = specificsPos3;
                    while (j < N) {
                        ResolveInfo sri = results.get(j);
                        if ((sri.activityInfo.name.equals(comp.getClassName()) && sri.activityInfo.applicationInfo.packageName.equals(comp.getPackageName())) || (action != null && sri.filter.matchAction(action))) {
                            results.remove(j);
                            if (DEBUG_INTENT_MATCHING) {
                                Log.v(TAG, "Removing duplicate item from " + j + " due to specific " + specificsPos3);
                            }
                            if (ri2 == null) {
                                ri2 = sri;
                            }
                            j--;
                            N--;
                        }
                        j++;
                        str2 = str2;
                    }
                    str = str2;
                    if (ri2 == null) {
                        ri = new ResolveInfo();
                        ri.activityInfo = ai;
                    } else {
                        ri = ri2;
                    }
                    results.add(specificsPos3, ri);
                    ri.specificIndex = i;
                    specificsPos3++;
                    i++;
                    intentArr = specifics;
                    str2 = str;
                    callingUid2 = callingUid;
                    resultsAction6 = resultsAction5;
                }
                str = str2;
                i++;
                intentArr = specifics;
                str2 = str;
                callingUid2 = callingUid;
                resultsAction6 = resultsAction5;
            }
            resultsAction = resultsAction6;
        } else {
            resultsAction = resultsAction6;
        }
        int N2 = results.size();
        int i2 = specificsPos3;
        while (i2 < N2 - 1) {
            ResolveInfo rii = results.get(i2);
            if (rii.filter == null || (it = rii.filter.actionsIterator()) == null) {
                specificsPos = specificsPos3;
                resultsAction2 = resultsAction;
            } else {
                while (it.hasNext()) {
                    String action2 = it.next();
                    if (resultsAction != null) {
                        resultsAction3 = resultsAction;
                        if (resultsAction3.equals(action2)) {
                            resultsAction4 = resultsAction3;
                        }
                    } else {
                        resultsAction3 = resultsAction;
                    }
                    int j2 = i2 + 1;
                    while (j2 < N2) {
                        ResolveInfo rij = results.get(j2);
                        if (rij.filter == null || !rij.filter.hasAction(action2)) {
                            specificsPos2 = specificsPos3;
                        } else {
                            results.remove(j2);
                            if (DEBUG_INTENT_MATCHING) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Removing duplicate item from ");
                                sb.append(j2);
                                specificsPos2 = specificsPos3;
                                sb.append(" due to action ");
                                sb.append(action2);
                                sb.append(" at ");
                                sb.append(i2);
                                Log.v(TAG, sb.toString());
                            } else {
                                specificsPos2 = specificsPos3;
                            }
                            j2--;
                            N2--;
                        }
                        j2++;
                        specificsPos3 = specificsPos2;
                    }
                    resultsAction4 = resultsAction3;
                }
                specificsPos = specificsPos3;
                resultsAction2 = resultsAction;
                if ((flags2 & 64) == 0) {
                    rii.filter = null;
                }
            }
            i2++;
            resultsAction = resultsAction2;
            specificsPos3 = specificsPos;
        }
        if (caller != null) {
            int N3 = results.size();
            int i3 = 0;
            while (true) {
                if (i3 >= N3) {
                    break;
                }
                ActivityInfo ainfo = results.get(i3).activityInfo;
                if (caller.getPackageName().equals(ainfo.applicationInfo.packageName) && caller.getClassName().equals(ainfo.name)) {
                    results.remove(i3);
                    break;
                }
                i3++;
            }
        }
        if ((flags2 & 64) == 0) {
            int N4 = results.size();
            for (int i4 = 0; i4 < N4; i4++) {
                results.get(i4).filter = null;
            }
        }
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Result: " + results);
        }
        return results;
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentReceiversInternal(intent, resolvedType, flags, userId, false));
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x00cf  */
    /* JADX WARNING: Removed duplicated region for block: B:62:0x00e0  */
    public List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
        Intent intent2;
        ComponentName comp;
        boolean isTargetExplicitlyVisibleToInstantApp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ActivityInfo ai = getReceiverInfo(comp, flags2, userId);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    if ((ai.flags & 2097152) == 0) {
                        isTargetExplicitlyVisibleToInstantApp = true;
                        if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                            ResolveInfo ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            list.add(ri);
                        }
                    }
                }
                isTargetExplicitlyVisibleToInstantApp = false;
                if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                }
            }
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
        }
        synchronized (this.mPackages) {
            String pkgName = intent2.getPackage();
            if (pkgName == null) {
                return applyPostResolutionFilter(this.mComponentResolver.queryReceivers(intent2, resolvedType, flags2, userId), instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
            }
            PackageParser.Package pkg = this.mPackages.get(pkgName);
            if (pkg != null) {
                return applyPostResolutionFilter(this.mComponentResolver.queryReceivers(intent2, resolvedType, flags2, pkg.receivers, userId), instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
            }
            return Collections.emptyList();
        }
    }

    public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
        return resolveServiceInternal(intent, resolvedType, flags, userId, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    public ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
        List<ResolveInfo> query;
        if (sUserManager.exists(userId) && (query = queryIntentServicesInternal(intent, resolvedType, updateFlagsForResolve(flags, userId, intent, callingUid, false), userId, callingUid, false)) != null && query.size() >= 1) {
            return query.get(0);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentServicesInternal(intent, resolvedType, flags, userId, Binder.getCallingUid(), false));
    }

    /* access modifiers changed from: private */
    public List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
        Intent intent2;
        ComponentName comp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, includeInstantApps);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ServiceInfo si = getServiceInfo(comp, flags2, userId);
            if (si != null) {
                boolean blockResolution = false;
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (si.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (si.flags & 1048576) == 0;
                if (!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp))) {
                    blockResolution = true;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.serviceInfo = si;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            try {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    return applyPostServiceResolutionFilter(this.mComponentResolver.queryServices(intent2, resolvedType, flags2, userId), instantAppPkgName);
                }
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    return applyPostServiceResolutionFilter(this.mComponentResolver.queryServices(intent2, resolvedType, flags2, pkg.services, userId), instantAppPkgName);
                }
                return Collections.emptyList();
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostServiceResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.serviceInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.serviceInfo.packageName)) {
                if (isEphemeralApp || (info.serviceInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.serviceInfo.splitName != null && !ArrayUtils.contains(info.serviceInfo.applicationInfo.splitNames, info.serviceInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo((ComponentName) null, info.serviceInfo.packageName, info.serviceInfo.applicationInfo.longVersionCode, info.serviceInfo.splitName);
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId));
    }

    private List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
        Intent intent2;
        ComponentName comp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ProviderInfo pi = getProviderInfo(comp, flags2, userId);
            if (pi != null) {
                boolean blockResolution = false;
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (pi.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (pi.flags & 1048576) == 0;
                if (!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp))) {
                    blockResolution = true;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.providerInfo = pi;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            try {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    return applyPostContentProviderResolutionFilter(this.mComponentResolver.queryProviders(intent2, resolvedType, flags2, userId), instantAppPkgName);
                }
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    return applyPostContentProviderResolutionFilter(this.mComponentResolver.queryProviders(intent2, resolvedType, flags2, pkg.providers, userId), instantAppPkgName);
                }
                return Collections.emptyList();
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostContentProviderResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.providerInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.providerInfo.packageName)) {
                if (isEphemeralApp || (info.providerInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.providerInfo.splitName != null && !ArrayUtils.contains(info.providerInfo.applicationInfo.splitNames, info.providerInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo((ComponentName) null, info.providerInfo.packageName, info.providerInfo.applicationInfo.longVersionCode, info.providerInfo.splitName);
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
        ArrayList<PackageInfo> list;
        ParceledListSlice<PackageInfo> parceledListSlice;
        long startTime = SystemClock.uptimeMillis();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETINSTALLEDPACKAGES);
            if (getInstantAppPackageName(callingUid) != null) {
                return ParceledListSlice.emptyList();
            }
            if (!sUserManager.exists(userId)) {
                ParceledListSlice<PackageInfo> emptyList = ParceledListSlice.emptyList();
                Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return emptyList;
            }
            int flags2 = updateFlagsForPackage(flags, userId, null);
            boolean listFactory = true;
            boolean listUninstalled = (4202496 & flags2) != 0;
            boolean listApex = (1073741824 & flags2) != 0;
            if ((2097152 & flags2) == 0) {
                listFactory = false;
            }
            this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed packages");
            synchronized (this.mPackages) {
                if (listUninstalled) {
                    list = new ArrayList<>(this.mSettings.mPackages.size());
                    for (PackageSetting ps : this.mSettings.mPackages.values()) {
                        if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                            if (!filterAppAccessLPr(ps, callingUid, userId)) {
                                PackageInfo pi = generatePackageInfo(ps, flags2, userId);
                                if (pi != null) {
                                    list.add(pi);
                                }
                            }
                        }
                    }
                } else {
                    list = new ArrayList<>(this.mPackages.size());
                    for (PackageParser.Package p : this.mPackages.values()) {
                        PackageSetting ps2 = (PackageSetting) p.mExtras;
                        if (!filterSharedLibPackageLPr(ps2, callingUid, userId, flags2)) {
                            if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                PackageInfo pi2 = generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
                                if (pi2 != null) {
                                    list.add(pi2);
                                }
                            }
                        }
                    }
                }
                if (listApex) {
                    if (listFactory) {
                        list.addAll(this.mApexManager.getFactoryPackages());
                    } else {
                        list.addAll(this.mApexManager.getActivePackages());
                    }
                    if (listUninstalled) {
                        list.addAll(this.mApexManager.getInactivePackages());
                    }
                }
                parceledListSlice = new ParceledListSlice<>(list);
            }
            Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
            return parceledListSlice;
        } finally {
            Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
        }
    }

    private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
        PackageInfo pi;
        int numMatch = 0;
        PermissionsState permissionsState = ps.getPermissionsState();
        for (int i = 0; i < permissions.length; i++) {
            if (permissionsState.hasPermission(permissions[i], userId)) {
                tmp[i] = true;
                numMatch++;
            } else {
                tmp[i] = false;
            }
        }
        if (numMatch != 0 && (pi = generatePackageInfo(ps, flags, userId)) != null) {
            if ((flags & 4096) == 0) {
                if (numMatch == permissions.length) {
                    pi.requestedPermissions = permissions;
                } else {
                    pi.requestedPermissions = new String[numMatch];
                    int numMatch2 = 0;
                    for (int i2 = 0; i2 < permissions.length; i2++) {
                        if (tmp[i2]) {
                            pi.requestedPermissions[numMatch2] = permissions[i2];
                            numMatch2++;
                        }
                    }
                }
            }
            list.add(pi);
        }
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:39:0x0096 */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:10:0x0037 */
    /* JADX DEBUG: Multi-variable search result rejected for r4v6, resolved type: android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package> */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r4v0 */
    /* JADX WARN: Type inference failed for: r4v1 */
    /* JADX WARN: Type inference failed for: r4v8 */
    public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForPackage(flags, userId, permissions);
        ArrayMap<String, PackageParser.Package> arrayMap3 = 1;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "get packages holding permissions");
        boolean listUninstalled = (flags2 & 4202496) != 0;
        ArrayMap<String, PackageParser.Package> arrayMap4 = this.mPackages;
        synchronized (arrayMap4) {
            try {
                ArrayList<PackageInfo> list = new ArrayList<>();
                boolean[] tmpBools = new boolean[permissions.length];
                if (listUninstalled) {
                    for (PackageSetting ps : this.mSettings.mPackages.values()) {
                        addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags2, userId);
                    }
                    arrayMap2 = arrayMap4;
                } else {
                    for (PackageParser.Package pkg : this.mPackages.values()) {
                        PackageSetting ps2 = (PackageSetting) pkg.mExtras;
                        if (ps2 != null) {
                            arrayMap3 = arrayMap4;
                            addPackageHoldingPermissions(list, ps2, permissions, tmpBools, flags2, userId);
                        } else {
                            arrayMap3 = arrayMap4;
                        }
                        arrayMap4 = arrayMap3;
                    }
                    arrayMap2 = arrayMap4;
                }
                ParceledListSlice<PackageInfo> parceledListSlice = new ParceledListSlice<>(list);
                return parceledListSlice;
            } catch (Throwable th) {
                th = th;
                arrayMap = arrayMap3;
                throw th;
            }
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        long startTime = SystemClock.uptimeMillis();
        int callingPid = Binder.getCallingPid();
        int callingUid = Binder.getCallingUid();
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETINSTALLEDAPPLICATIONS);
            try {
                ParceledListSlice<ApplicationInfo> parceledListSlice = new ParceledListSlice<>(getInstalledApplicationsListInternal(flags, userId, callingUid));
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return parceledListSlice;
            } catch (Throwable th) {
                th = th;
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                throw th;
            }
        } catch (Throwable th2) {
            th = th2;
            Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
            throw th;
        }
    }

    /* access modifiers changed from: private */
    public List<ApplicationInfo> getInstalledApplicationsListInternal(int flags, int userId, int callingUid) {
        ArrayList<ApplicationInfo> list;
        ApplicationInfo ai;
        if (getInstantAppPackageName(callingUid) != null) {
            return Collections.emptyList();
        }
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int flags2 = updateFlagsForApplication(flags, userId, null);
        boolean listUninstalled = (4202496 & flags2) != 0;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed application info");
        synchronized (this.mPackages) {
            if (listUninstalled) {
                list = new ArrayList<>(this.mSettings.mPackages.size());
                for (PackageSetting ps : this.mSettings.mPackages.values()) {
                    int effectiveFlags = flags2;
                    if (ps.isSystem()) {
                        effectiveFlags |= 4194304;
                    }
                    if (ps.pkg == null) {
                        ai = generateApplicationInfoFromSettingsLPw(ps.name, callingUid, effectiveFlags, userId);
                    } else if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                        if (!filterAppAccessLPr(ps, callingUid, userId)) {
                            ai = PackageParser.generateApplicationInfo(ps.pkg, effectiveFlags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
                            }
                        }
                    }
                    if (ai != null) {
                        list.add(ai);
                    }
                }
            } else {
                list = new ArrayList<>(this.mPackages.size());
                for (PackageParser.Package p : this.mPackages.values()) {
                    if (p.mExtras != null) {
                        PackageSetting ps2 = (PackageSetting) p.mExtras;
                        if (!filterSharedLibPackageLPr(ps2, Binder.getCallingUid(), userId, flags2)) {
                            if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                ApplicationInfo ai2 = PackageParser.generateApplicationInfo(p, flags2, ps2.readUserState(userId), userId);
                                if (ai2 != null) {
                                    ai2.packageName = resolveExternalPackageNameLPr(p);
                                    list.add(ai2);
                                }
                            }
                        }
                    }
                }
            }
        }
        return list;
    }

    public ParceledListSlice<InstantAppInfo> getInstantApps(int userId) {
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getEphemeralApplications");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getEphemeralApplications");
        synchronized (this.mPackages) {
            List<InstantAppInfo> instantApps = this.mInstantAppRegistry.getInstantAppsLPr(userId);
            if (instantApps == null) {
                return null;
            }
            return new ParceledListSlice<>(instantApps);
        }
    }

    public boolean isInstantApp(String packageName, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "isInstantApp");
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            this.mPackages.get(packageName);
            if (!(ps != null && (isCallerSameApp(packageName, callingUid) || canViewInstantApps(callingUid, userId) || this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId)))) {
                return false;
            }
            return ps.getInstantApp(userId);
        }
    }

    public byte[] getInstantAppCookie(String packageName, int userId) {
        byte[] instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.getInstantAppCookieLPw(packageName, userId);
        }
        return instantAppCookieLPw;
    }

    public boolean setInstantAppCookie(String packageName, byte[] cookie, int userId) {
        boolean instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "setInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return false;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.setInstantAppCookieLPw(packageName, cookie, userId);
        }
        return instantAppCookieLPw;
    }

    public Bitmap getInstantAppIcon(String packageName, int userId) {
        Bitmap instantAppIconLPw;
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppIcon");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppIcon");
        synchronized (this.mPackages) {
            instantAppIconLPw = this.mInstantAppRegistry.getInstantAppIconLPw(packageName, userId);
        }
        return instantAppIconLPw;
    }

    private boolean isCallerSameApp(String packageName, int uid) {
        PackageParser.Package pkg = this.mPackages.get(packageName);
        return pkg != null && UserHandle.getAppId(uid) == pkg.applicationInfo.uid;
    }

    public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(getPersistentApplicationsInternal(flags));
    }

    private List<ApplicationInfo> getPersistentApplicationsInternal(int flags) {
        PackageSetting ps;
        ArrayList<ApplicationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            int userId = UserHandle.getCallingUserId();
            for (PackageParser.Package p : this.mPackages.values()) {
                if (p.applicationInfo != null) {
                    boolean matchesAware = true;
                    boolean matchesUnaware = (262144 & flags) != 0 && !p.applicationInfo.isDirectBootAware();
                    if ((524288 & flags) == 0 || !p.applicationInfo.isDirectBootAware()) {
                        matchesAware = false;
                    }
                    if ((p.applicationInfo.flags & 8) != 0 && ((!this.mSafeMode || isSystemApp(p)) && ((matchesUnaware || matchesAware) && (ps = this.mSettings.mPackages.get(p.packageName)) != null))) {
                        boolean isPersistent = getHwPMSEx().isReservePersistentApp(ps);
                        if (!this.mSafeMode || isPersistent) {
                            ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                finalList.add(ai);
                            }
                        }
                    }
                }
            }
        }
        return finalList;
    }

    public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
        return resolveContentProviderInternal(name, flags, userId);
    }

    /* access modifiers changed from: private */
    public ProviderInfo resolveContentProviderInternal(String name, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, name);
        int callingUid = Binder.getCallingUid();
        ProviderInfo providerInfo = this.mComponentResolver.queryProvider(name, flags2, userId);
        if (providerInfo == null || !this.mSettings.isEnabledAndMatchLPr(providerInfo, flags2, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(providerInfo.packageName), callingUid, new ComponentName(providerInfo.packageName, providerInfo.name), 4, userId)) {
                return null;
            }
            return providerInfo;
        }
    }

    @Deprecated
    public void querySyncProviders(List<String> outNames, List<ProviderInfo> outInfo) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            this.mComponentResolver.querySyncProviders(outNames, outInfo, this.mSafeMode, UserHandle.getCallingUserId());
        }
    }

    public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags, String metaDataKey) {
        int userId;
        ArrayList<ProviderInfo> finalList;
        PackageManagerService packageManagerService = this;
        int callingUid = Binder.getCallingUid();
        if (processName != null) {
            userId = UserHandle.getUserId(uid);
        } else {
            userId = UserHandle.getCallingUserId();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = packageManagerService.updateFlagsForComponent(flags, userId, processName);
        List<ProviderInfo> matchList = packageManagerService.mComponentResolver.queryProviders(processName, metaDataKey, uid, flags2, userId);
        int listSize = matchList == null ? 0 : matchList.size();
        synchronized (packageManagerService.mPackages) {
            finalList = null;
            int i = 0;
            while (i < listSize) {
                ProviderInfo providerInfo = matchList.get(i);
                if (packageManagerService.mSettings.isEnabledAndMatchLPr(providerInfo, flags2, userId)) {
                    if (!filterAppAccessLPr(packageManagerService.mSettings.mPackages.get(providerInfo.packageName), callingUid, new ComponentName(providerInfo.packageName, providerInfo.name), 4, userId)) {
                        if (finalList == null) {
                            finalList = new ArrayList<>(listSize - i);
                        }
                        finalList.add(providerInfo);
                    }
                }
                i++;
                packageManagerService = this;
            }
        }
        if (finalList == null) {
            return ParceledListSlice.emptyList();
        }
        finalList.sort(sProviderInitOrderSorter);
        return new ParceledListSlice<>(finalList);
    }

    public InstrumentationInfo getInstrumentationInfo(ComponentName component, int flags) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 0, callingUserId)) {
                return null;
            }
            return PackageParser.generateInstrumentationInfo(this.mInstrumentation.get(component), flags);
        }
    }

    public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr(this.mSettings.mPackages.get(targetPackage), callingUid, UserHandle.getUserId(callingUid))) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(queryInstrumentationInternal(targetPackage, flags));
    }

    private List<InstrumentationInfo> queryInstrumentationInternal(String targetPackage, int flags) {
        InstrumentationInfo ii;
        ArrayList<InstrumentationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Instrumentation p : this.mInstrumentation.values()) {
                if ((targetPackage == null || targetPackage.equals(p.info.targetPackage)) && (ii = PackageParser.generateInstrumentationInfo(p, flags)) != null) {
                    finalList.add(ii);
                }
            }
        }
        return finalList;
    }

    private void scanDirTracedLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        Trace.traceBegin(262144, "scanDir [" + scanDir.getAbsolutePath() + "]");
        try {
            scanDirLI(scanDir, parseFlags, scanFlags, currentTime);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: protected */
    public void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        scanDirLI(dir, parseFlags, scanFlags, currentTime, 0);
    }

    /* access modifiers changed from: protected */
    public void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        File[] files = scanDir.listFiles();
        if (ArrayUtils.isEmpty(files)) {
            Log.d(TAG, "No files in app dir " + scanDir);
            return;
        }
        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, "Scanning app dir " + scanDir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags) + " hwFlags=0x" + Integer.toHexString(hwFlags));
        }
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x0143  */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x0168  */
    public void scanPackageFilesLI(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        ParallelPackageParser.ParseResult parseResult;
        int errorCode;
        String str;
        ParallelPackageParser parallelPackageParser = new ParallelPackageParser(this.mSeparateProcesses, this.mOnlyCore, this.mMetrics, this.mCacheDir, this.mParallelPackageParserCallback);
        try {
            int length = files.length;
            int fileCount = 0;
            int fileCount2 = 0;
            while (fileCount2 < length) {
                try {
                    File file = files[fileCount2];
                    if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                        if (!mHwPMSEx.isUninstallApk(file.getPath() + ".apk")) {
                            HwCustEmergDataManager emergDataManager = HwCustEmergDataManager.getDefault();
                            if (emergDataManager == null || emergDataManager.isEmergencyState() || !emergDataManager.getEmergencyPkgName().contains(file.getName())) {
                                parallelPackageParser.submit(file, parseFlags);
                                fileCount++;
                                fileCount2++;
                            } else {
                                Log.i(TAG, "dont scan EmergencyData.apk");
                            }
                        }
                    }
                    fileCount2++;
                } catch (Throwable th) {
                    th = th;
                    try {
                        throw th;
                    } catch (Throwable th2) {
                        $closeResource(th, parallelPackageParser);
                        throw th2;
                    }
                }
            }
            for (int fileCount3 = fileCount; fileCount3 > 0; fileCount3--) {
                ParallelPackageParser.ParseResult parseResult2 = parallelPackageParser.take();
                Throwable throwable = parseResult2.throwable;
                if (throwable == null) {
                    if (parseResult2.pkg.applicationInfo.isStaticSharedLibrary()) {
                        renameStaticSharedLibraryPackage(parseResult2.pkg);
                    }
                    if (this.mDelPackageList == null || !this.mDelPackageList.contains(parseResult2.pkg.packageName)) {
                        try {
                            str = ": ";
                            parseResult = parseResult2;
                            try {
                                scanPackageChildLI(parseResult2.pkg, parseFlags, scanFlags, currentTime, null, hwFlags);
                                errorCode = 1;
                            } catch (PackageManagerException e) {
                                e = e;
                                int errorCode2 = e.error;
                                Slog.w(TAG, "Failed to scan " + parseResult.scanFile + str + e.getMessage());
                                errorCode = errorCode2;
                                if ((scanFlags & 131072) == 0) {
                                }
                            }
                        } catch (PackageManagerException e2) {
                            e = e2;
                            str = ": ";
                            parseResult = parseResult2;
                            int errorCode22 = e.error;
                            Slog.w(TAG, "Failed to scan " + parseResult.scanFile + str + e.getMessage());
                            errorCode = errorCode22;
                            if ((scanFlags & 131072) == 0) {
                            }
                        }
                    } else {
                        deletePackageIfUnusedLPr(parseResult2.pkg.packageName);
                    }
                } else {
                    parseResult = parseResult2;
                    if (throwable instanceof PackageParser.PackageParserException) {
                        PackageParser.PackageParserException e3 = (PackageParser.PackageParserException) throwable;
                        int errorCode3 = e3.error;
                        Slog.w(TAG, "Failed to parse " + parseResult.scanFile + ": " + e3.getMessage());
                        errorCode = errorCode3;
                    } else {
                        throw new IllegalStateException("Unexpected exception occurred while parsing " + parseResult.scanFile, throwable);
                    }
                }
                if ((scanFlags & 131072) == 0) {
                    if (errorCode != 1) {
                        reportApkScanError(errorCode, parseResult.scanFile);
                        PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                        removeCodePathLI(parseResult.scanFile);
                    }
                }
            }
            $closeResource(null, parallelPackageParser);
        } catch (Throwable th3) {
            th = th3;
            throw th;
        }
    }

    private void reportApkScanError(int errorCode, File file) {
        long elapsedRealtime = SystemClock.elapsedRealtime();
        Slog.i(TAG, "scan userdata apps error, errorCode:" + errorCode + ", file name:" + file.getName() + ", elapsedRealtime: " + elapsedRealtime);
        HwPackageManagerServiceUtils.reportPmsDeleteDataApp(errorCode, file.getName(), elapsedRealtime);
    }

    public static void reportSettingsProblem(int priority, String msg) {
        PackageManagerServiceUtils.logCriticalInfo(priority, msg);
    }

    private void collectCertificatesLI(PackageSetting ps, PackageParser.Package pkg, boolean forceCollect, boolean skipVerify) throws PackageManagerException {
        long lastModifiedTime = this.mIsPreNMR1Upgrade ? new File(pkg.codePath).lastModified() : PackageManagerServiceUtils.getLastModifiedTime(pkg);
        Settings.VersionInfo settingsVersionForPackage = getSettingsVersionForPackage(pkg);
        if (ps == null || forceCollect || !ps.codePathString.equals(pkg.codePath) || ps.timeStamp != lastModifiedTime || isCompatSignatureUpdateNeeded(settingsVersionForPackage) || isRecoverSignatureUpdateNeeded(settingsVersionForPackage)) {
            StringBuilder sb = new StringBuilder();
            sb.append(pkg.codePath);
            sb.append(" changed; collecting certs");
            sb.append(forceCollect ? " (forced)" : "");
            Slog.i(TAG, sb.toString());
        } else if (ps.signatures.mSigningDetails.signatures == null || ps.signatures.mSigningDetails.signatures.length == 0 || ps.signatures.mSigningDetails.signatureSchemeVersion == 0) {
            Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.,skipVerify=" + skipVerify);
        } else {
            pkg.mSigningDetails = new PackageParser.SigningDetails(ps.signatures.mSigningDetails);
            return;
        }
        try {
            Trace.traceBegin(262144, "collectCertificates");
            PackageParser.collectCertificates(pkg, skipVerify);
            Trace.traceEnd(262144);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    private void maybeClearProfilesForUpgradesLI(PackageSetting originalPkgSetting, PackageParser.Package currentPkg) {
        if (originalPkgSetting != null && isDeviceUpgrading() && originalPkgSetting.versionCode != ((long) currentPkg.mVersionCode)) {
            clearAppProfilesLIF(currentPkg, -1);
            if (DEBUG_INSTALL) {
                Slog.d(TAG, originalPkgSetting.name + " clear profile due to version change " + originalPkgSetting.versionCode + " != " + currentPkg.mVersionCode);
            }
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageTracedLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    private PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        Trace.traceBegin(262144, "scanPackage [" + scanFile.toString() + "]");
        try {
            return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: protected */
    @GuardedBy({"mInstallLock", "mPackages"})
    public PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* access modifiers changed from: protected */
    public PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx.isUninstallApk(scanFile.getPath() + ".apk")) {
            return null;
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Parsing: " + scanFile);
        }
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setOnlyCoreApps(this.mOnlyCore);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        pp.setCacheDir(this.mCacheDir);
        Trace.traceBegin(262144, "parsePackage");
        try {
            PackageParser.Package pkg = pp.parsePackage(scanFile, parseFlags, true, hwFlags);
            Trace.traceEnd(262144);
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                renameStaticSharedLibraryPackage(pkg);
            }
            return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user, hwFlags);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable pkg2) {
            Trace.traceEnd(262144);
            throw pkg2;
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Removed duplicated region for block: B:11:0x0037  */
    /* JADX WARNING: Removed duplicated region for block: B:12:0x003a  */
    /* JADX WARNING: Removed duplicated region for block: B:21:0x0076 A[RETURN] */
    /* JADX WARNING: Removed duplicated region for block: B:22:0x0078  */
    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        int fixedScanFlags;
        int hwFlags2;
        int hwFlags3;
        int scanFlags2;
        ArrayList<PackageParser.Package> arrayList;
        if (!pkg.codePath.startsWith(SYSTEM_ROOT_DIR)) {
            if (locationIsProduct(pkg.codePath)) {
                fixedScanFlags = scanFlags | 2097152;
            } else if (locationIsVendor(pkg.codePath)) {
                fixedScanFlags = scanFlags | 1048576;
            }
            if ((pkg.applicationInfo.hwFlags & 1048576) == 0) {
                hwFlags2 = hwFlags | 1048576;
            } else {
                hwFlags2 = hwFlags;
            }
            pkg.applicationInfo.hwFlags = hwFlags2;
            if (mHwPMSEx.isPreRemovableApp(pkg.codePath) || (hwFlags2 & DumpState.DUMP_APEX) != 0) {
                hwFlags3 = hwFlags2;
            } else {
                int hwFlags4 = hwFlags2 | DumpState.DUMP_APEX;
                pkg.applicationInfo.hwFlags = hwFlags2 | DumpState.DUMP_APEX;
                hwFlags3 = hwFlags4;
            }
            pkg.applicationInfo.forceDarkMode = mHwPMSEx.getForceDarkSetting(pkg.packageName);
            if (!mHwPMSEx.isInMspesForbidInstallPackageList(pkg.packageName)) {
                return null;
            }
            if (mHwPMSEx.isInMultiWinWhiteList(pkg.packageName)) {
                pkg.forceResizeableAllActivity();
            }
            if ((fixedScanFlags & 1024) != 0) {
                scanFlags2 = fixedScanFlags & -1025;
            } else if (pkg.childPackages == null || pkg.childPackages.size() <= 0) {
                scanFlags2 = fixedScanFlags;
            } else {
                scanFlags2 = fixedScanFlags | 1024;
            }
            int childCount = 0;
            boolean isNewInstall = (hwFlags3 & 1073741824) != 0 && !this.mPackages.containsKey(pkg.packageName);
            PackageParser.Package scannedPkg = addForInitLI(pkg, parseFlags, scanFlags2, currentTime, user, hwFlags3);
            if (pkg.childPackages != null) {
                childCount = pkg.childPackages.size();
            }
            for (int i = 0; i < childCount; i++) {
                addForInitLI((PackageParser.Package) pkg.childPackages.get(i), parseFlags, scanFlags2, currentTime, user, hwFlags3);
            }
            if ((scanFlags2 & 1024) != 0) {
                return scanPackageChildLI(pkg, parseFlags, scanFlags2, currentTime, user, hwFlags3);
            }
            if (!(!this.mCotaFlag || (arrayList = this.mTempPkgList) == null || scannedPkg == null)) {
                arrayList.add(pkg);
            }
            mHwPMSEx.doPostScanInstall(pkg, user, isNewInstall, hwFlags3, scannedPkg);
            return scannedPkg;
        }
        fixedScanFlags = scanFlags;
        if ((pkg.applicationInfo.hwFlags & 1048576) == 0) {
        }
        pkg.applicationInfo.hwFlags = hwFlags2;
        if (mHwPMSEx.isPreRemovableApp(pkg.codePath)) {
        }
        hwFlags3 = hwFlags2;
        pkg.applicationInfo.forceDarkMode = mHwPMSEx.getForceDarkSetting(pkg.packageName);
        if (!mHwPMSEx.isInMspesForbidInstallPackageList(pkg.packageName)) {
        }
    }

    private boolean canSkipForcedPackageVerification(PackageParser.Package pkg) {
        if (!canSkipForcedApkVerification(pkg.baseCodePath)) {
            return false;
        }
        if (ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            return true;
        }
        for (int i = 0; i < pkg.splitCodePaths.length; i++) {
            if (!canSkipForcedApkVerification(pkg.splitCodePaths[i])) {
                return false;
            }
        }
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0021, code lost:
        r1 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0022, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Error in fsverity check. Fallback to full apk verification.", r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0029, code lost:
        return false;
     */
    /* JADX WARNING: Removed duplicated region for block: B:17:0x0021 A[ExcHandler: InstallerException | IOException | DigestException | NoSuchAlgorithmException (r1v1 'e' java.lang.Exception A[CUSTOM_DECLARE]), Splitter:B:15:0x0020] */
    private boolean canSkipForcedApkVerification(String apkPath) {
        if (!PackageManagerServiceUtils.isLegacyApkVerityEnabled()) {
            return VerityUtils.hasFsverity(apkPath);
        }
        byte[] rootHashObserved = VerityUtils.generateApkVerityRootHash(apkPath);
        if (rootHashObserved == null) {
            return false;
        }
        synchronized (this.mInstallLock) {
            this.mInstaller.assertFsverityRootHashMatches(apkPath, rootHashObserved);
        }
        return true;
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return addForInitLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x01fb, code lost:
        if (r11 >= r11) goto L_0x0242;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x01fd, code lost:
        r7 = (java.lang.String) r11.childPackageNames.get(r11);
        r16 = false;
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x020d, code lost:
        if (r0 >= r2) goto L_0x022d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x020f, code lost:
        r31 = r2;
        r32 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0221, code lost:
        if (((android.content.pm.PackageParser.Package) r44.childPackages.get(r0)).packageName.equals(r7) == false) goto L_0x0226;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x0223, code lost:
        r16 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x0226, code lost:
        r0 = r0 + 1;
        r2 = r31;
        r3 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x022d, code lost:
        r31 = r2;
        r32 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x0231, code lost:
        if (r16 != false) goto L_0x0238;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x0233, code lost:
        r43.mSettings.removeDisabledSystemPackageLPw(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x0238, code lost:
        r11 = r11 + 1;
        r0 = r0;
        r2 = r31;
        r3 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0253, code lost:
        if (r44 != r43.mPlatformPackage) goto L_0x0258;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x0255, code lost:
        r21 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x0258, code lost:
        r21 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x025a, code lost:
        r7 = r11;
        r2 = r11;
        r0 = new com.android.server.pm.PackageManagerService.ScanRequest(r44, r6, null, r7, null, null, null, r45, r46, r21, r49);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x0272, code lost:
        if (isSystemAppGrantByMdmAndNonPreload(r44) == false) goto L_0x0280;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:?, code lost:
        r11 = com.android.server.pm.PackageManagerService.mHwPMSEx.adjustScanFlagForApk(r44, r46);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x027d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0280, code lost:
        r11 = r46;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:?, code lost:
        applyPolicy(r44, r45, r11, r43.mPlatformPackage, r50);
        r12 = scanPackageOnlyLI(r0, r43.mFactoryTest, -1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x0292, code lost:
        if (r12.existingSettingCopied == false) goto L_0x02ba;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x0298, code lost:
        if (r12.request.pkgSetting == null) goto L_0x02ba;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x029a, code lost:
        r12.request.pkgSetting.updateFrom(r12.pkgSetting);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x02a4, code lost:
        r12 = r46;
        r7 = r11;
        r2 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x02af, code lost:
        r12 = r46;
        r7 = r11;
        r2 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:0x02b9, code lost:
        r11 = r12;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x02ba, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x02bc, code lost:
        if (r11 == false) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x02be, code lost:
        if (r23 == false) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x02c4, code lost:
        if (isUpgrade() == false) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:139:0x02c8, code lost:
        if (r2.codePathString == null) goto L_0x02d6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x02d2, code lost:
        if (r2.codePathString.startsWith("/data/app/") == false) goto L_0x02d6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x02d4, code lost:
        r3 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x02d6, code lost:
        r3 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x02d9, code lost:
        if (r44.hasPlugin != false) goto L_0x02e4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x02df, code lost:
        if ((r2.hw_extra_flags & 1) == 0) goto L_0x02e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:148:0x02e2, code lost:
        r4 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x02e4, code lost:
        r4 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x02e5, code lost:
        if (r3 == false) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x02e7, code lost:
        if (r4 == false) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02e9, code lost:
        r6 = com.android.server.HwServiceExFactory.getHwPluginPackage(r43, r44.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02ef, code lost:
        if (r6 == null) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x02f6, code lost:
        if (1 != r6.mergePluginCommit(r44, r2, r7)) goto L_0x0326;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x02f8, code lost:
        createInstallArgsForExisting(r2.codePathString, r2.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r2)).cleanUpResourcesLI();
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "pluginMerge.renameStage " + r44.packageName);
        r6.renameStage();
        r12 = 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x0326, code lost:
        r12 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x0327, code lost:
        if (r11 == false) goto L_0x0335;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x0331, code lost:
        if (r2.codePathString.equals(r44.codePath) != false) goto L_0x0335;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:161:0x0333, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x0335, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x0337, code lost:
        if (r11 == false) goto L_0x0345;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x0341, code lost:
        if (r44.getLongVersionCode() <= r2.versionCode) goto L_0x0345;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x0343, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x0345, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x0349, code lost:
        if (r43.mIsUpgrade == false) goto L_0x035d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x034b, code lost:
        if (r23 == false) goto L_0x035d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x034d, code lost:
        if (r11 == false) goto L_0x035d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x034f, code lost:
        if (r11 == false) goto L_0x035d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x0359, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isInValidApkPatchFile(r2.codePath, r45) == false) goto L_0x035d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x035b, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x035d, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x035f, code lost:
        if (r23 == false) goto L_0x0367;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x0361, code lost:
        if (r11 == false) goto L_0x0367;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x0363, code lost:
        if (r0 == false) goto L_0x0367;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0365, code lost:
        if (r0 != false) goto L_0x0369;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x0367, code lost:
        if (r0 == false) goto L_0x036b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x0369, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x036b, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x036e, code lost:
        if (r0 == false) goto L_0x03df;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x0370, code lost:
        if (r12 != null) goto L_0x03df;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x0372, code lost:
        r3 = r43.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x0374, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:?, code lost:
        r43.mPackages.remove(r2.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x037c, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x037d, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "System package updated; name: " + r2.name + "; " + r2.versionCode + " --> " + r44.getLongVersionCode() + "; " + r2.codePathString + " --> " + r44.codePath);
        createInstallArgsForExisting(r2.codePathString, r2.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r2)).cleanUpResourcesLI();
        r4 = r43.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x03cf, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:?, code lost:
        r43.mSettings.enableSystemPackageLPw(r2.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x03d7, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x03df, code lost:
        if (r23 == false) goto L_0x042b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x03e1, code lost:
        if (r11 == false) goto L_0x042b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:208:0x03e3, code lost:
        if (r0 == false) goto L_0x03e8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:209:0x03e5, code lost:
        if (r12 != null) goto L_0x03e8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x03e8, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.addUpdatedRemoveableAppFlag(r44.codePath, r44.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:211:0x042a, code lost:
        throw new com.android.server.pm.PackageManagerException(5, "Package " + r44.packageName + " at " + r44.codePath + " ignored: updated version " + r2.versionCode + " better than this " + r44.getLongVersionCode());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:212:0x042b, code lost:
        if (r11 == false) goto L_0x0441;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x0435, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.needAddUpdatedRemoveableAppFlag(r44.packageName) == false) goto L_0x0441;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:215:0x0437, code lost:
        r6 = (r50 & -33554433) | com.android.server.pm.DumpState.DUMP_HANDLE;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x0441, code lost:
        r6 = r50;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:218:0x0445, code lost:
        if (r43.mIsUpgrade == false) goto L_0x0449;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x0447, code lost:
        if (r23 != false) goto L_0x044f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:221:0x044d, code lost:
        if (com.android.server.pm.PackageManagerServiceUtils.isApkVerificationForced(r7) == false) goto L_0x0451;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:222:0x044f, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:223:0x0451, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:225:0x0453, code lost:
        if (r23 != false) goto L_0x0469;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:226:0x0455, code lost:
        if (r0 == false) goto L_0x045d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:228:0x045b, code lost:
        if (canSkipForcedPackageVerification(r44) != false) goto L_0x0469;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:230:0x0460, code lost:
        if ((33554432 & r6) != 0) goto L_0x0469;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:232:0x0464, code lost:
        if (r43.mIsPrePUpgrade == false) goto L_0x0467;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:233:0x0467, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:234:0x0469, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:235:0x046a, code lost:
        collectCertificatesLI(r2, r44, r0, r0);
        com.android.server.pm.PackageManagerService.mHwPMSEx.checkIllegalSysApk(r44, r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:236:0x0473, code lost:
        if (r2 == null) goto L_0x049c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:238:0x047d, code lost:
        if (r2.codePathString.equals(r44.codePath) == false) goto L_0x0497;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:239:0x047f, code lost:
        r50 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:240:0x0492, code lost:
        if (r2.timeStamp == new java.io.File(r44.codePath).lastModified()) goto L_0x0495;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:241:0x0495, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:242:0x0497, code lost:
        r50 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:243:0x049c, code lost:
        r50 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:244:0x04a0, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:245:0x04a1, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.checkHwCertification(r44, r0);
        com.android.server.pm.PackageManagerService.mHwPMSEx.replaceSignatureIfNeeded(r2, r44, true, r0);
        maybeClearProfilesForUpgradesLI(r2, r44);
        r18 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:246:0x04b2, code lost:
        if (r2 != null) goto L_0x04b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:247:0x04b4, code lost:
        r28 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:249:0x04c1, code lost:
        if (isSystemAppGrantByMdmAndNonPreload(r2.name, r2.codePathString, r2.volumeUuid) == false) goto L_0x04ca;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:251:0x04c5, code lost:
        if (r43.mSystemReady != false) goto L_0x04ca;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:252:0x04c7, code lost:
        r28 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:253:0x04ca, code lost:
        r28 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:255:0x04ce, code lost:
        if (r23 == false) goto L_0x0655;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:256:0x04d0, code lost:
        if (r11 != false) goto L_0x0655;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:257:0x04d2, code lost:
        if (r11 == false) goto L_0x0655;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:259:0x04d8, code lost:
        if (r2.isSystem() == false) goto L_0x04ed;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:260:0x04da, code lost:
        if (r28 == false) goto L_0x04dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:261:0x04dd, code lost:
        r1 = r2;
        r22 = r6;
        r13 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:263:0x04f8, code lost:
        if (r44.mSigningDetails.checkCapability(r2.signatures.mSigningDetails, 1) != false) goto L_0x059a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:265:0x0506, code lost:
        if (r2.signatures.mSigningDetails.checkCapability(r44.mSigningDetails, 8) != false) goto L_0x058a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:266:0x0508, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "System package signature mismatch; name: " + r2.name);
        r3 = freezePackage(r44.packageName, "scanPackageInternalLI");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:269:0x052a, code lost:
        r22 = r6;
        r13 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:271:?, code lost:
        deletePackageLIF(r44.packageName, null, true, null, 0, null, false, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:273:0x0561, code lost:
        if (r3 == null) goto L_0x0566;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:274:0x0563, code lost:
        $closeResource(null, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:276:0x056a, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:277:0x056b, code lost:
        r1 = r3;
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:278:0x056f, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:279:0x0570, code lost:
        r1 = r3;
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:281:?, code lost:
        throw r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:282:0x0582, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:284:0x0584, code lost:
        if (r1 != null) goto L_0x0586;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:285:0x0586, code lost:
        $closeResource(r2, r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:286:0x0589, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:287:0x058a, code lost:
        r34 = r2;
        r22 = r6;
        r13 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:288:0x059a, code lost:
        r34 = r2;
        r22 = r6;
        r13 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:289:0x05a9, code lost:
        if (r0 == false) goto L_0x0607;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:290:0x05ab, code lost:
        if (r12 != null) goto L_0x0607;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:291:0x05ad, code lost:
        r0 = new java.lang.StringBuilder();
        r0.append("System package enabled; name: ");
        r1 = r34;
        r0.append(r1.name);
        r0.append("; ");
        r0.append(r1.versionCode);
        r0.append(" --> ");
        r0.append(r44.getLongVersionCode());
        r0.append("; ");
        r0.append(r1.codePathString);
        r0.append(" --> ");
        r0.append(r13.codePath);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, r0.toString());
        r2 = createInstallArgsForExisting(r1.codePathString, r1.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r1));
        r3 = r43.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:292:0x05fe, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:294:?, code lost:
        r2.cleanUpResourcesLI();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:295:0x0602, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:300:0x0607, code lost:
        r18 = true;
        com.android.server.pm.PackageManagerService.mHwPMSEx.addUpdatedRemoveableAppFlag(r13.codePath, r34.name);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, "System package disabled; name: " + r34.name + "; old: " + r34.codePathString + " @ " + r34.versionCode + "; new: " + r13.codePath + " @ " + r13.codePath);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:301:0x0655, code lost:
        r1 = r2;
        r22 = r6;
        r13 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:303:0x0664, code lost:
        r1 = scanPackageNewLI(r44, r45, r11 | 2, r47, r49, r22);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:304:0x0678, code lost:
        if (r1.success == false) goto L_0x0727;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:305:0x067a, code lost:
        r2 = r43.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:306:0x067c, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:309:?, code lost:
        r0 = r1.pkgSetting.name;
        r4 = reconcilePackagesLocked(new com.android.server.pm.PackageManagerService.ReconcileRequest(java.util.Collections.singletonMap(r0, r1), r43.mSharedLibraries, r43.mPackages, java.util.Collections.singletonMap(r0, getSettingsVersionForPackage(r44)), java.util.Collections.singletonMap(r0, getSharedLibLatestVersionSetting(r1)), null), r43.mSettings.mKeySetManagerService);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:310:0x06b2, code lost:
        if ((131072 & r11) == 0) goto L_0x070a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:311:0x06b4, code lost:
        r5 = com.android.server.pm.PackageManagerService.mHwPMSEx.generateRenamedPackagePolicyLocked(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:312:0x06be, code lost:
        if (r5.isPresent() == false) goto L_0x0704;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:314:0x06ca, code lost:
        if (r5.get().getAppId() <= 0) goto L_0x0704;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:315:0x06cc, code lost:
        r1.pkgSetting.appId = r5.get().getAppId();
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "rename package " + r0 + " used appId:" + r5.get().getAppId());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:316:0x0704, code lost:
        r6 = optimisticallyRegisterAppId(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:318:0x070a, code lost:
        r5 = optimisticallyRegisterAppId(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:319:0x070f, code lost:
        commitReconciledScanResultLocked(r4.get(r0));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:321:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:323:0x071b, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:325:0x071d, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:326:0x071e, code lost:
        if (0 != 0) goto L_0x0720;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:327:0x0720, code lost:
        cleanUpAppIdCreation(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:328:0x0724, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:330:0x0726, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:331:0x0727, code lost:
        if (r18 == false) goto L_0x0739;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:332:0x0729, code lost:
        r2 = r43.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:333:0x072b, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:335:?, code lost:
        r43.mSettings.disableSystemPackageLPw(r13.packageName, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:336:0x0734, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:341:0x0739, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.addPreinstalledPkgToList(r1.pkgSetting.pkg);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:342:0x0746, code lost:
        return r1.pkgSetting.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:343:0x0747, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:345:0x074b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:349:?, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:350:0x0750, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:351:0x0751, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:357:0x0759, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00e0, code lost:
        r44.setApplicationVolumeUuid(r44.volumeUuid);
        r44.setApplicationInfoCodePath(r44.codePath);
        r44.setApplicationInfoBaseCodePath(r44.baseCodePath);
        r44.setApplicationInfoSplitCodePaths(r44.splitCodePaths);
        r44.setApplicationInfoResourcePath(r44.codePath);
        r44.setApplicationInfoBaseResourcePath(r44.baseCodePath);
        r44.setApplicationInfoSplitResourcePaths(r44.splitCodePaths);
        r4 = r43.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x0105, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:?, code lost:
        r0 = r43.mSettings.getRenamedPackageLPr(r44.mRealPackage);
        r0 = getRealPackageName(r44, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0113, code lost:
        if (r0 == null) goto L_0x0118;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0115, code lost:
        ensurePackageRenamed(r44, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x0118, code lost:
        r3 = getOriginalPackageLocked(r44, r0);
        r11 = r43.mSettings.getPackageLPr(r44.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0126, code lost:
        if (r3 != null) goto L_0x012b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x0128, code lost:
        r11 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x012b, code lost:
        r11 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x012d, code lost:
        if (r11 == null) goto L_0x0131;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x012f, code lost:
        r11 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x0131, code lost:
        r11 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x0134, code lost:
        if (r11 == false) goto L_0x0139;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x0136, code lost:
        r11 = r11.name;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0139, code lost:
        r11 = r44.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x013c, code lost:
        if (r23 == false) goto L_0x0163;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x013e, code lost:
        if (r11 != false) goto L_0x0163;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x0146, code lost:
        if (r43.mSettings.getDisabledSystemPkgLPr(r11) == null) goto L_0x0163;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x0148, code lost:
        r43.mSettings.removeDisabledSystemPackageLPw(r11);
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, r11 + " updated but found that the pkg is not already exists, remove updated info!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x0163, code lost:
        r11 = r43.mSettings.getDisabledSystemPkgLPr(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x016a, code lost:
        if (r11 == null) goto L_0x016e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x016c, code lost:
        r11 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x016e, code lost:
        r11 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x0173, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x018e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0175, code lost:
        if (r11 == false) goto L_0x018e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x0177, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "updatedPkg = " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x018e, code lost:
        r43.mSettings.addReservedUidForSharedUser(r44.mSharedUserId, r44.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0199, code lost:
        if (r44.mSharedUserId == null) goto L_0x01a4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x019b, code lost:
        r6 = r43.mSettings.getSharedUserLPw(r44.mSharedUserId, 0, 0, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x01a4, code lost:
        r6 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x01a8, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PACKAGE_SCANNING == false) goto L_0x01dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x01ad, code lost:
        if ((Integer.MIN_VALUE & r45) == 0) goto L_0x01dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x01af, code lost:
        if (r6 == null) goto L_0x01dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x01b1, code lost:
        android.util.Log.d(com.android.server.pm.PackageManagerService.TAG, "Shared UserID " + r44.mSharedUserId + " (uid=" + r6.userId + "): packages=" + r6.packages);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x01dd, code lost:
        if (r23 == false) goto L_0x02af;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x01df, code lost:
        if (r11 == false) goto L_0x02a4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01e3, code lost:
        if (r44.childPackages == null) goto L_0x01ec;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x01e5, code lost:
        r2 = r44.childPackages.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x01ec, code lost:
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x01ef, code lost:
        if (r11.childPackageNames == null) goto L_0x01f8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x01f1, code lost:
        r11 = r11.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01f8, code lost:
        r11 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x01f9, code lost:
        r11 = 0;
     */
    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        boolean scanSystemPartition = (parseFlags & 16) != 0;
        boolean scanSystemPartition2 = (scanSystemPartition || !isSystemApp(pkg) || !isSystemAppGrantByMdmAndNonPreload(pkg.packageName, pkg.codePath, pkg.volumeUuid)) ? scanSystemPartition : true;
        synchronized (this.mPackages) {
            if ((1073741824 & hwFlags) == 0) {
                PackageSetting psTemp = this.mSettings.getPackageLPr(pkg.packageName);
                if (!mHwPMSEx.needInstallRemovablePreApk(pkg, hwFlags)) {
                    mHwPMSEx.addUnisntallDataToCache(pkg.packageName, pkg.codePath);
                    if (psTemp == null || !psTemp.isAnyInstalled(sUserManager.getUserIds()) || (this.mSettings.getDisabledSystemPkgLPr(pkg.packageName) == null && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/"))) {
                        Slog.d(TAG, "scan return here for package:" + pkg.packageName);
                        return null;
                    }
                } else if (psTemp != null && pkg.codePath != null && !pkg.codePath.startsWith("/data/app/") && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/") && !scanSystemPartition2 && ((long) pkg.mVersionCode) <= psTemp.versionCode) {
                    Slog.d(TAG, "scan return here for ota nosys package:" + pkg.packageName);
                    mHwPMSEx.recordUninstalledDelapp(pkg.packageName, pkg.codePath.toString());
                    return null;
                }
            }
        }
        while (true) {
        }
    }

    private static void renameStaticSharedLibraryPackage(PackageParser.Package pkg) {
        pkg.setPackageName(pkg.packageName + STATIC_SHARED_LIB_DELIMITER + pkg.staticSharedLibVersion);
    }

    static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return processName;
    }

    private static void enforceSystemOrRoot(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0) {
            throw new SecurityException(message);
        }
    }

    private static void enforceSystemOrRootOrShell(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0 && uid != 2000) {
            throw new SecurityException(message);
        }
    }

    public void performFstrimIfNeeded() {
        boolean dexOptDialogShown;
        enforceSystemOrRoot("Only the system can request fstrim");
        HwThemeManager.applyDefaultHwTheme(false, this.mContext, 0);
        HwThemeManager.linkDataSkinDirAsUser(0);
        try {
            IStorageManager sm = PackageHelper.getStorageManager();
            if (sm != null) {
                boolean doTrim = false;
                long interval = Settings.Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", DEFAULT_MANDATORY_FSTRIM_INTERVAL);
                if (interval > 0) {
                    long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();
                    if (timeSinceLast > interval) {
                        doTrim = true;
                        Slog.w(TAG, "No disk maintenance in " + timeSinceLast + "; running immediately");
                    }
                }
                if (doTrim) {
                    synchronized (this.mPackages) {
                        dexOptDialogShown = this.mDexOptDialogShown;
                    }
                    if (!isFirstBoot() && dexOptDialogShown) {
                        try {
                            ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039596), true);
                        } catch (RemoteException e) {
                        }
                    }
                    sm.runMaintenance();
                    return;
                }
                return;
            }
            Slog.e(TAG, "storageManager service unavailable!");
        } catch (RemoteException e2) {
        }
    }

    public void updatePackagesIfNeeded() {
        List<PackageParser.Package> pkgs;
        enforceSystemOrRoot("Only the system can request package update");
        boolean causeUpgrade = isDeviceUpgrading();
        boolean cacheEnabled = SystemProperties.getBoolean(MAPLE_DECOUPLE_CACHE_ENABLE, true);
        if ((causeUpgrade || isFirstBoot()) && cacheEnabled && mHwPMSEx.isMygoteEnabled()) {
            long startTime = System.nanoTime();
            for (PackageParser.Package pkg : mHwPMSEx.obtainMaplePkgsToGenCache()) {
                Slog.i(TAG, "[DCP] -> generateCachesForMplApps is called " + pkg.baseCodePath);
                int cacheLevel = mHwPMSEx.getCacheLevelForMapleApp(pkg);
                String mapleClassPath = mHwPMSEx.obtainMapleClassPathByPkg(pkg);
                if (!(cacheLevel == -1 || mapleClassPath == null)) {
                    int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
                    synchronized (this.mInstallLock) {
                        mHwPMSEx.callGenMplCacheAtPmsInstaller(pkg.baseCodePath, sharedGid, cacheLevel, mapleClassPath);
                    }
                }
            }
            Slog.i(TAG, "[DCP] -> extra time consumed at hota : " + ((int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime)) + " seconds");
        }
        boolean causeFirstBoot = isFirstBoot() || this.mIsPreNUpgrade;
        boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
        if (!IS_BOPD) {
            if (causeUpgrade || causeFirstBoot || causePrunedCache) {
                synchronized (this.mPackages) {
                    pkgs = PackageManagerServiceUtils.getPackagesForDexopt(this.mPackages.values(), this);
                }
                boolean showDialog = this.mIsPreNUpgrade;
                if (SystemProperties.getBoolean("ro.config.show_dex2oatDialog", true)) {
                    showDialog = this.mIsUpgrade;
                }
                long startTime2 = System.nanoTime();
                int[] stats = performDexOptUpgrade(pkgs, showDialog, causeFirstBoot ? 0 : 1, false);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_dexopted", stats[0]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_skipped", stats[1]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_failed", stats[2]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_total", getOptimizablePackages().size());
                MetricsLogger.histogram(this.mContext, "opt_dialog_time_s", (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime2));
            }
        }
    }

    private static String getPrebuildProfilePath(PackageParser.Package pkg) {
        return pkg.baseCodePath + ".prof";
    }

    /* access modifiers changed from: package-private */
    public boolean isUseProfileForDexopt(PackageParser.Package pkg) {
        if ((!isFirstBoot() && !isUpgrade()) || !isSystemApp(pkg)) {
            return false;
        }
        File profileFile = new File(getPrebuildProfilePath(pkg));
        if (profileFile.exists()) {
            try {
                if (this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                    return false;
                }
                Log.e(TAG, "Installer failed to copy system profile!");
                return false;
            } catch (Exception e) {
                Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + HwLog.PREFIX, e);
                return false;
            }
        } else {
            PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (disabledPs == null || !disabledPs.pkg.isStub) {
                return false;
            }
            File profileFile2 = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, ""));
            if (!profileFile2.exists()) {
                return false;
            }
            try {
                if (this.mInstaller.copySystemProfile(profileFile2.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                    return true;
                }
                Log.e(TAG, "Failed to copy system profile for stub package!");
                return false;
            } catch (Exception e2) {
                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + HwLog.PREFIX, e2);
                return false;
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:65:0x013f  */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x0160  */
    private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, int compilationReason, boolean bootComplete) {
        Iterator<PackageParser.Package> it;
        boolean useProfileForDexopt;
        boolean useProfileForDexopt2;
        if (ZygoteInit.sIsMygote) {
            MplDexOptAdaptor.getInstance().getDexOptNeededCachePrepare(pkgs, compilationReason, bootComplete, this.mDexManager, this, 0);
        }
        int numberOfPackagesVisited = 0;
        int numberOfPackagesOptimized = 0;
        int numberOfPackagesSkipped = 0;
        int numberOfPackagesFailed = 0;
        int numberOfPackagesToDexopt = pkgs.size();
        Iterator<PackageParser.Package> it2 = pkgs.iterator();
        while (it2.hasNext()) {
            PackageParser.Package pkg = it2.next();
            int numberOfPackagesVisited2 = numberOfPackagesVisited + 1;
            boolean useProfileForDexopt3 = ZygoteInit.sIsMygote ? false : isUseProfileForDexopt(pkg);
            if (!isFirstBoot() && !isDeviceUpgrading()) {
                it = it2;
                useProfileForDexopt2 = useProfileForDexopt3;
            } else if (isSystemApp(pkg)) {
                File profileFile = new File(getPrebuildProfilePath(pkg));
                if (profileFile.exists()) {
                    try {
                        it = it2;
                        try {
                            useProfileForDexopt2 = useProfileForDexopt3;
                            try {
                                if (!this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                                    Log.e(TAG, "Installer failed to copy system profile!");
                                }
                            } catch (Exception e) {
                                e = e;
                                Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + HwLog.PREFIX, e);
                                useProfileForDexopt = useProfileForDexopt2;
                                if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                        } catch (Exception e2) {
                            e = e2;
                            useProfileForDexopt2 = useProfileForDexopt3;
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + HwLog.PREFIX, e);
                            useProfileForDexopt = useProfileForDexopt2;
                            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                            }
                        }
                    } catch (Exception e3) {
                        e = e3;
                        it = it2;
                        useProfileForDexopt2 = useProfileForDexopt3;
                        Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + HwLog.PREFIX, e);
                        useProfileForDexopt = useProfileForDexopt2;
                        if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                        }
                    }
                } else {
                    it = it2;
                    useProfileForDexopt2 = useProfileForDexopt3;
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                    if (disabledPs != null && disabledPs.pkg.isStub) {
                        File profileFile2 = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, ""));
                        if (profileFile2.exists()) {
                            try {
                                try {
                                } catch (Exception e4) {
                                    e = e4;
                                    Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + HwLog.PREFIX, e);
                                    useProfileForDexopt = useProfileForDexopt2;
                                    if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                                try {
                                    if (!this.mInstaller.copySystemProfile(profileFile2.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                                        Log.e(TAG, "Failed to copy system profile for stub package!");
                                        useProfileForDexopt = useProfileForDexopt2;
                                    } else {
                                        useProfileForDexopt = true;
                                    }
                                } catch (Exception e5) {
                                    e = e5;
                                    Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + HwLog.PREFIX, e);
                                    useProfileForDexopt = useProfileForDexopt2;
                                    if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                            } catch (Exception e6) {
                                e = e6;
                                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + HwLog.PREFIX, e);
                                useProfileForDexopt = useProfileForDexopt2;
                                if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                if (DEBUG_DEXOPT) {
                                    Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
                                }
                                numberOfPackagesSkipped++;
                                numberOfPackagesVisited = numberOfPackagesVisited2;
                                it2 = it;
                            } else {
                                if (DEBUG_DEXOPT) {
                                    Log.i(TAG, "Updating app " + numberOfPackagesVisited2 + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
                                }
                                if (showDialog) {
                                    HwPackageManagerServiceUtils.showBootAnimationMessage(numberOfPackagesVisited2, numberOfPackagesToDexopt);
                                }
                                int pkgCompilationReason = compilationReason;
                                if (useProfileForDexopt) {
                                    pkgCompilationReason = 3;
                                }
                                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
                                    this.mArtManagerService.compileLayouts(pkg);
                                }
                                int dexoptFlags = bootComplete ? 4 : 0;
                                if (compilationReason == 0) {
                                    dexoptFlags |= 1024;
                                }
                                int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
                                if (primaryDexOptStaus == -1) {
                                    numberOfPackagesFailed++;
                                } else if (primaryDexOptStaus == 0) {
                                    numberOfPackagesSkipped++;
                                } else if (primaryDexOptStaus != 1) {
                                    Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                                } else {
                                    numberOfPackagesOptimized++;
                                }
                                numberOfPackagesVisited = numberOfPackagesVisited2;
                                it2 = it;
                            }
                        }
                    }
                }
            } else {
                it = it2;
                useProfileForDexopt2 = useProfileForDexopt3;
            }
            useProfileForDexopt = useProfileForDexopt2;
            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
            }
        }
        HwPackageManagerServiceUtils.stopBootAnimationMessage(this);
        if (ZygoteInit.sIsMygote) {
            MplDexOptAdaptor.getInstance().getDexOptNeededCacheClear();
        }
        return new int[]{numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed};
    }

    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (getInstantAppPackageName(callingUid) != null) {
                if (!isCallerSameApp(packageName, callingUid)) {
                    return;
                }
            } else if (isInstantApp(packageName, callingUserId)) {
                return;
            }
            notifyPackageUseLocked(packageName, reason);
        }
    }

    @GuardedBy({"mPackages"})
    public PackageManagerInternal.CheckPermissionDelegate getCheckPermissionDelegateLocked() {
        return this.mCheckPermissionDelegate;
    }

    @GuardedBy({"mPackages"})
    public void setCheckPermissionDelegateLocked(PackageManagerInternal.CheckPermissionDelegate delegate) {
        this.mCheckPermissionDelegate = delegate;
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public void notifyPackageUseLocked(String packageName, int reason) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            p.mLastPackageUsageTimeInMills[reason] = System.currentTimeMillis();
        }
    }

    public void notifyDexLoad(String loadingPackageName, List<String> classLoaderNames, List<String> classPaths, String loaderIsa) {
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(loadingPackageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Loading a package that does not exist for the calling user. package=" + loadingPackageName + ", user=" + userId);
            return;
        }
        this.mDexManager.notifyDexLoad(ai, classLoaderNames, classPaths, loaderIsa, userId);
    }

    public void registerDexModule(String packageName, String dexModulePath, boolean isSharedModule, IDexModuleRegisterCallback callback) {
        DexManager.RegisterDexModuleResult result;
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(packageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Registering a dex module for a package that does not exist for the calling user. package=" + packageName + ", user=" + userId);
            result = new DexManager.RegisterDexModuleResult(false, "Package not installed");
        } else {
            result = this.mDexManager.registerDexModule(ai, dexModulePath, isSharedModule, userId);
        }
        if (callback != null) {
            this.mHandler.post(new Runnable(callback, dexModulePath, result) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$zyuddDJhFJp3TkyomSnR_V1OTpA */
                private final /* synthetic */ IDexModuleRegisterCallback f$0;
                private final /* synthetic */ String f$1;
                private final /* synthetic */ DexManager.RegisterDexModuleResult f$2;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void run() {
                    PackageManagerService.lambda$registerDexModule$4(this.f$0, this.f$1, this.f$2);
                }
            });
        }
    }

    static /* synthetic */ void lambda$registerDexModule$4(IDexModuleRegisterCallback callback, String dexModulePath, DexManager.RegisterDexModuleResult result) {
        try {
            callback.onDexModuleRegistered(dexModulePath, result.success, result.message);
        } catch (RemoteException e) {
            Slog.w(TAG, "Failed to callback after module registration " + dexModulePath, e);
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
        if (mHwPMSEx.isApkDexOpt(targetCompilerFilter)) {
            return mHwPMSEx.hwPerformDexOptMode(packageName, checkProfiles, targetCompilerFilter, force, bootComplete, splitName);
        }
        int i = 0;
        int i2 = (force ? 2 : 0) | checkProfiles;
        if (bootComplete) {
            i = 4;
        }
        return performDexOpt(new DexoptOptions(packageName, -1, targetCompilerFilter, splitName, i | i2));
    }

    public boolean performDexOptSecondary(String packageName, String compilerFilter, boolean force) {
        return performDexOpt(new DexoptOptions(packageName, compilerFilter, (force ? 2 : 0) | 13));
    }

    public boolean compileLayouts(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                return false;
            }
            return this.mViewCompiler.compileLayouts(pkg);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean performDexOpt(DexoptOptions options) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || isInstantApp(options.getPackageName(), UserHandle.getCallingUserId())) {
            return false;
        }
        if (options.isDexoptOnlySecondaryDex()) {
            return this.mDexManager.dexoptSecondaryDex(options);
        }
        if (performDexOptWithStatus(options) != -1) {
            return true;
        }
        return false;
    }

    /* access modifiers changed from: package-private */
    public int performDexOptWithStatus(DexoptOptions options) {
        return performDexOptTraced(options);
    }

    private int performDexOptTraced(DexoptOptions options) {
        Trace.traceBegin(262144, "dexopt");
        try {
            return performDexOptInternal(options);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private int performDexOptInternal(DexoptOptions options) {
        int performDexOptInternalWithDependenciesLI;
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(options.getPackageName());
            if (p == null) {
                return -1;
            }
            this.mPackageUsage.maybeWriteAsync(this.mPackages);
            this.mCompilerStats.maybeWriteAsync();
            long callingId = Binder.clearCallingIdentity();
            try {
                synchronized (this.mInstallLock) {
                    performDexOptInternalWithDependenciesLI = performDexOptInternalWithDependenciesLI(p, options);
                }
                return performDexOptInternalWithDependenciesLI;
            } finally {
                Binder.restoreCallingIdentity(callingId);
            }
        }
    }

    public ArraySet<String> getOptimizablePackages() {
        ArraySet<String> pkgs = new ArraySet<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p.packageName);
                }
            }
        }
        return pkgs;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:16:0x0063, code lost:
        if (r4 == null) goto L_0x0044;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0066, code lost:
        r1.performDexOpt(r4, r9, getOrCreateCompilerPackageStats(r4), r11.mDexManager.getPackageUseInfoOrDefault(r4.packageName), r2);
     */
    private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, DexoptOptions options) {
        PackageDexOptimizer.ForcedUpdatePackageDexOptimizer pdo;
        if (options.isForce()) {
            pdo = new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(this.mPackageDexOptimizer);
        } else {
            pdo = this.mPackageDexOptimizer;
        }
        Collection<SharedLibraryInfo> deps = findSharedLibraries(p);
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(p.applicationInfo);
        if (!deps.isEmpty()) {
            DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilationReason(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | 64);
            for (SharedLibraryInfo info : deps) {
                synchronized (this.mPackages) {
                    try {
                        PackageParser.Package depPackage = this.mPackages.get(info.getPackageName());
                        try {
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
            }
        }
        return pdo.performDexOpt(p, instructionSets, getOrCreateCompilerPackageStats(p), this.mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
    }

    public void reconcileSecondaryDexFiles(String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && !isInstantApp(packageName, UserHandle.getCallingUserId())) {
            this.mDexManager.reconcileSecondaryDexFiles(packageName);
        }
    }

    /* access modifiers changed from: package-private */
    public DexManager getDexManager() {
        return this.mDexManager;
    }

    public boolean runBackgroundDexoptJob(List<String> packageNames) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        enforceSystemOrRootOrShell("runBackgroundDexoptJob");
        long identity = Binder.clearCallingIdentity();
        try {
            return BackgroundDexOptService.runIdleOptimizationsNow(this, this.mContext, packageNames);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private static List<SharedLibraryInfo> findSharedLibraries(PackageParser.Package p) {
        if (p.usesLibraryInfos == null) {
            return Collections.emptyList();
        }
        ArrayList<SharedLibraryInfo> retValue = new ArrayList<>();
        Set<String> collectedNames = new HashSet<>();
        Iterator it = p.usesLibraryInfos.iterator();
        while (it.hasNext()) {
            findSharedLibrariesRecursive((SharedLibraryInfo) it.next(), retValue, collectedNames);
        }
        return retValue;
    }

    private static void findSharedLibrariesRecursive(SharedLibraryInfo info, ArrayList<SharedLibraryInfo> collected, Set<String> collectedNames) {
        if (!collectedNames.contains(info.getName())) {
            collectedNames.add(info.getName());
            collected.add(info);
            if (info.getDependencies() != null) {
                for (SharedLibraryInfo dep : info.getDependencies()) {
                    findSharedLibrariesRecursive(dep, collected, collectedNames);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> findSharedNonSystemLibraries(PackageParser.Package pkg) {
        List<SharedLibraryInfo> deps = findSharedLibraries(pkg);
        if (deps.isEmpty()) {
            return Collections.emptyList();
        }
        ArrayList<PackageParser.Package> retValue = new ArrayList<>();
        synchronized (this.mPackages) {
            for (SharedLibraryInfo info : deps) {
                PackageParser.Package depPackage = this.mPackages.get(info.getPackageName());
                if (depPackage != null) {
                    retValue.add(depPackage);
                }
            }
        }
        return retValue;
    }

    private SharedLibraryInfo getSharedLibraryInfoLPr(String name, long version) {
        return getSharedLibraryInfo(name, version, this.mSharedLibraries, null);
    }

    private static SharedLibraryInfo getSharedLibraryInfo(String name, long version, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) {
        if (newLibraries != null) {
            LongSparseArray<SharedLibraryInfo> versionedLib = newLibraries.get(name);
            SharedLibraryInfo info = null;
            if (versionedLib != null) {
                info = versionedLib.get(version);
            }
            if (info != null) {
                return info;
            }
        }
        LongSparseArray<SharedLibraryInfo> versionedLib2 = existingLibraries.get(name);
        if (versionedLib2 == null) {
            return null;
        }
        return versionedLib2.get(version);
    }

    private SharedLibraryInfo getLatestSharedLibraVersionLPr(PackageParser.Package pkg) {
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(pkg.staticSharedLibName);
        if (versionedLib == null) {
            return null;
        }
        long previousLibVersion = -1;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            long libVersion = versionedLib.keyAt(i);
            if (libVersion < pkg.staticSharedLibVersion) {
                previousLibVersion = Math.max(previousLibVersion, libVersion);
            }
        }
        if (previousLibVersion >= 0) {
            return versionedLib.get(previousLibVersion);
        }
        return null;
    }

    private PackageSetting getSharedLibLatestVersionSetting(ScanResult scanResult) {
        PackageSetting sharedLibPackage = null;
        synchronized (this.mPackages) {
            SharedLibraryInfo latestSharedLibraVersionLPr = getLatestSharedLibraVersionLPr(scanResult.pkgSetting.pkg);
            if (latestSharedLibraVersionLPr != null) {
                sharedLibPackage = this.mSettings.getPackageLPr(latestSharedLibraVersionLPr.getPackageName());
            }
        }
        return sharedLibPackage;
    }

    public void shutdown() {
        this.mPackageUsage.writeNow(this.mPackages);
        this.mCompilerStats.writeNow();
        this.mDexManager.writePackageDexUsageNow();
        PackageWatchdog.getInstance(this.mContext).writeNow();
        synchronized (this.mPackages) {
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
                Iterator<Integer> it = this.mDirtyUsers.iterator();
                while (it.hasNext()) {
                    this.mSettings.writePackageRestrictionsLPr(it.next().intValue());
                }
                this.mDirtyUsers.clear();
            }
        }
    }

    public void dumpProfiles(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        int callingUid = Binder.getCallingUid();
        if (callingUid == 2000 || callingUid == 0 || callingUid == pkg.applicationInfo.uid) {
            synchronized (this.mInstallLock) {
                Trace.traceBegin(262144, "dump profiles");
                this.mArtManagerService.dumpProfiles(pkg);
                Trace.traceEnd(262144);
            }
            return;
        }
        throw new SecurityException("dumpProfiles");
    }

    public void forceDexOpt(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("forceDexOpt");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        synchronized (this.mInstallLock) {
            Trace.traceBegin(262144, "dexopt");
            int res = performDexOptInternalWithDependenciesLI(pkg, new DexoptOptions(packageName, PackageManagerServiceCompilerMapping.getDefaultCompilerFilter(), 6));
            Trace.traceEnd(262144);
            if (res != 1) {
                throw new IllegalStateException("Failed to dexopt: " + res);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, PackageParser.Package newPkg) {
        if ((oldPkg.pkgFlags & 1) == 0) {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package not in system partition");
            return false;
        } else if (this.mPackages.get(oldPkg.name) == null) {
            return true;
        } else {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package still exists");
            return false;
        }
    }

    /* access modifiers changed from: package-private */
    @GuardedBy({"mInstallLock"})
    public void removeCodePathLI(File codePath) {
        if (codePath.isDirectory()) {
            try {
                this.mInstaller.rmPackageDir(codePath.getAbsolutePath());
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, "Failed to remove code path", e);
            }
        } else {
            codePath.delete();
        }
    }

    private int[] resolveUserIds(int userId) {
        if (userId == -1) {
            return sUserManager.getUserIds();
        }
        return new int[]{userId};
    }

    private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            clearAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
        clearAppProfilesLIF(pkg, -1);
    }

    private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        int[] resolveUserIds = resolveUserIds(userId);
        for (int realUserId : resolveUserIds) {
            try {
                this.mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
    }

    private void destroyAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void destroyAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        int[] resolveUserIds = resolveUserIds(userId);
        for (int realUserId : resolveUserIds) {
            try {
                this.mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
            this.mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);
        }
    }

    private void destroyAppProfilesLIF(PackageParser.Package pkg) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppProfilesLeafLIF(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppProfilesLeafLIF((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void destroyAppProfilesLeafLIF(PackageParser.Package pkg) {
        try {
            this.mInstaller.destroyAppProfiles(pkg.packageName);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        this.mArtManagerService.clearAppProfiles(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mArtManagerService.clearAppProfiles((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void setInstallAndUpdateTime(PackageParser.Package pkg, long firstInstallTime, long lastUpdateTime) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            ps.firstInstallTime = firstInstallTime;
            ps.lastUpdateTime = lastUpdateTime;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                ps2.firstInstallTime = firstInstallTime;
                ps2.lastUpdateTime = lastUpdateTime;
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void applyDefiningSharedLibraryUpdateLocked(PackageParser.Package pkg, SharedLibraryInfo libInfo, BiConsumer<SharedLibraryInfo, SharedLibraryInfo> action) {
        if (!pkg.isLibrary()) {
            return;
        }
        if (pkg.staticSharedLibName != null) {
            SharedLibraryInfo definedLibrary = getSharedLibraryInfoLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
            if (definedLibrary != null) {
                action.accept(definedLibrary, libInfo);
                return;
            }
            return;
        }
        Iterator it = pkg.libraryNames.iterator();
        while (it.hasNext()) {
            SharedLibraryInfo definedLibrary2 = getSharedLibraryInfoLPr((String) it.next(), -1);
            if (definedLibrary2 != null) {
                action.accept(definedLibrary2, libInfo);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void addSharedLibraryLPr(PackageParser.Package pkg, Set<String> usesLibraryFiles, SharedLibraryInfo libInfo, PackageParser.Package changingLib) {
        if (libInfo.getPath() != null) {
            usesLibraryFiles.add(libInfo.getPath());
            return;
        }
        PackageParser.Package p = this.mPackages.get(libInfo.getPackageName());
        if (changingLib != null && changingLib.packageName.equals(libInfo.getPackageName()) && (p == null || p.packageName.equals(changingLib.packageName))) {
            p = changingLib;
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
            applyDefiningSharedLibraryUpdateLocked(pkg, libInfo, $$Lambda$PackageManagerService$tQg409Z6Ctp5FPOVwhjUsdZLWA.INSTANCE);
            if (p.usesLibraryFiles != null) {
                Collections.addAll(usesLibraryFiles, p.usesLibraryFiles);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void updateSharedLibrariesLocked(PackageParser.Package pkg, PackageParser.Package changingLib, Map<String, PackageParser.Package> availablePackages) throws PackageManagerException {
        executeSharedLibrariesUpdateLPr(pkg, changingLib, collectSharedLibraryInfos(pkg, availablePackages, this.mSharedLibraries, null));
    }

    private static ArrayList<SharedLibraryInfo> collectSharedLibraryInfos(PackageParser.Package pkg, Map<String, PackageParser.Package> availablePackages, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) throws PackageManagerException {
        if (pkg == null) {
            return null;
        }
        ArrayList<SharedLibraryInfo> usesLibraryInfos = null;
        if (pkg.usesLibraries != null) {
            usesLibraryInfos = collectSharedLibraryInfos(pkg.usesLibraries, null, null, pkg.packageName, true, pkg.applicationInfo.targetSdkVersion, null, availablePackages, existingLibraries, newLibraries);
        }
        if (pkg.usesStaticLibraries != null) {
            usesLibraryInfos = collectSharedLibraryInfos(pkg.usesStaticLibraries, pkg.usesStaticLibrariesVersions, pkg.usesStaticLibrariesCertDigests, pkg.packageName, true, pkg.applicationInfo.targetSdkVersion, usesLibraryInfos, availablePackages, existingLibraries, newLibraries);
        }
        if (pkg.usesOptionalLibraries != null) {
            return collectSharedLibraryInfos(pkg.usesOptionalLibraries, null, null, pkg.packageName, false, pkg.applicationInfo.targetSdkVersion, usesLibraryInfos, availablePackages, existingLibraries, newLibraries);
        }
        return usesLibraryInfos;
    }

    private void executeSharedLibrariesUpdateLPr(PackageParser.Package pkg, PackageParser.Package changingLib, ArrayList<SharedLibraryInfo> usesLibraryInfos) {
        applyDefiningSharedLibraryUpdateLocked(pkg, null, $$Lambda$PackageManagerService$GRQMseHE8dORyaqj3rZBaYJdvk.INSTANCE);
        if (usesLibraryInfos != null) {
            pkg.usesLibraryInfos = usesLibraryInfos;
            Set<String> usesLibraryFiles = new LinkedHashSet<>();
            Iterator<SharedLibraryInfo> it = usesLibraryInfos.iterator();
            while (it.hasNext()) {
                addSharedLibraryLPr(pkg, usesLibraryFiles, it.next(), changingLib);
            }
            pkg.usesLibraryFiles = (String[]) usesLibraryFiles.toArray(new String[usesLibraryFiles.size()]);
            return;
        }
        pkg.usesLibraryInfos = null;
        pkg.usesLibraryFiles = null;
    }

    @GuardedBy({"mPackages"})
    private static ArrayList<SharedLibraryInfo> collectSharedLibraryInfos(List<String> requestedLibraries, long[] requiredVersions, String[][] requiredCertDigests, String packageName, boolean required, int targetSdk, ArrayList<SharedLibraryInfo> outUsedLibraries, Map<String, PackageParser.Package> availablePackages, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) throws PackageManagerException {
        long libVersion;
        int libCount;
        String[] strArr;
        int libCount2 = requestedLibraries.size();
        int i = 0;
        ArrayList<SharedLibraryInfo> outUsedLibraries2 = outUsedLibraries;
        while (i < libCount2) {
            String libName = requestedLibraries.get(i);
            if (requiredVersions != null) {
                libVersion = requiredVersions[i];
            } else {
                libVersion = -1;
            }
            SharedLibraryInfo libraryInfo = getSharedLibraryInfo(libName, libVersion, existingLibraries, newLibraries);
            if (libraryInfo != null) {
                if (requiredVersions == null || requiredCertDigests == null) {
                    libCount = libCount2;
                } else if (libraryInfo.getLongVersion() == requiredVersions[i]) {
                    PackageParser.Package libPkg = availablePackages.get(libraryInfo.getPackageName());
                    if (libPkg != null) {
                        String[] expectedCertDigests = requiredCertDigests[i];
                        libCount = libCount2;
                        if (expectedCertDigests.length > 1) {
                            if (targetSdk >= 27) {
                                strArr = PackageUtils.computeSignaturesSha256Digests(libPkg.mSigningDetails.signatures);
                            } else {
                                strArr = PackageUtils.computeSignaturesSha256Digests(new Signature[]{libPkg.mSigningDetails.signatures[0]});
                            }
                            String[] libCertDigests = strArr;
                            if (expectedCertDigests.length == libCertDigests.length) {
                                Arrays.sort(libCertDigests);
                                Arrays.sort(expectedCertDigests);
                                int certCount = libCertDigests.length;
                                int j = 0;
                                while (j < certCount) {
                                    if (libCertDigests[j].equalsIgnoreCase(expectedCertDigests[j])) {
                                        j++;
                                        libCertDigests = libCertDigests;
                                    } else {
                                        throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                                    }
                                }
                            } else {
                                throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                            }
                        } else if (!libPkg.mSigningDetails.hasSha256Certificate(ByteStringUtils.fromHexToByteArray(expectedCertDigests[0]))) {
                            throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                        }
                    } else {
                        throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared library; failing!");
                    }
                } else {
                    throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared library " + libName + " version " + libraryInfo.getLongVersion() + "; failing!");
                }
                if (outUsedLibraries2 == null) {
                    outUsedLibraries2 = new ArrayList<>();
                }
                outUsedLibraries2.add(libraryInfo);
            } else if (!required) {
                if (DEBUG_SHARED_LIBRARIES) {
                    Slog.i(TAG, "Package " + packageName + " desires unavailable shared library " + libName + "; ignoring!");
                }
                libCount = libCount2;
            } else {
                throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable shared library " + libName + "; failing!");
            }
            i++;
            libCount2 = libCount;
        }
        return outUsedLibraries2;
    }

    private static boolean hasString(List<String> list, List<String> which) {
        if (list == null || which == null) {
            return false;
        }
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = which.size() - 1; j >= 0; j--) {
                if (which.get(j).equals(list.get(i))) {
                    return true;
                }
            }
        }
        return false;
    }

    /* access modifiers changed from: protected */
    @GuardedBy({"mPackages"})
    public ArrayList<PackageParser.Package> updateAllSharedLibrariesLocked(PackageParser.Package updatedPkg, Map<String, PackageParser.Package> availablePackages) {
        ArrayList<PackageParser.Package> needsUpdating;
        int i;
        ArrayList<PackageParser.Package> resultList;
        ArraySet<String> descendants;
        ArrayList<PackageParser.Package> resultList2;
        ArrayList<PackageParser.Package> resultList3 = null;
        ArraySet<String> descendants2 = null;
        if (updatedPkg != null) {
            ArrayList<PackageParser.Package> needsUpdating2 = new ArrayList<>(1);
            needsUpdating2.add(updatedPkg);
            needsUpdating = needsUpdating2;
        } else {
            needsUpdating = null;
        }
        do {
            PackageParser.Package changingPkg = needsUpdating == null ? null : needsUpdating.remove(0);
            int i2 = this.mPackages.size() - 1;
            while (i2 >= 0) {
                PackageParser.Package pkg = this.mPackages.valueAt(i2);
                if (changingPkg == null || hasString(pkg.usesLibraries, changingPkg.libraryNames) || hasString(pkg.usesOptionalLibraries, changingPkg.libraryNames) || ArrayUtils.contains(pkg.usesStaticLibraries, changingPkg.staticSharedLibName)) {
                    if (resultList3 == null) {
                        resultList = new ArrayList<>();
                    } else {
                        resultList = resultList3;
                    }
                    if (changingPkg != null && !"com.huawei.androidx".equals(changingPkg.manifestPackageName)) {
                        resultList.add(pkg);
                    }
                    if (changingPkg != null) {
                        if (descendants2 == null) {
                            descendants2 = new ArraySet<>();
                        }
                        if (!descendants2.contains(pkg.packageName)) {
                            descendants2.add(pkg.packageName);
                            needsUpdating.add(pkg);
                        }
                        descendants = descendants2;
                    } else {
                        descendants = descendants2;
                    }
                    try {
                        updateSharedLibrariesLocked(pkg, changingPkg, availablePackages);
                        resultList2 = resultList;
                        i = i2;
                    } catch (PackageManagerException e) {
                        if (!pkg.isSystem() || pkg.isUpdatedSystemApp()) {
                            resultList2 = resultList;
                            i = i2;
                            deletePackageLIF(pkg.packageName, null, true, sUserManager.getUserIds(), pkg.isUpdatedSystemApp() ? 1 : 0, null, true, null);
                        } else {
                            resultList2 = resultList;
                            i = i2;
                        }
                        Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
                    }
                    descendants2 = descendants;
                    resultList3 = resultList2;
                } else {
                    i = i2;
                }
                i2 = i - 1;
            }
            if (needsUpdating == null) {
                break;
            }
        } while (needsUpdating.size() > 0);
        return resultList3;
    }

    /* JADX INFO: finally extract failed */
    @GuardedBy({"mInstallLock", "mPackages"})
    private List<ScanResult> scanPackageTracedLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        int scanFlags2;
        Trace.traceBegin(262144, "scanPackage");
        if ((scanFlags & 1024) != 0) {
            scanFlags2 = scanFlags & -1025;
        } else if (pkg.childPackages == null || pkg.childPackages.size() <= 0) {
            scanFlags2 = scanFlags;
        } else {
            scanFlags2 = scanFlags | 1024;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        List<ScanResult> scanResults = new ArrayList<>(childCount + 1);
        try {
            scanResults.add(scanPackageNewLI(pkg, parseFlags, scanFlags2, currentTime, user));
            for (int i = 0; i < childCount; i++) {
                scanResults.add(scanPackageNewLI((PackageParser.Package) pkg.childPackages.get(i), parseFlags, scanFlags2, currentTime, user));
            }
            Trace.traceEnd(262144);
            if ((scanFlags2 & 1024) != 0) {
                return scanPackageTracedLI(pkg, parseFlags, scanFlags2, currentTime, user);
            }
            return scanResults;
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    private static class ScanResult {
        public final List<String> changedAbiCodePath;
        public final List<SharedLibraryInfo> dynamicSharedLibraryInfos;
        public final boolean existingSettingCopied;
        public final PackageSetting pkgSetting;
        public final ScanRequest request;
        public final SharedLibraryInfo staticSharedLibraryInfo;
        public final boolean success;

        public ScanResult(ScanRequest request2, boolean success2, PackageSetting pkgSetting2, List<String> changedAbiCodePath2, boolean existingSettingCopied2, SharedLibraryInfo staticSharedLibraryInfo2, List<SharedLibraryInfo> dynamicSharedLibraryInfos2) {
            this.request = request2;
            this.success = success2;
            this.pkgSetting = pkgSetting2;
            this.changedAbiCodePath = changedAbiCodePath2;
            this.existingSettingCopied = existingSettingCopied2;
            this.staticSharedLibraryInfo = staticSharedLibraryInfo2;
            this.dynamicSharedLibraryInfos = dynamicSharedLibraryInfos2;
        }
    }

    private static class ScanRequest {
        public final PackageSetting disabledPkgSetting;
        public final boolean isPlatformPackage;
        public final PackageParser.Package oldPkg;
        public final PackageSetting oldPkgSetting;
        public final PackageSetting originalPkgSetting;
        public final int parseFlags;
        public final PackageParser.Package pkg;
        public final PackageSetting pkgSetting;
        public final String realPkgName;
        public final int scanFlags;
        public final SharedUserSetting sharedUserSetting;
        public final UserHandle user;

        public ScanRequest(PackageParser.Package pkg2, SharedUserSetting sharedUserSetting2, PackageParser.Package oldPkg2, PackageSetting pkgSetting2, PackageSetting disabledPkgSetting2, PackageSetting originalPkgSetting2, String realPkgName2, int parseFlags2, int scanFlags2, boolean isPlatformPackage2, UserHandle user2) {
            this.pkg = pkg2;
            this.oldPkg = oldPkg2;
            this.pkgSetting = pkgSetting2;
            this.sharedUserSetting = sharedUserSetting2;
            this.oldPkgSetting = pkgSetting2 == null ? null : new PackageSetting(pkgSetting2);
            this.disabledPkgSetting = disabledPkgSetting2;
            this.originalPkgSetting = originalPkgSetting2;
            this.realPkgName = realPkgName2;
            this.parseFlags = parseFlags2;
            this.scanFlags = scanFlags2;
            this.isPlatformPackage = isPlatformPackage2;
            this.user = user2;
        }
    }

    private int adjustScanFlags(int scanFlags, PackageSetting pkgSetting, PackageSetting disabledPkgSetting, UserHandle user, PackageParser.Package pkg) {
        PackageSetting systemPkgSetting;
        if ((scanFlags & 4) == 0 || disabledPkgSetting != null || pkgSetting == null || !pkgSetting.isSystem()) {
            systemPkgSetting = disabledPkgSetting;
        } else {
            systemPkgSetting = pkgSetting;
        }
        if (systemPkgSetting != null) {
            scanFlags |= 131072;
            if ((systemPkgSetting.pkgPrivateFlags & 8) != 0) {
                scanFlags |= 262144;
            }
            if ((131072 & systemPkgSetting.pkgPrivateFlags) != 0) {
                scanFlags |= 524288;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 262144) != 0) {
                scanFlags |= 1048576;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 524288) != 0) {
                scanFlags |= 2097152;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 2097152) != 0) {
                scanFlags |= 4194304;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 1073741824) != 0) {
                scanFlags |= 8388608;
            }
        }
        if (pkgSetting != null) {
            int userId = user == null ? 0 : user.getIdentifier();
            if (pkgSetting.getInstantApp(userId)) {
                scanFlags |= 16384;
            }
            if (pkgSetting.getVirtulalPreload(userId)) {
                scanFlags |= 65536;
            }
        }
        boolean skipVendorPrivilegeScan = (1048576 & scanFlags) != 0 && SystemProperties.getInt("ro.vndk.version", 28) < 28;
        if ((scanFlags & 262144) == 0 && !pkg.isPrivileged() && pkg.mSharedUserId != null && !skipVendorPrivilegeScan) {
            SharedUserSetting sharedUserSetting = null;
            try {
                sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
            } catch (PackageManagerException e) {
            }
            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                synchronized (this.mPackages) {
                    if (PackageManagerServiceUtils.compareSignatures(this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME).signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) != 0) {
                        scanFlags |= 262144;
                    }
                }
            }
        }
        return scanFlags;
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private ScanResult scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageNewLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private ScanResult scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        int scanFlags2;
        SharedUserSetting sharedUserSetting;
        String renamedPkgName = this.mSettings.getRenamedPackageLPr(pkg.mRealPackage);
        String realPkgName = getRealPackageName(pkg, renamedPkgName);
        if (realPkgName != null) {
            ensurePackageRenamed(pkg, renamedPkgName);
        }
        PackageSetting originalPkgSetting = getOriginalPackageLocked(pkg, renamedPkgName);
        PackageSetting pkgSetting = this.mSettings.getPackageLPr(pkg.packageName);
        PackageSetting disabledPkgSetting = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
        if (this.mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        int scanFlags3 = adjustScanFlags(scanFlags, pkgSetting, disabledPkgSetting, user, pkg);
        mHwPMSEx.resolvePersistentFlagForPackage(disabledPkgSetting != null ? disabledPkgSetting.pkgFlags : Integer.MIN_VALUE, pkg);
        if (isSystemAppGrantByMdmAndNonPreload(pkg)) {
            scanFlags2 = mHwPMSEx.adjustScanFlagForApk(pkg, scanFlags3);
        } else {
            scanFlags2 = scanFlags3;
        }
        synchronized (this.mPackages) {
            try {
                try {
                    applyPolicy(pkg, parseFlags, scanFlags2, this.mPlatformPackage, hwFlags);
                    String type = HwMaplePMServiceUtils.getMapleAppType(pkg);
                    int hwFlagTemp = hwFlags;
                    if (type != null) {
                        try {
                            if (type.equals("m")) {
                                hwFlagTemp |= DumpState.DUMP_SERVICE_PERMISSIONS;
                                ApplicationInfo applicationInfo = pkg.applicationInfo;
                                applicationInfo.hwFlags = 16777216 | applicationInfo.hwFlags;
                            } else if (type.equals("mo")) {
                                hwFlagTemp |= 20971520;
                                ApplicationInfo applicationInfo2 = pkg.applicationInfo;
                                applicationInfo2.hwFlags = 20971520 | applicationInfo2.hwFlags;
                            } else if (type.equals("z")) {
                                hwFlagTemp |= 8388608;
                                ApplicationInfo applicationInfo3 = pkg.applicationInfo;
                                applicationInfo3.hwFlags = 8388608 | applicationInfo3.hwFlags;
                            }
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    }
                    if (HwMaplePMServiceUtils.getDependWebView(pkg)) {
                        hwFlagTemp |= 2097152;
                        ApplicationInfo applicationInfo4 = pkg.applicationInfo;
                        applicationInfo4.hwFlags = 2097152 | applicationInfo4.hwFlags;
                    }
                    if ("com.huawei.webview".equals(pkg.packageName)) {
                        HwMaplePMServiceUtils.setWebViewInfoFlags(hwFlagTemp);
                    }
                    if (HwMaplePMServiceUtils.isMaplePkgGcOnly(pkg)) {
                        hwFlagTemp |= 524288;
                        ApplicationInfo applicationInfo5 = pkg.applicationInfo;
                        applicationInfo5.hwFlags = 524288 | applicationInfo5.hwFlags;
                    }
                    assertPackageIsValid(pkg, parseFlags, scanFlags2);
                    if (pkg.mSharedUserId != null) {
                        sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
                        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags) != 0) {
                            Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + sharedUserSetting.userId + "): packages=" + sharedUserSetting.packages);
                        }
                    } else {
                        sharedUserSetting = null;
                    }
                    if (isSystemApp(pkg) || !HwDeviceManager.disallowOp(19, pkg.packageName)) {
                        PackageParser.Package r8 = pkgSetting == null ? null : pkgSetting.pkg;
                        boolean z = pkg == this.mPlatformPackage;
                        try {
                            return scanPackageOnlyLI(new ScanRequest(pkg, sharedUserSetting, r8, pkgSetting, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags2, z, user), this.mFactoryTest, currentTime, hwFlagTemp);
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } else {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "app is in the installpackage_blacklist");
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            } catch (Throwable th4) {
                th = th4;
                throw th;
            }
        }
    }

    private boolean optimisticallyRegisterAppId(ScanResult result) throws PackageManagerException {
        if (!result.existingSettingCopied) {
            return this.mSettings.registerAppIdLPw(result.pkgSetting);
        }
        return false;
    }

    private void cleanUpAppIdCreation(ScanResult result) {
        if (result.pkgSetting.appId > 0) {
            this.mSettings.removeAppIdLPw(result.pkgSetting.appId);
        }
    }

    @GuardedBy({"mPackages", "mInstallLock"})
    private void commitReconciledScanResultLocked(ReconciledPackage reconciledPkg) {
        PackageSetting pkgSetting;
        String realPkgName;
        PackageSetting pkgSetting2;
        String realPkgName2;
        PackageSetting pkgSetting3;
        ScanResult result = reconciledPkg.scanResult;
        ScanRequest request = result.request;
        PackageParser.Package pkg = request.pkg;
        PackageParser.Package oldPkg = request.oldPkg;
        int parseFlags = request.parseFlags;
        int scanFlags = request.scanFlags;
        PackageSetting oldPkgSetting = request.oldPkgSetting;
        PackageSetting originalPkgSetting = request.originalPkgSetting;
        UserHandle user = request.user;
        String realPkgName3 = request.realPkgName;
        List<String> changedAbiCodePath = result.changedAbiCodePath;
        if (!(request.pkgSetting == null || request.pkgSetting.sharedUser == null || request.pkgSetting.sharedUser == result.pkgSetting.sharedUser)) {
            request.pkgSetting.sharedUser.removePackage(request.pkgSetting);
        }
        if (result.existingSettingCopied) {
            PackageSetting pkgSetting4 = request.pkgSetting;
            pkgSetting4.updateFrom(result.pkgSetting);
            pkg.mExtras = pkgSetting4;
            pkgSetting = pkgSetting4;
        } else {
            PackageSetting pkgSetting5 = result.pkgSetting;
            if (originalPkgSetting != null) {
                pkgSetting3 = pkgSetting5;
                this.mSettings.addRenamedPackageLPw(pkg.packageName, originalPkgSetting.name);
            } else {
                pkgSetting3 = pkgSetting5;
            }
            if (originalPkgSetting != null && (scanFlags & 1024) == 0) {
                this.mTransferedPackages.add(originalPkgSetting.name);
            }
            pkgSetting = pkgSetting3;
        }
        if (pkgSetting.sharedUser != null) {
            pkgSetting.sharedUser.addPackage(pkgSetting);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        this.mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);
        if ((scanFlags & 1024) == 0 && realPkgName3 != null) {
            this.mTransferedPackages.add(pkg.packageName);
        }
        if (reconciledPkg.collectedSharedLibraryInfos != null) {
            executeSharedLibrariesUpdateLPr(pkg, null, reconciledPkg.collectedSharedLibraryInfos);
        }
        KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
        if (reconciledPkg.removeAppKeySetData) {
            ksms.removeAppKeySetDataLPw(pkg.packageName);
        }
        if (reconciledPkg.sharedUserSignaturesChanged) {
            pkgSetting.sharedUser.signaturesChanged = Boolean.TRUE;
            pkgSetting.sharedUser.signatures.mSigningDetails = reconciledPkg.signingDetails;
        }
        pkgSetting.signatures.mSigningDetails = reconciledPkg.signingDetails;
        if ((scanFlags & 1024) != 0 || pkg.mAdoptPermissions == null) {
            pkgSetting2 = pkgSetting;
            realPkgName = realPkgName3;
        } else {
            int i = pkg.mAdoptPermissions.size() - 1;
            while (i >= 0) {
                String origName = (String) pkg.mAdoptPermissions.get(i);
                PackageSetting orig = this.mSettings.getPackageLPr(origName);
                if (orig == null) {
                    realPkgName2 = realPkgName3;
                } else if (verifyPackageUpdateLPr(orig, pkg)) {
                    StringBuilder sb = new StringBuilder();
                    realPkgName2 = realPkgName3;
                    sb.append("Adopting permissions from ");
                    sb.append(origName);
                    sb.append(" to ");
                    sb.append(pkg.packageName);
                    Slog.i(TAG, sb.toString());
                    this.mSettings.mPermissions.transferPermissions(origName, pkg.packageName);
                } else {
                    realPkgName2 = realPkgName3;
                }
                i--;
                pkgSetting = pkgSetting;
                realPkgName3 = realPkgName2;
            }
            pkgSetting2 = pkgSetting;
            realPkgName = realPkgName3;
        }
        if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
            for (int i2 = changedAbiCodePath.size() - 1; i2 >= 0; i2--) {
                try {
                    this.mInstaller.rmdex(changedAbiCodePath.get(i2), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                } catch (Installer.InstallerException e) {
                }
            }
        }
        if ((scanFlags & 1024) == 0) {
            boolean z = false;
            int userId = user == null ? 0 : user.getIdentifier();
            if ((Integer.MIN_VALUE & parseFlags) != 0) {
                z = true;
            }
            commitPackageSettings(pkg, oldPkg, pkgSetting2, scanFlags, z, reconciledPkg);
            if (pkgSetting2.getInstantApp(userId)) {
                this.mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting2.appId);
            }
        } else if (oldPkgSetting != null) {
            synchronized (this.mPackages) {
                this.mSettings.mPackages.put(oldPkgSetting.name, oldPkgSetting);
            }
        }
    }

    private static String getRealPackageName(PackageParser.Package pkg, String renamedPkgName) {
        if (isPackageRenamed(pkg, renamedPkgName)) {
            return pkg.mRealPackage;
        }
        return null;
    }

    private static boolean isPackageRenamed(PackageParser.Package pkg, String renamedPkgName) {
        return pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPkgName);
    }

    @GuardedBy({"mPackages"})
    private PackageSetting getOriginalPackageLocked(PackageParser.Package pkg, String renamedPkgName) {
        if (!isPackageRenamed(pkg, renamedPkgName)) {
            return null;
        }
        for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
            PackageSetting originalPs = this.mSettings.getPackageLPr((String) pkg.mOriginalPackages.get(i));
            if (originalPs != null && verifyPackageUpdateLPr(originalPs, pkg)) {
                if (originalPs.sharedUser != null) {
                    if (!originalPs.sharedUser.name.equals(pkg.mSharedUserId)) {
                        Slog.w(TAG, "Unable to migrate data from " + originalPs.name + " to " + pkg.packageName + ": old uid " + originalPs.sharedUser.name + " differs from " + pkg.mSharedUserId);
                    }
                } else if (DEBUG_UPGRADE) {
                    Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + originalPs.name);
                }
                return originalPs;
            }
        }
        return null;
    }

    private static void ensurePackageRenamed(PackageParser.Package pkg, String renamedPackageName) {
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPackageName) && !pkg.packageName.equals(renamedPackageName)) {
            pkg.setPackageName(renamedPackageName);
        }
    }

    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime) throws PackageManagerException {
        return scanPackageOnlyLI(request, isUnderFactoryTest, currentTime, 0);
    }

    @GuardedBy({"mInstallLock"})
    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime, int hwFlags) throws PackageManagerException {
        String secondaryCpuAbiFromSettings;
        String primaryCpuAbiFromSettings;
        boolean isPlatformPackage;
        String str;
        String secondaryCpuAbiFromSettings2;
        String str2;
        String primaryCpuAbiFromSettings2;
        PackageSetting pkgSetting;
        UserHandle user;
        String secondaryCpuAbiFromSettings3;
        boolean z;
        String cpuAbiOverride;
        PackageSetting originalPkgSetting;
        SharedLibraryInfo staticSharedLibraryInfo;
        List<SharedLibraryInfo> dynamicSharedLibraryInfos;
        String str3;
        String primaryCpuAbiFromSettings3;
        String primaryCpuAbiFromSettings4;
        String secondaryCpuAbiFromSettings4;
        String str4;
        String str5;
        PackageParser.Package pkg = request.pkg;
        PackageSetting pkgSetting2 = request.pkgSetting;
        PackageSetting disabledPkgSetting = request.disabledPkgSetting;
        PackageSetting originalPkgSetting2 = request.originalPkgSetting;
        int parseFlags = request.parseFlags;
        int scanFlags = request.scanFlags;
        String realPkgName = request.realPkgName;
        SharedUserSetting sharedUserSetting = request.sharedUserSetting;
        UserHandle user2 = request.user;
        boolean isPlatformPackage2 = request.isPlatformPackage;
        List<String> changedAbiCodePath = null;
        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags) != 0) {
            Log.d(TAG, "Scanning package " + pkg.packageName);
        }
        new File(pkg.codePath);
        File destCodeFile = new File(pkg.applicationInfo.getCodePath());
        File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
        boolean needToDeriveAbi = (scanFlags & 8192) != 0;
        if (needToDeriveAbi) {
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = null;
        } else if (pkgSetting2 != null) {
            secondaryCpuAbiFromSettings = pkgSetting2.primaryCpuAbiString;
            primaryCpuAbiFromSettings = pkgSetting2.secondaryCpuAbiString;
        } else {
            needToDeriveAbi = true;
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = null;
        }
        if (!(pkgSetting2 == null || pkgSetting2.sharedUser == sharedUserSetting)) {
            StringBuilder sb = new StringBuilder();
            sb.append("Package ");
            sb.append(pkg.packageName);
            sb.append(" shared user changed from ");
            if (pkgSetting2.sharedUser != null) {
                str4 = pkgSetting2.sharedUser.name;
            } else {
                str4 = "<nothing>";
            }
            sb.append(str4);
            sb.append(" to ");
            if (sharedUserSetting != null) {
                str5 = sharedUserSetting.name;
            } else {
                str5 = "<nothing>";
            }
            sb.append(str5);
            sb.append("; replacing with new");
            reportSettingsProblem(5, sb.toString());
            pkgSetting2 = null;
        }
        String[] usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
            pkg.usesStaticLibraries.toArray(usesStaticLibraries);
        }
        boolean createNewPackage = pkgSetting2 == null;
        if (createNewPackage) {
            String parentPackageName = pkg.parentPackage != null ? pkg.parentPackage.packageName : null;
            boolean instantApp = (scanFlags & 16384) != 0;
            boolean virtualPreload = (65536 & scanFlags) != 0;
            String str6 = pkg.packageName;
            str2 = " to ";
            String str7 = pkg.applicationInfo.nativeLibraryRootDir;
            String str8 = pkg.applicationInfo.primaryCpuAbi;
            String str9 = pkg.applicationInfo.secondaryCpuAbi;
            long j = (long) pkg.mVersionCode;
            int i = pkg.applicationInfo.flags;
            int i2 = pkg.applicationInfo.privateFlags;
            List childPackageNames = pkg.getChildPackageNames();
            UserManagerService instance = UserManagerService.getInstance();
            long[] jArr = pkg.usesStaticLibrariesVersions;
            secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            str = TAG;
            isPlatformPackage = isPlatformPackage2;
            pkgSetting = Settings.createNewSetting(str6, originalPkgSetting2, disabledPkgSetting, realPkgName, sharedUserSetting, destCodeFile, destResourceFile, str7, str8, str9, j, i, i2, user2, true, instantApp, virtualPreload, parentPackageName, childPackageNames, instance, usesStaticLibraries, jArr);
            primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
        } else {
            str2 = " to ";
            secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            str = TAG;
            isPlatformPackage = isPlatformPackage2;
            PackageSetting pkgSetting3 = new PackageSetting(pkgSetting2);
            pkgSetting3.pkg = pkg;
            primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
            Settings.updatePackageSetting(pkgSetting3, disabledPkgSetting, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
            pkgSetting = pkgSetting3;
        }
        pkgSetting.hw_extra_flags = pkg.applicationInfo.hw_extra_flags;
        if (createNewPackage && originalPkgSetting2 != null) {
            pkg.setPackageName(originalPkgSetting2.name);
            reportSettingsProblem(5, "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name);
        }
        int userId = user2 == null ? 0 : user2.getIdentifier();
        if (!createNewPackage) {
            setInstantAppForUser(pkgSetting, userId, (scanFlags & 16384) != 0, (32768 & scanFlags) != 0);
        }
        if (disabledPkgSetting != null || ((scanFlags & 4) != 0 && pkgSetting.isSystem() && !isSystemAppGrantByMdmAndNonPreload(pkg))) {
            pkg.applicationInfo.flags |= 128;
            HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
        }
        pkg.applicationInfo.seInfo = SELinuxMMAC.getSeInfo(pkg, sharedUserSetting != null ? sharedUserSetting.isPrivileged() | pkg.isPrivileged() : pkg.isPrivileged(), pkg.applicationInfo.targetSandboxVersion, (sharedUserSetting == null || sharedUserSetting.packages.size() == 0) ? pkg.applicationInfo.targetSdkVersion : sharedUserSetting.seInfoTargetSdkVersion);
        pkg.applicationInfo.seInfoUser = SELinuxUtil.assignSeinfoUser(pkgSetting.readUserState(userId == -1 ? 0 : userId));
        pkg.mExtras = pkgSetting;
        pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
        if (!isPlatformPackage) {
            pkg.applicationInfo.initForUser(0);
        }
        String cpuAbiOverride2 = PackageManagerServiceUtils.deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
        if ((scanFlags & 4) != 0) {
            user = user2;
            secondaryCpuAbiFromSettings3 = str;
            if ((scanFlags & 256) != 0) {
                primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
                pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
                pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
            } else {
                primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        } else if (needToDeriveAbi) {
            user = user2;
            Trace.traceBegin(262144, "derivePackageAbi");
            derivePackageAbi(pkg, cpuAbiOverride2, (pkg.isLibrary() ^ true) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath));
            Trace.traceEnd(262144);
            if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                setBundledAppAbisAndRoots(pkg, pkgSetting);
                setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            }
            secondaryCpuAbiFromSettings3 = str;
        } else {
            user = user2;
            if (primaryCpuAbiFromSettings2 != null || ((!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath))) {
                primaryCpuAbiFromSettings4 = primaryCpuAbiFromSettings2;
                pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings4;
                secondaryCpuAbiFromSettings4 = secondaryCpuAbiFromSettings2;
                pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings4;
            } else {
                derivePackageAbi(pkg, cpuAbiOverride2, !pkg.isLibrary() && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath));
                if (pkg.applicationInfo.primaryCpuAbi == null) {
                    setBundledAppAbisAndRoots(pkg, pkgSetting);
                    primaryCpuAbiFromSettings4 = primaryCpuAbiFromSettings2;
                    secondaryCpuAbiFromSettings4 = secondaryCpuAbiFromSettings2;
                } else {
                    primaryCpuAbiFromSettings4 = primaryCpuAbiFromSettings2;
                    secondaryCpuAbiFromSettings4 = secondaryCpuAbiFromSettings2;
                }
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            if (DEBUG_ABI_SELECTION) {
                StringBuilder sb2 = new StringBuilder();
                secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings4;
                sb2.append("Using ABIS and native lib paths from settings : ");
                sb2.append(pkg.packageName);
                sb2.append(HwLog.PREFIX);
                sb2.append(pkg.applicationInfo.primaryCpuAbi);
                sb2.append(", ");
                sb2.append(pkg.applicationInfo.secondaryCpuAbi);
                secondaryCpuAbiFromSettings3 = str;
                Slog.i(secondaryCpuAbiFromSettings3, sb2.toString());
                primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings4;
            } else {
                secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings4;
                secondaryCpuAbiFromSettings3 = str;
                primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings4;
            }
        }
        if (isPlatformPackage) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            if (VMRuntime.getRuntime().is64Bit()) {
                z = false;
                str3 = Build.SUPPORTED_64_BIT_ABIS[0];
            } else {
                z = false;
                str3 = Build.SUPPORTED_32_BIT_ABIS[0];
            }
            applicationInfo.primaryCpuAbi = str3;
        } else {
            z = false;
        }
        if ((scanFlags & 1) == 0 && (scanFlags & 4) != 0 && cpuAbiOverride2 == null && pkg.packageName != null) {
            Slog.w(secondaryCpuAbiFromSettings3, "Ignoring persisted ABI override " + cpuAbiOverride2 + " for package " + pkg.packageName);
        }
        pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
        pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        pkgSetting.cpuAbiOverrideString = cpuAbiOverride2;
        pkg.cpuAbiOverride = cpuAbiOverride2;
        if (DEBUG_ABI_SELECTION) {
            Slog.d(secondaryCpuAbiFromSettings3, "Resolved nativeLibraryRoot for " + pkg.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
        }
        pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
        if (DEBUG_ABI_SELECTION) {
            Log.d(secondaryCpuAbiFromSettings3, "Abis for package[" + pkg.packageName + "] are primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
        }
        if ((scanFlags & 16) == 0 && pkgSetting.sharedUser != null) {
            changedAbiCodePath = adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
        }
        if (isUnderFactoryTest && pkg.requestedPermissions.contains("android.permission.FACTORY_TEST")) {
            pkg.applicationInfo.flags |= 16;
        }
        if (isSystemApp(pkg)) {
            pkgSetting.isOrphaned = true;
        }
        long scanFileTime = PackageManagerServiceUtils.getLastModifiedTime(pkg);
        if (currentTime != 0) {
            cpuAbiOverride = cpuAbiOverride2;
            originalPkgSetting = originalPkgSetting2;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = currentTime;
                pkgSetting.firstInstallTime = currentTime;
            } else if ((scanFlags & 8) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else {
            cpuAbiOverride = cpuAbiOverride2;
            originalPkgSetting = originalPkgSetting2;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = scanFileTime;
                pkgSetting.firstInstallTime = scanFileTime;
            } else if ((parseFlags & 16) != 0) {
                if (scanFileTime != pkgSetting.timeStamp) {
                    pkgSetting.lastUpdateTime = scanFileTime;
                }
                if ((pkg.applicationInfo.hwFlags & 8388608) != 0) {
                    if (!HwMaplePMServiceUtils.getMapleEnableFlag(pkg.packageName)) {
                        HwMaplePMServiceUtils.setMapleEnableFlag(pkg.packageName, true);
                    }
                }
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        pkgSetting.pkg = pkg;
        pkgSetting.pkgFlags = pkg.applicationInfo.flags;
        if (pkg.getLongVersionCode() != pkgSetting.versionCode) {
            pkgSetting.versionCode = pkg.getLongVersionCode();
        }
        String volumeUuid = pkg.applicationInfo.volumeUuid;
        if (!Objects.equals(volumeUuid, pkgSetting.volumeUuid)) {
            StringBuilder sb3 = new StringBuilder();
            sb3.append("Update");
            sb3.append(pkgSetting.isSystem() ? " system" : "");
            sb3.append(" package ");
            sb3.append(pkg.packageName);
            sb3.append(" volume from ");
            sb3.append(pkgSetting.volumeUuid);
            sb3.append(str2);
            sb3.append(volumeUuid);
            Slog.i(secondaryCpuAbiFromSettings3, sb3.toString());
            pkgSetting.volumeUuid = volumeUuid;
        }
        if (!TextUtils.isEmpty(pkg.staticSharedLibName)) {
            staticSharedLibraryInfo = SharedLibraryInfo.createForStatic(pkg);
        } else {
            staticSharedLibraryInfo = null;
        }
        if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
            List<SharedLibraryInfo> dynamicSharedLibraryInfos2 = new ArrayList<>(pkg.libraryNames.size());
            for (Iterator it = pkg.libraryNames.iterator(); it.hasNext(); it = it) {
                dynamicSharedLibraryInfos2.add(SharedLibraryInfo.createForDynamic(pkg, (String) it.next()));
            }
            dynamicSharedLibraryInfos = dynamicSharedLibraryInfos2;
        } else {
            dynamicSharedLibraryInfos = null;
        }
        if (!createNewPackage) {
            z = true;
        }
        return new ScanResult(request, true, pkgSetting, changedAbiCodePath, z, staticSharedLibraryInfo, dynamicSharedLibraryInfos);
    }

    private static boolean apkHasCode(String fileName) {
        StrictJarFile jarFile = null;
        boolean z = false;
        try {
            jarFile = new StrictJarFile(fileName, false, false);
            if (jarFile.findEntry("classes.dex") != null) {
                z = true;
            }
            try {
                jarFile.close();
            } catch (IOException e) {
            }
            return z;
        } catch (IOException e2) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e3) {
                }
            }
            return false;
        } catch (Throwable th) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e4) {
                }
            }
            throw th;
        }
    }

    private static void assertCodePolicy(PackageParser.Package pkg) throws PackageManagerException {
        boolean shouldHaveCode = (pkg.applicationInfo.flags & 4) != 0;
        boolean isMapleOnlySupport = (pkg.applicationInfo.hwFlags & 4194304) != 0 && MAPLE_ENABLE;
        if (shouldHaveCode && !apkHasCode(pkg.baseCodePath) && !isMapleOnlySupport) {
            throw new PackageManagerException(-2, "Package " + pkg.baseCodePath + " code is missing");
        } else if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            int i = 0;
            while (i < pkg.splitCodePaths.length) {
                if (!((pkg.splitFlags[i] & 4) != 0) || apkHasCode(pkg.splitCodePaths[i]) || isMapleOnlySupport) {
                    i++;
                } else {
                    throw new PackageManagerException(-2, "Package " + pkg.splitCodePaths[i] + " code is missing");
                }
            }
        }
    }

    private static void applyPolicy(PackageParser.Package pkg, int parseFlags, int scanFlags, PackageParser.Package platformPkg, int hwFlags) {
        if ((scanFlags & 131072) != 0) {
            pkg.applicationInfo.flags |= 1;
            if (pkg.applicationInfo.isDirectBootAware()) {
                Iterator it = pkg.services.iterator();
                while (it.hasNext()) {
                    PackageParser.Service s = (PackageParser.Service) it.next();
                    ServiceInfo serviceInfo = s.info;
                    s.info.directBootAware = true;
                    serviceInfo.encryptionAware = true;
                }
                Iterator it2 = pkg.providers.iterator();
                while (it2.hasNext()) {
                    PackageParser.Provider p = (PackageParser.Provider) it2.next();
                    ProviderInfo providerInfo = p.info;
                    p.info.directBootAware = true;
                    providerInfo.encryptionAware = true;
                }
                Iterator it3 = pkg.activities.iterator();
                while (it3.hasNext()) {
                    PackageParser.Activity a = (PackageParser.Activity) it3.next();
                    ActivityInfo activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
                Iterator it4 = pkg.receivers.iterator();
                while (it4.hasNext()) {
                    PackageParser.Activity r = (PackageParser.Activity) it4.next();
                    ActivityInfo activityInfo2 = r.info;
                    r.info.directBootAware = true;
                    activityInfo2.encryptionAware = true;
                }
            }
            if (PackageManagerServiceUtils.compressedFileExists(pkg.codePath)) {
                pkg.isStub = true;
            }
        } else {
            pkg.coreApp = false;
            pkg.applicationInfo.flags &= -9;
            pkg.applicationInfo.privateFlags &= -33;
            pkg.applicationInfo.privateFlags &= -65;
            if (pkg.permissionGroups != null && pkg.permissionGroups.size() > 0) {
                for (int i = pkg.permissionGroups.size() - 1; i >= 0; i--) {
                    ((PackageParser.PermissionGroup) pkg.permissionGroups.get(i)).info.priority = 0;
                }
            }
        }
        if ((scanFlags & 262144) == 0) {
            pkg.protectedBroadcasts = null;
            if (pkg.receivers != null) {
                for (int i2 = pkg.receivers.size() - 1; i2 >= 0; i2--) {
                    PackageParser.Activity receiver = (PackageParser.Activity) pkg.receivers.get(i2);
                    if ((receiver.info.flags & 1073741824) != 0) {
                        receiver.info.exported = false;
                    }
                }
            }
            if (pkg.services != null) {
                for (int i3 = pkg.services.size() - 1; i3 >= 0; i3--) {
                    PackageParser.Service service = (PackageParser.Service) pkg.services.get(i3);
                    if ((service.info.flags & 1073741824) != 0) {
                        service.info.exported = false;
                    }
                }
            }
            if (pkg.providers != null) {
                for (int i4 = pkg.providers.size() - 1; i4 >= 0; i4--) {
                    PackageParser.Provider provider = (PackageParser.Provider) pkg.providers.get(i4);
                    if ((provider.info.flags & 1073741824) != 0) {
                        provider.info.exported = false;
                    }
                }
            }
        }
        if ((scanFlags & 262144) != 0) {
            pkg.applicationInfo.privateFlags |= 8;
        }
        if ((scanFlags & 524288) != 0) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags = 131072 | applicationInfo.privateFlags;
        }
        if ((scanFlags & 1048576) != 0) {
            ApplicationInfo applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags = 262144 | applicationInfo2.privateFlags;
        }
        if ((scanFlags & 2097152) != 0) {
            ApplicationInfo applicationInfo3 = pkg.applicationInfo;
            applicationInfo3.privateFlags = 524288 | applicationInfo3.privateFlags;
        }
        if ((4194304 & scanFlags) != 0) {
            ApplicationInfo applicationInfo4 = pkg.applicationInfo;
            applicationInfo4.privateFlags = 2097152 | applicationInfo4.privateFlags;
        }
        if ((8388608 & scanFlags) != 0) {
            pkg.applicationInfo.privateFlags |= 1073741824;
        }
        if (PLATFORM_PACKAGE_NAME.equals(pkg.packageName) || (platformPkg != null && PackageManagerServiceUtils.compareSignatures(platformPkg.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
            ApplicationInfo applicationInfo5 = pkg.applicationInfo;
            applicationInfo5.privateFlags = 1048576 | applicationInfo5.privateFlags;
        }
        if (!isSystemApp(pkg)) {
            pkg.mOriginalPackages = null;
            pkg.mRealPackage = null;
            pkg.mAdoptPermissions = null;
        }
        PackageBackwardCompatibility.modifySharedLibraries(pkg);
        HwPackageManagerServiceUtils.addFlagsForRemovablePreApk(pkg, hwFlags);
        HwPackageManagerServiceUtils.addFlagsForUpdatedRemovablePreApk(pkg, hwFlags);
    }

    private static <T> T assertNotNull(T object, String message) throws PackageManagerException {
        if (object != null) {
            return object;
        }
        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, message);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags) throws PackageManagerException {
        assertPackageIsValid(pkg, parseFlags, scanFlags, 0);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags, int hwFlags) throws PackageManagerException {
        ArrayMap<String, PackageParser.Package> arrayMap;
        PackageManagerService packageManagerService;
        PackageSetting targetPkgSetting;
        LongSparseArray<SharedLibraryInfo> versionedLib;
        KeySetManagerService ksms;
        PackageManagerService packageManagerService2 = this;
        if ((parseFlags & 64) != 0) {
            assertCodePolicy(pkg);
        }
        if (pkg.applicationInfo.getCodePath() != null) {
            if (pkg.applicationInfo.getResourcePath() != null) {
                boolean isFirstBootOrUpgrade = true;
                boolean isUserInstall = (scanFlags & 16) == 0;
                if ((scanFlags & 8192) == 0) {
                    isFirstBootOrUpgrade = false;
                }
                if ((isUserInstall || isFirstBootOrUpgrade) && packageManagerService2.mApexManager.isApexPackage(pkg.packageName)) {
                    throw new PackageManagerException(-5, pkg.packageName + " is an APEX package and can't be installed as an APK.");
                }
                KeySetManagerService ksms2 = packageManagerService2.mSettings.mKeySetManagerService;
                ksms2.assertScannedPackageValid(pkg);
                ArrayMap<String, PackageParser.Package> arrayMap2 = packageManagerService2.mPackages;
                synchronized (arrayMap2) {
                    try {
                        if (pkg.packageName.equals(PLATFORM_PACKAGE_NAME)) {
                            try {
                                if (packageManagerService2.mAndroidApplication != null) {
                                    Slog.w(TAG, "*************************************************");
                                    Slog.w(TAG, "Core android package being redefined.  Skipping.");
                                    Slog.w(TAG, " codePath=" + pkg.codePath);
                                    Slog.w(TAG, "*************************************************");
                                    throw new PackageManagerException(-5, "Core android package being redefined.  Skipping.");
                                }
                            } catch (Throwable th) {
                                th = th;
                                arrayMap = arrayMap2;
                                throw th;
                            }
                        }
                        if ((scanFlags & 4) == 0) {
                            if (packageManagerService2.mPackages.containsKey(pkg.packageName)) {
                                throw new PackageManagerException(-5, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
                            }
                        }
                        if (!pkg.applicationInfo.isStaticSharedLibrary()) {
                            arrayMap = arrayMap2;
                        } else if ((scanFlags & 4) != 0 || !packageManagerService2.mPackages.containsKey(pkg.manifestPackageName)) {
                            try {
                                if (pkg.applicationInfo.targetSdkVersion < 26) {
                                    throw new PackageManagerException("Packages declaring static-shared libs must target O SDK or higher");
                                } else if ((scanFlags & 16384) != 0) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot be instant apps");
                                } else if (!ArrayUtils.isEmpty(pkg.mOriginalPackages)) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot be renamed");
                                } else if (!ArrayUtils.isEmpty(pkg.childPackages)) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot have child packages");
                                } else if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare dynamic libs");
                                } else if (pkg.mSharedUserId != null) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare shared users");
                                } else if (!pkg.activities.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare activities");
                                } else if (!pkg.services.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare services");
                                } else if (!pkg.providers.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare content providers");
                                } else if (!pkg.receivers.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare broadcast receivers");
                                } else if (!pkg.permissionGroups.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare permission groups");
                                } else if (!pkg.permissions.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare permissions");
                                } else if (pkg.protectedBroadcasts != null) {
                                    throw new PackageManagerException("Static shared libs cannot declare protected broadcasts");
                                } else if (pkg.mOverlayTarget == null) {
                                    long minVersionCode = Long.MIN_VALUE;
                                    long maxVersionCode = JobStatus.NO_LATEST_RUNTIME;
                                    LongSparseArray<SharedLibraryInfo> versionedLib2 = packageManagerService2.mSharedLibraries.get(pkg.staticSharedLibName);
                                    if (versionedLib2 != null) {
                                        int versionCount = versionedLib2.size();
                                        int i = 0;
                                        while (true) {
                                            if (i >= versionCount) {
                                                arrayMap = arrayMap2;
                                                break;
                                            }
                                            SharedLibraryInfo libInfo = versionedLib2.valueAt(i);
                                            long libVersionCode = libInfo.getDeclaringPackage().getLongVersionCode();
                                            try {
                                                if (libInfo.getLongVersion() >= pkg.staticSharedLibVersion) {
                                                    ksms = ksms2;
                                                    arrayMap = arrayMap2;
                                                    versionedLib = versionedLib2;
                                                    if (libInfo.getLongVersion() <= pkg.staticSharedLibVersion) {
                                                        if (!"com.huawei.androidx".equals(pkg.manifestPackageName)) {
                                                            maxVersionCode = libVersionCode;
                                                            minVersionCode = libVersionCode;
                                                            break;
                                                        }
                                                        minVersionCode = Math.max(minVersionCode, libVersionCode);
                                                    } else {
                                                        maxVersionCode = Math.min(maxVersionCode, libVersionCode - 1);
                                                    }
                                                } else {
                                                    ksms = ksms2;
                                                    arrayMap = arrayMap2;
                                                    try {
                                                        versionedLib = versionedLib2;
                                                        minVersionCode = Math.max(minVersionCode, libVersionCode + 1);
                                                    } catch (Throwable th2) {
                                                        th = th2;
                                                        throw th;
                                                    }
                                                }
                                                i++;
                                                packageManagerService2 = this;
                                                ksms2 = ksms;
                                                arrayMap2 = arrayMap;
                                                isUserInstall = isUserInstall;
                                                versionedLib2 = versionedLib;
                                            } catch (Throwable th3) {
                                                th = th3;
                                                throw th;
                                            }
                                        }
                                    } else {
                                        arrayMap = arrayMap2;
                                    }
                                    if (pkg.getLongVersionCode() < minVersionCode || pkg.getLongVersionCode() > maxVersionCode) {
                                        throw new PackageManagerException("Static shared lib version codes must be ordered as lib versions");
                                    }
                                } else {
                                    throw new PackageManagerException("Static shared libs cannot be overlay targets");
                                }
                            } catch (Throwable th4) {
                                th = th4;
                                arrayMap = arrayMap2;
                                throw th;
                            }
                        } else {
                            throw new PackageManagerException("Duplicate static shared lib provider package");
                        }
                        if (pkg.childPackages == null || pkg.childPackages.isEmpty()) {
                            packageManagerService = this;
                        } else if ((262144 & scanFlags) != 0) {
                            int childCount = pkg.childPackages.size();
                            int i2 = 0;
                            while (i2 < childCount) {
                                try {
                                    if (!this.mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, ((PackageParser.Package) pkg.childPackages.get(i2)).packageName)) {
                                        i2++;
                                    } else {
                                        throw new PackageManagerException("Can't override child of another disabled app. Ignoring package " + pkg.packageName);
                                    }
                                } catch (Throwable th5) {
                                    th = th5;
                                    throw th;
                                }
                            }
                            packageManagerService = this;
                        } else {
                            throw new PackageManagerException("Only privileged apps can add child packages. Ignoring package " + pkg.packageName);
                        }
                        if ((scanFlags & 128) != 0) {
                            if (!packageManagerService.mExpectingBetter.containsKey(pkg.packageName)) {
                                if (!isSystemAppGrantByMdmAndNonPreload(pkg)) {
                                    PackageSetting known = packageManagerService.mSettings.getPackageLPr(pkg.packageName);
                                    if (known != null) {
                                        if (DEBUG_PACKAGE_SCANNING) {
                                            Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                                        }
                                        if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                                            throw new PackageManagerException(-23, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                                        }
                                    } else {
                                        throw new PackageManagerException(-19, "Application package " + pkg.packageName + " not found; ignoring.");
                                    }
                                }
                            }
                            PackageManagerServiceUtils.logCriticalInfo(5, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
                        }
                        if ((scanFlags & 4) != 0) {
                            packageManagerService.mComponentResolver.assertProvidersNotDefined(pkg);
                        }
                        if (!pkg.isPrivileged() && pkg.mSharedUserId != null) {
                            SharedUserSetting sharedUserSetting = null;
                            try {
                                sharedUserSetting = packageManagerService.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
                            } catch (PackageManagerException e) {
                            }
                            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                                PackageSetting platformPkgSetting = packageManagerService.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME);
                                if (!(platformPkgSetting.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(platformPkgSetting.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                    throw new PackageManagerException("Apps that share a user with a privileged app must themselves be marked as privileged. " + pkg.packageName + " shares privileged user " + pkg.mSharedUserId + ".");
                                }
                            }
                        }
                        if (pkg.mOverlayTarget != null) {
                            if ((131072 & scanFlags) != 0) {
                                if ((parseFlags & 16) == 0) {
                                    PackageSetting previousPkg = (PackageSetting) assertNotNull(packageManagerService.mSettings.getPackageLPr(pkg.packageName), "previous package state not present");
                                    PackageParser.Package ppkg = previousPkg.pkg;
                                    if (ppkg == null) {
                                        try {
                                            ppkg = new PackageParser().parsePackage(previousPkg.codePath, parseFlags | 16);
                                        } catch (PackageParser.PackageParserException e2) {
                                            Slog.w(TAG, "failed to parse " + previousPkg.codePath, e2);
                                        }
                                    }
                                    if (ppkg != null && ppkg.mOverlayIsStatic) {
                                        throw new PackageManagerException("Overlay " + pkg.packageName + " is static and cannot be upgraded.");
                                    } else if (pkg.mOverlayIsStatic) {
                                        throw new PackageManagerException("Overlay " + pkg.packageName + " cannot be upgraded into a static overlay.");
                                    }
                                }
                            } else if (!pkg.mOverlayIsStatic) {
                                if (pkg.applicationInfo.targetSdkVersion < 29) {
                                    PackageSetting platformPkgSetting2 = packageManagerService.mSettings.getPackageLPr(PLATFORM_PACKAGE_NAME);
                                    if (!(platformPkgSetting2.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(platformPkgSetting2.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                        throw new PackageManagerException("Overlay " + pkg.packageName + " must target Q or later, or be signed with the platform certificate");
                                    }
                                }
                                if (!(pkg.mOverlayTargetName != null || (targetPkgSetting = packageManagerService.mSettings.getPackageLPr(pkg.mOverlayTarget)) == null || targetPkgSetting.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(targetPkgSetting.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                    throw new PackageManagerException("Overlay " + pkg.packageName + " and target " + pkg.mOverlayTarget + " signed with different certificates, and the overlay lacks <overlay android:targetName>");
                                }
                            } else {
                                throw new PackageManagerException("Overlay " + pkg.packageName + " is static but not pre-installed.");
                            }
                        }
                        return;
                    } catch (Throwable th6) {
                        th = th6;
                        arrayMap = arrayMap2;
                        throw th;
                    }
                }
            }
        }
        throw new PackageManagerException(-2, "Code and resource paths haven't been set correctly");
    }

    @GuardedBy({"mPackages"})
    private boolean addBuiltInSharedLibraryLocked(String path, String name) {
        if (nonStaticSharedLibExistsLocked(name)) {
            return false;
        }
        commitSharedLibraryInfoLocked(new SharedLibraryInfo(path, null, null, name, -1, 0, new VersionedPackage(PLATFORM_PACKAGE_NAME, 0L), null, null));
        return true;
    }

    @GuardedBy({"mPackages"})
    private boolean nonStaticSharedLibExistsLocked(String name) {
        return sharedLibExists(name, -1, this.mSharedLibraries);
    }

    private static boolean sharedLibExists(String name, long version, Map<String, LongSparseArray<SharedLibraryInfo>> librarySource) {
        LongSparseArray<SharedLibraryInfo> versionedLib = librarySource.get(name);
        if (versionedLib == null || versionedLib.indexOfKey(version) < 0) {
            return false;
        }
        return true;
    }

    @GuardedBy({"mPackages"})
    private void commitSharedLibraryInfoLocked(SharedLibraryInfo libraryInfo) {
        String name = libraryInfo.getName();
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            versionedLib = new LongSparseArray<>();
            this.mSharedLibraries.put(name, versionedLib);
        }
        String declaringPackageName = libraryInfo.getDeclaringPackage().getPackageName();
        if (libraryInfo.getType() == 2) {
            this.mStaticLibsByDeclaringPackage.put(declaringPackageName, versionedLib);
        }
        versionedLib.put(libraryInfo.getLongVersion(), libraryInfo);
    }

    private boolean removeSharedLibraryLPw(String name, long version) {
        int libIdx;
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null || (libIdx = versionedLib.indexOfKey(version)) < 0) {
            return false;
        }
        SharedLibraryInfo libraryInfo = versionedLib.valueAt(libIdx);
        versionedLib.remove(version);
        if (versionedLib.size() > 0) {
            return true;
        }
        this.mSharedLibraries.remove(name);
        if (libraryInfo.getType() != 2) {
            return true;
        }
        this.mStaticLibsByDeclaringPackage.remove(libraryInfo.getDeclaringPackage().getPackageName());
        return true;
    }

    private void commitPackageSettings(PackageParser.Package pkg, PackageParser.Package oldPkg, PackageSetting pkgSetting, int scanFlags, boolean chatty, ReconciledPackage reconciledPkg) {
        if ((pkg.applicationInfo.hwFlags & 1048576) != 0) {
            Slog.i(TAG, "Restrict Permissions for Z.");
            ZosPermissionAdapter.getInstance().restrictPermissions(pkg);
        }
        String pkgName = pkg.packageName;
        ComponentName componentName = this.mCustomResolverComponentName;
        if (componentName != null && componentName.getPackageName().equals(pkg.packageName)) {
            getHwPMSEx().setUpCustomResolverActivity(pkg);
        }
        if (pkg.packageName.equals(PLATFORM_PACKAGE_NAME)) {
            synchronized (this.mPackages) {
                if ((scanFlags & 1024) == 0) {
                    this.mPlatformPackage = pkg;
                    pkg.mVersionCode = this.mSdkVersion;
                    pkg.mVersionCodeMajor = 0;
                    this.mAndroidApplication = pkg.applicationInfo;
                    if (!this.mResolverReplaced) {
                        this.mResolveActivity.applicationInfo = this.mAndroidApplication;
                        this.mResolveActivity.name = ResolverActivity.class.getName();
                        this.mResolveActivity.packageName = this.mAndroidApplication.packageName;
                        this.mResolveActivity.processName = "system:ui";
                        this.mResolveActivity.launchMode = 0;
                        this.mResolveActivity.documentLaunchMode = 3;
                        this.mResolveActivity.flags = 32;
                        this.mResolveActivity.theme = 16974374;
                        this.mResolveActivity.exported = true;
                        this.mResolveActivity.enabled = true;
                        this.mResolveActivity.resizeMode = 2;
                        this.mResolveActivity.configChanges = 3504;
                        this.mResolveInfo.activityInfo = this.mResolveActivity;
                        this.mResolveInfo.priority = 0;
                        this.mResolveInfo.preferredOrder = 0;
                        this.mResolveInfo.match = 0;
                        this.mResolveComponentName = new ComponentName(this.mAndroidApplication.packageName, this.mResolveActivity.name);
                    }
                }
            }
        }
        ArrayList<PackageParser.Package> clientLibPkgs = null;
        synchronized (this.mPackages) {
            if (!ArrayUtils.isEmpty(reconciledPkg.allowedSharedLibraryInfos)) {
                for (SharedLibraryInfo info : reconciledPkg.allowedSharedLibraryInfos) {
                    commitSharedLibraryInfoLocked(info);
                }
                Map<String, PackageParser.Package> combinedPackages = reconciledPkg.getCombinedPackages();
                try {
                    updateSharedLibrariesLocked(pkg, null, combinedPackages);
                } catch (PackageManagerException e) {
                    Slog.e(TAG, "updateSharedLibrariesLPr failed: ", e);
                }
                if ((scanFlags & 16) == 0) {
                    clientLibPkgs = updateAllSharedLibrariesLocked(pkg, combinedPackages);
                }
            }
        }
        if ((scanFlags & 16) == 0 && (scanFlags & 2048) == 0 && (scanFlags & 4096) == 0) {
            checkPackageFrozen(pkgName);
        }
        if (clientLibPkgs != null) {
            for (int i = 0; i < clientLibPkgs.size(); i++) {
                PackageParser.Package clientPkg = clientLibPkgs.get(i);
                killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
            }
        }
        Trace.traceBegin(262144, "updateSettings");
        synchronized (this.mPackages) {
            this.mSettings.insertPackageSettingLPw(pkgSetting, pkg);
            mHwPMSEx.updateCertCompatPackage(pkg, pkgSetting);
            this.mPackages.put(pkg.applicationInfo.packageName, pkg);
            this.mSettings.mKeySetManagerService.addScannedPackageLPw(pkg);
            this.mComponentResolver.addAllComponents(pkg, chatty);
            if ((scanFlags & 16384) != 0) {
                Slog.w(TAG, "Permission groups from package " + pkg.packageName + " ignored: instant apps cannot define new permission groups.");
            } else {
                this.mPermissionManager.addAllPermissionGroups(pkg, chatty);
            }
            if ((scanFlags & 16384) != 0) {
                Slog.w(TAG, "Permissions from package " + pkg.packageName + " ignored: instant apps cannot define new permissions.");
            } else {
                this.mPermissionManager.addAllPermissions(pkg, chatty);
            }
            StringBuilder r = null;
            int i2 = 0;
            for (int collectionSize = pkg.instrumentation.size(); i2 < collectionSize; collectionSize = collectionSize) {
                PackageParser.Instrumentation a = (PackageParser.Instrumentation) pkg.instrumentation.get(i2);
                a.info.packageName = pkg.applicationInfo.packageName;
                a.info.sourceDir = pkg.applicationInfo.sourceDir;
                a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
                a.info.splitNames = pkg.splitNames;
                a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
                a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
                a.info.splitDependencies = pkg.applicationInfo.splitDependencies;
                a.info.dataDir = pkg.applicationInfo.dataDir;
                a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir;
                a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir;
                a.info.primaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                a.info.secondaryCpuAbi = pkg.applicationInfo.secondaryCpuAbi;
                a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
                a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir;
                this.mInstrumentation.put(a.getComponentName(), a);
                if (chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(a.info.name);
                }
                i2++;
            }
            if (r != null && DEBUG_PACKAGE_SCANNING) {
                Log.d(TAG, "  Instrumentation: " + ((Object) r));
            }
            if (pkg.protectedBroadcasts != null) {
                int collectionSize2 = pkg.protectedBroadcasts.size();
                synchronized (this.mProtectedBroadcasts) {
                    for (int i3 = 0; i3 < collectionSize2; i3++) {
                        this.mProtectedBroadcasts.add((String) pkg.protectedBroadcasts.get(i3));
                    }
                }
            }
            if (oldPkg != null) {
                AsyncTask.execute(new Runnable(pkg, oldPkg, new ArrayList<>(this.mPackages.keySet())) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$scNZVEJLQMgp84tbGQ2Cq35w */
                    private final /* synthetic */ PackageParser.Package f$1;
                    private final /* synthetic */ PackageParser.Package f$2;
                    private final /* synthetic */ ArrayList f$3;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                    }

                    public final void run() {
                        PackageManagerService.this.lambda$commitPackageSettings$7$PackageManagerService(this.f$1, this.f$2, this.f$3);
                    }
                });
            }
        }
        Trace.traceEnd(262144);
    }

    public /* synthetic */ void lambda$commitPackageSettings$7$PackageManagerService(PackageParser.Package pkg, PackageParser.Package oldPkg, ArrayList allPackageNames) {
        this.mPermissionManager.revokeRuntimePermissionsIfGroupChanged(pkg, oldPkg, allPackageNames, this.mPermissionCallback);
    }

    private static void derivePackageAbi(PackageParser.Package pkg, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
        boolean extractLibs2;
        int copyRet;
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        if (!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) {
            extractLibs2 = extractLibs;
        } else {
            extractLibs2 = false;
        }
        String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
        boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
        NativeLibraryHelper.Handle handle = null;
        try {
            handle = NativeLibraryHelper.Handle.create(pkg);
            File nativeLibraryRoot = new File(nativeLibraryRootStr);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            if (HwMaplePMServiceUtils.isNeedToCopyMapleSo(pkg)) {
                Slog.i(TAG, "Is need to cp mp so " + pkg.packageName);
                int copyRet2 = NativeLibraryHelper.copyNativeMapleBinaries(handle, new File(nativeLibraryRoot.getParent(), "maple"));
                if (copyRet2 < 0 && copyRet2 != -114) {
                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Error unpackaging native libs for app, errorCode=" + copyRet2);
                }
            }
            if (isMultiArch(pkg.applicationInfo)) {
                if (pkg.cpuAbiOverride != null && !"-".equals(pkg.cpuAbiOverride)) {
                    Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
                }
                int abi32 = -114;
                int abi64 = -114;
                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                    if (extractLibs2) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                if (abi32 < 0 || !pkg.isLibrary() || !extractLibs2) {
                    maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
                    if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                        if (extractLibs2) {
                            Trace.traceBegin(262144, "copyNativeBinaries");
                            abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                        } else {
                            Trace.traceBegin(262144, "findSupportedAbi");
                            abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                        }
                        Trace.traceEnd(262144);
                    }
                    maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
                    if (abi64 >= 0) {
                        if (!extractLibs2 || !pkg.isLibrary()) {
                            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
                        } else {
                            throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                        }
                    }
                    if (abi32 >= 0) {
                        String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                        if (abi64 < 0) {
                            pkg.applicationInfo.primaryCpuAbi = abi;
                        } else if (pkg.use32bitAbi) {
                            pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                            pkg.applicationInfo.primaryCpuAbi = abi;
                        } else {
                            pkg.applicationInfo.secondaryCpuAbi = abi;
                        }
                    }
                } else {
                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                }
            } else {
                String[] abiList = cpuAbiOverride != null ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
                boolean needsRenderScriptOverride = false;
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                    needsRenderScriptOverride = true;
                }
                if (extractLibs2) {
                    Trace.traceBegin(262144, "copyNativeBinaries");
                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
                } else {
                    Trace.traceBegin(262144, "findSupportedAbi");
                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
                }
                Trace.traceEnd(262144);
                if (copyRet < 0 && copyRet != -114) {
                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Error unpackaging native libs for app, errorCode=" + copyRet);
                } else if (copyRet >= 0) {
                    if (!pkg.isLibrary()) {
                        pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
                    } else {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library with native libs must be multiarch");
                    }
                } else if (copyRet == -114 && cpuAbiOverride != null) {
                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
                } else if (needsRenderScriptOverride) {
                    pkg.applicationInfo.primaryCpuAbi = abiList[0];
                }
            }
        } catch (IOException ioe) {
            Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
        } catch (Throwable th) {
            IoUtils.closeQuietly(handle);
            throw th;
        }
        IoUtils.closeQuietly(handle);
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
    }

    private static List<String> adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, PackageParser.Package scannedPackage) {
        String adjustedAbi;
        List<String> changedAbiCodePath = null;
        String requiredInstructionSet = null;
        if (!(scannedPackage == null || scannedPackage.applicationInfo.primaryCpuAbi == null)) {
            requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
        }
        PackageSetting requirer = null;
        for (PackageSetting ps : packagesForUser) {
            if ((scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) && ps.primaryCpuAbiString != null) {
                String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
                if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Instruction set mismatch, ");
                    sb.append(requirer == null ? "[caller]" : requirer);
                    sb.append(" requires ");
                    sb.append(requiredInstructionSet);
                    sb.append(" whereas ");
                    sb.append(ps);
                    sb.append(" requires ");
                    sb.append(instructionSet);
                    Slog.w(TAG, sb.toString());
                }
                if (requiredInstructionSet == null) {
                    requiredInstructionSet = instructionSet;
                    requirer = ps;
                }
            }
        }
        if (requiredInstructionSet != null) {
            if (requirer != null) {
                adjustedAbi = requirer.primaryCpuAbiString;
                if (scannedPackage != null && (!ZygoteInit.sIsMygote || (scannedPackage.applicationInfo.hwFlags & DumpState.DUMP_SERVICE_PERMISSIONS) == 0)) {
                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
                }
            } else {
                adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
            }
            for (PackageSetting ps2 : packagesForUser) {
                if ((scannedPackage == null || !scannedPackage.packageName.equals(ps2.name)) && ps2.primaryCpuAbiString == null) {
                    if (SystemProperties.get("persist.sys.shareduid_abi_check", "1").equals("0")) {
                        ps2.primaryCpuAbiString = adjustedAbi;
                    }
                    if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null || TextUtils.equals(adjustedAbi, ps2.pkg.applicationInfo.primaryCpuAbi))) {
                        if (SystemProperties.get("persist.sys.shareduid_abi_check", "1").equals("0")) {
                            ps2.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                        }
                        if (DEBUG_ABI_SELECTION) {
                            StringBuilder sb2 = new StringBuilder();
                            sb2.append("Adjusting ABI for ");
                            sb2.append(ps2.name);
                            sb2.append(" to ");
                            sb2.append(adjustedAbi);
                            sb2.append(" (requirer=");
                            PackageParser.Package r8 = "null";
                            sb2.append(requirer != null ? requirer.pkg : r8);
                            sb2.append(", scannedPackage=");
                            if (scannedPackage != null) {
                                r8 = scannedPackage;
                            }
                            sb2.append(r8);
                            sb2.append(")");
                            Slog.i(TAG, sb2.toString());
                        }
                        if (changedAbiCodePath == null) {
                            changedAbiCodePath = new ArrayList<>();
                        }
                        changedAbiCodePath.add(ps2.codePathString);
                    }
                }
            }
        }
        return changedAbiCodePath;
    }

    private void setUpCustomResolverActivity(PackageParser.Package pkg) {
        synchronized (this.mPackages) {
            this.mResolverReplaced = true;
            this.mResolveActivity.applicationInfo = pkg.applicationInfo;
            this.mResolveActivity.name = this.mCustomResolverComponentName.getClassName();
            this.mResolveActivity.packageName = pkg.applicationInfo.packageName;
            this.mResolveActivity.processName = pkg.applicationInfo.packageName;
            this.mResolveActivity.launchMode = 0;
            this.mResolveActivity.flags = 288;
            this.mResolveActivity.theme = 0;
            this.mResolveActivity.exported = true;
            this.mResolveActivity.enabled = true;
            this.mResolveInfo.activityInfo = this.mResolveActivity;
            this.mResolveInfo.priority = 0;
            this.mResolveInfo.preferredOrder = 0;
            this.mResolveInfo.match = 0;
            this.mResolveComponentName = this.mCustomResolverComponentName;
            Slog.i(TAG, "Replacing default ResolverActivity with custom activity: " + this.mResolveComponentName);
        }
    }

    private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) {
        if (installerActivity == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Clear ephemeral installer activity");
            }
            this.mInstantAppInstallerActivity = null;
            return;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Set ephemeral installer activity: " + installerActivity.getComponentName());
        }
        this.mInstantAppInstallerActivity = installerActivity;
        this.mInstantAppInstallerActivity.flags |= 288;
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        activityInfo.exported = true;
        activityInfo.enabled = true;
        ResolveInfo resolveInfo = this.mInstantAppInstallerInfo;
        resolveInfo.activityInfo = activityInfo;
        resolveInfo.priority = 1;
        resolveInfo.preferredOrder = 1;
        resolveInfo.isDefault = true;
        resolveInfo.match = 5799936;
    }

    private static String calculateBundledApkRoot(String codePathString) {
        File codeRoot;
        File codePath = new File(codePathString);
        if (FileUtils.contains(Environment.getRootDirectory(), codePath)) {
            codeRoot = Environment.getRootDirectory();
        } else if (FileUtils.contains(Environment.getOemDirectory(), codePath)) {
            codeRoot = Environment.getOemDirectory();
        } else if (FileUtils.contains(Environment.getVendorDirectory(), codePath)) {
            codeRoot = Environment.getVendorDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else if (FileUtils.contains(Environment.getProductDirectory(), codePath)) {
            codeRoot = Environment.getProductDirectory();
        } else if (FileUtils.contains(Environment.getProductServicesDirectory(), codePath)) {
            codeRoot = Environment.getProductServicesDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else {
            try {
                File f = codePath.getCanonicalFile();
                File parent = f.getParentFile();
                while (true) {
                    File tmp = parent.getParentFile();
                    if (tmp == null) {
                        break;
                    }
                    f = parent;
                    parent = tmp;
                }
                Slog.w(TAG, "Unrecognized code path " + codePath + " - using " + f);
                codeRoot = f;
            } catch (IOException e) {
                Slog.w(TAG, "Can't canonicalize code path " + codePath);
                return Environment.getRootDirectory().getPath();
            }
        }
        return codeRoot.getPath();
    }

    protected static void setNativeLibraryPaths(PackageParser.Package pkg, File appLib32InstallDir) {
        ApplicationInfo info = pkg.applicationInfo;
        String codePath = pkg.codePath;
        File codeFile = new File(codePath);
        boolean bundledApp = info.isSystemApp() && !info.isUpdatedSystemApp();
        info.nativeLibraryRootDir = null;
        info.nativeLibraryRootRequiresIsa = false;
        info.nativeLibraryDir = null;
        info.secondaryNativeLibraryDir = null;
        String secondaryLibDir = "lib";
        if (PackageParser.isApkFile(codeFile)) {
            if (bundledApp) {
                String apkRoot = calculateBundledApkRoot(info.sourceDir);
                boolean is64Bit = VMRuntime.is64BitInstructionSet(InstructionSets.getPrimaryInstructionSet(info));
                String apkName = deriveCodePathName(codePath);
                info.nativeLibraryRootDir = Environment.buildPath(new File(apkRoot), new String[]{is64Bit ? "lib64" : secondaryLibDir, apkName}).getAbsolutePath();
                if (info.secondaryCpuAbi != null) {
                    if (!is64Bit) {
                        secondaryLibDir = "lib64";
                    }
                    info.secondaryNativeLibraryDir = Environment.buildPath(new File(apkRoot), new String[]{secondaryLibDir, apkName}).getAbsolutePath();
                }
            } else {
                info.nativeLibraryRootDir = new File(appLib32InstallDir, deriveCodePathName(codePath)).getAbsolutePath();
            }
            info.nativeLibraryRootRequiresIsa = false;
            info.nativeLibraryDir = info.nativeLibraryRootDir;
            return;
        }
        info.nativeLibraryRootDir = new File(codeFile, secondaryLibDir).getAbsolutePath();
        info.nativeLibraryRootRequiresIsa = true;
        info.nativeLibraryDir = new File(info.nativeLibraryRootDir, InstructionSets.getPrimaryInstructionSet(info)).getAbsolutePath();
        if (info.secondaryCpuAbi != null) {
            info.secondaryNativeLibraryDir = new File(info.nativeLibraryRootDir, VMRuntime.getInstructionSet(info.secondaryCpuAbi)).getAbsolutePath();
        }
    }

    private static void setBundledAppAbisAndRoots(PackageParser.Package pkg, PackageSetting pkgSetting) {
        setBundledAppAbi(pkg, calculateBundledApkRoot(pkg.applicationInfo.sourceDir), deriveCodePathName(pkg.applicationInfo.getCodePath()));
        if (pkgSetting != null) {
            pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
            pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        }
    }

    /* JADX INFO: Multiple debug info for r4v20 boolean: [D('has32BitLibs' boolean), D('isa' java.lang.String)] */
    private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) {
        boolean has64BitLibs;
        boolean has64BitLibs2;
        File codeFile = new File(pkg.codePath);
        if (PackageParser.isApkFile(codeFile)) {
            has64BitLibs = new File(apkRoot, new File("lib64", apkName).getPath()).exists();
            has64BitLibs2 = new File(apkRoot, new File("lib", apkName).getPath()).exists();
        } else {
            File rootDir = new File(codeFile, "lib");
            if (ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
                has64BitLibs = false;
            } else {
                has64BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0])).exists();
            }
            if (ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
                has64BitLibs2 = false;
            } else {
                has64BitLibs2 = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0])).exists();
            }
        }
        if (has64BitLibs && !has64BitLibs2) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has64BitLibs2 && !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (!has64BitLibs2 || !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else {
            if ((pkg.applicationInfo.flags & Integer.MIN_VALUE) == 0) {
                Slog.e(TAG, "Package " + pkg + " has multiple bundled libs, but is not multiarch.");
            }
            if (VMRuntime.is64BitInstructionSet(InstructionSets.getPreferredInstructionSet())) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
                pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
                return;
            }
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    }

    private void killApplication(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, -1, reason);
    }

    /* access modifiers changed from: private */
    public void killApplication(String pkgName, int appId, int userId, String reason) {
        long token = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killApplication(pkgName, appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    private void removePackageLI(PackageParser.Package pkg, boolean chatty) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            removePackageLI(ps.name, chatty);
        } else if (DEBUG_REMOVE && chatty) {
            Log.d(TAG, "Not removing package " + pkg.packageName + "; mExtras == null");
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                removePackageLI(ps2.name, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removePackageLI(String packageName, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + packageName);
        }
        synchronized (this.mPackages) {
            PackageParser.Package removedPackage = this.mPackages.remove(packageName);
            if (removedPackage != null) {
                cleanPackageDataStructuresLILPw(removedPackage, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i);
                this.mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        this.mComponentResolver.removeAllComponents(pkg, chatty);
        this.mPermissionManager.removeAllPermissions(pkg, chatty);
        int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        for (int i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = (PackageParser.Instrumentation) pkg.instrumentation.get(i);
            this.mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Instrumentation: " + ((Object) r));
        }
        StringBuilder r2 = null;
        if (!((pkg.applicationInfo.flags & 1) == 0 || pkg.libraryNames == null)) {
            int libraryNamesSize = pkg.libraryNames.size();
            for (int i2 = 0; i2 < libraryNamesSize; i2++) {
                String name = (String) pkg.libraryNames.get(i2);
                if (removeSharedLibraryLPw(name, 0) && DEBUG_REMOVE && chatty) {
                    if (r2 == null) {
                        r2 = new StringBuilder(256);
                    } else {
                        r2.append(' ');
                    }
                    r2.append(name);
                }
            }
        }
        StringBuilder r3 = null;
        if (pkg.staticSharedLibName != null && removeSharedLibraryLPw(pkg.staticSharedLibName, pkg.staticSharedLibVersion) && DEBUG_REMOVE && chatty) {
            if (0 == 0) {
                r3 = new StringBuilder(256);
            } else {
                r3.append(' ');
            }
            r3.append(pkg.staticSharedLibName);
        }
        if (r3 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Libraries: " + ((Object) r3));
        }
    }

    @Override // com.android.server.pm.PackageSender
    public void sendPackageBroadcast(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        mHwPMSEx.preSendPackageBroadcast(action, pkg, targetPkg);
        this.mHandler.post(new Runnable(userIds, action, pkg, extras, flags, targetPkg, finishedReceiver, instantUserIds) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$UtVCpL0mJ1ePNHwGgkapgCkTreo */
            private final /* synthetic */ int[] f$1;
            private final /* synthetic */ String f$2;
            private final /* synthetic */ String f$3;
            private final /* synthetic */ Bundle f$4;
            private final /* synthetic */ int f$5;
            private final /* synthetic */ String f$6;
            private final /* synthetic */ IIntentReceiver f$7;
            private final /* synthetic */ int[] f$8;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
                this.f$6 = r7;
                this.f$7 = r8;
                this.f$8 = r9;
            }

            public final void run() {
                PackageManagerService.this.lambda$sendPackageBroadcast$8$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6, this.f$7, this.f$8);
            }
        });
    }

    public /* synthetic */ void lambda$sendPackageBroadcast$8$PackageManagerService(int[] userIds, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] instantUserIds) {
        int[] resolvedUserIds;
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                if (userIds == null) {
                    resolvedUserIds = am.getRunningUserIds();
                } else {
                    resolvedUserIds = userIds;
                }
                doSendBroadcast(am, action, pkg, extras, flags, targetPkg, finishedReceiver, resolvedUserIds, false);
                if (instantUserIds != null && instantUserIds != EMPTY_INT_ARRAY) {
                    doSendBroadcast(am, action, pkg, extras, flags, targetPkg, finishedReceiver, instantUserIds, true);
                }
            }
        } catch (RemoteException e) {
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0022, code lost:
        if (r0 < 0) goto L_0x002c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0024, code lost:
        r2[r0].onPackageAdded(r4, r5);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x002c, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x001f, code lost:
        r0 = r2.length - 1;
     */
    @Override // com.android.server.pm.PackageSender
    public void notifyPackageAdded(String packageName, int uid) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0022, code lost:
        if (r0 < 0) goto L_0x002c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0024, code lost:
        r2[r0].onPackageChanged(r4, r5);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x002c, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x001f, code lost:
        r0 = r2.length - 1;
     */
    @Override // com.android.server.pm.PackageSender
    public void notifyPackageChanged(String packageName, int uid) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            }
        }
    }

    static /* synthetic */ int lambda$static$9(ProviderInfo p1, ProviderInfo p2) {
        int v1 = p1.initOrder;
        int v2 = p2.initOrder;
        if (v1 > v2) {
            return -1;
        }
        return v1 < v2 ? 1 : 0;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0022, code lost:
        if (r0 < 0) goto L_0x002c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0024, code lost:
        r2[r0].onPackageRemoved(r4, r5);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x002c, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x001f, code lost:
        r0 = r2.length - 1;
     */
    @Override // com.android.server.pm.PackageSender
    public void notifyPackageRemoved(String packageName, int uid) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            }
        }
    }

    private void doSendBroadcast(IActivityManager am, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, boolean isInstantApp) throws RemoteException {
        for (int id : userIds) {
            Intent intent = new Intent(action, pkg != null ? Uri.fromParts("package", pkg, null) : null);
            String[] requiredPermissions = isInstantApp ? INSTANT_APP_BROADCAST_PERMISSION : null;
            if (extras != null) {
                intent.putExtras(extras);
            }
            if (targetPkg != null) {
                intent.setPackage(targetPkg);
            }
            int uid = intent.getIntExtra("android.intent.extra.UID", -1);
            if (uid > 0 && UserHandle.getUserId(uid) != id) {
                intent.putExtra("android.intent.extra.UID", UserHandle.getUid(id, UserHandle.getAppId(uid)));
            }
            intent.putExtra("android.intent.extra.user_handle", id);
            intent.addFlags(flags | DumpState.DUMP_HANDLE);
            if (DEBUG_BROADCASTS) {
                RuntimeException here = new RuntimeException("here");
                here.fillInStackTrace();
                Slog.d(TAG, "Sending to user " + id + ": " + intent.toShortString(false, true, false, false) + HwLog.PREFIX + intent.getExtras(), here);
            }
            am.broadcastIntent((IApplicationThread) null, intent, (String) null, finishedReceiver, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, finishedReceiver != null, false, id);
        }
    }

    private boolean isExternalMediaAvailable() {
        return this.mMediaMounted || Environment.isExternalStorageEmulated();
    }

    /* access modifiers changed from: private */
    public int fixUpInstallReason(String installerPackageName, int installerUid, int installReason) {
        if (checkUidPermission("android.permission.INSTALL_PACKAGES", installerUid) == 0) {
            return installReason;
        }
        String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(UserHandle.getUserId(installerUid));
        if (ownerPackage != null && ownerPackage.equals(installerPackageName)) {
            return 1;
        }
        if (installReason == 1) {
            return 0;
        }
        return installReason;
    }

    /* access modifiers changed from: package-private */
    public void installStage(ActiveInstallSession activeInstallSession) {
        if (DEBUG_INSTANT && (activeInstallSession.getSessionParams().installFlags & 2048) != 0) {
            Slog.d(TAG, "Ephemeral install of " + activeInstallSession.getPackageName());
        }
        this.callingSessionUid = activeInstallSession.getInstallerUid();
        if (DEBUG_GUNSTALL) {
            Slog.i(TAG, "installStage: installerUid=" + this.callingSessionUid);
        }
        Message msg = this.mHandler.obtainMessage(5);
        InstallParams params = new InstallParams(activeInstallSession);
        params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "installStage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    /* access modifiers changed from: package-private */
    public void installStage(List<ActiveInstallSession> children) throws PackageManagerException {
        Message msg = this.mHandler.obtainMessage(5);
        MultiPackageInstallParams params = new MultiPackageInstallParams(UserHandle.ALL, children);
        params.setTraceMethod("installStageMultiPackage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "installStageMultiPackage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
        boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        boolean isInstantApp = pkgSetting.getInstantApp(userId);
        sendPackageAddedForNewUsers(packageName, isSystem, false, pkgSetting.appId, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
        PackageInstaller.SessionInfo info = new PackageInstaller.SessionInfo();
        info.installReason = pkgSetting.getInstallReason(userId);
        info.appPackageName = packageName;
        sendSessionCommitBroadcast(info, userId);
    }

    @Override // com.android.server.pm.PackageSender
    public void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int[] userIds, int[] instantUserIds) {
        if (!ArrayUtils.isEmpty(userIds) || !ArrayUtils.isEmpty(instantUserIds)) {
            Bundle extras = new Bundle(1);
            extras.putInt("android.intent.extra.UID", UserHandle.getUid(ArrayUtils.isEmpty(userIds) ? instantUserIds[0] : userIds[0], appId));
            sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, userIds, instantUserIds);
            if (sendBootCompleted && !ArrayUtils.isEmpty(userIds)) {
                this.mHandler.post(new Runnable(userIds, packageName, includeStopped) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$dNpDOaNQuARBbRnLTCuImaANwU4 */
                    private final /* synthetic */ int[] f$1;
                    private final /* synthetic */ String f$2;
                    private final /* synthetic */ boolean f$3;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                    }

                    public final void run() {
                        PackageManagerService.this.lambda$sendPackageAddedForNewUsers$10$PackageManagerService(this.f$1, this.f$2, this.f$3);
                    }
                });
            }
        }
    }

    public /* synthetic */ void lambda$sendPackageAddedForNewUsers$10$PackageManagerService(int[] userIds, String packageName, boolean includeStopped) {
        for (int userId : userIds) {
            sendBootCompletedBroadcastToSystemApp(packageName, includeStopped, userId);
        }
    }

    private void sendBootCompletedBroadcastToSystemApp(String packageName, boolean includeStopped, int userId) {
        if (this.mUserManagerInternal.isUserRunning(userId)) {
            IActivityManager am = ActivityManager.getService();
            try {
                Intent lockedBcIntent = new Intent("android.intent.action.LOCKED_BOOT_COMPLETED").setPackage(packageName);
                if (includeStopped) {
                    lockedBcIntent.addFlags(32);
                }
                String[] requiredPermissions = {"android.permission.RECEIVE_BOOT_COMPLETED"};
                try {
                    am.broadcastIntent((IApplicationThread) null, lockedBcIntent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, false, false, userId);
                    try {
                        if (this.mUserManagerInternal.isUserUnlockingOrUnlocked(userId)) {
                            Intent bcIntent = new Intent("android.intent.action.BOOT_COMPLETED").setPackage(packageName);
                            if (includeStopped) {
                                bcIntent.addFlags(32);
                            }
                            am.broadcastIntent((IApplicationThread) null, bcIntent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, false, false, userId);
                        }
                    } catch (RemoteException e) {
                        e = e;
                        throw e.rethrowFromSystemServer();
                    }
                } catch (RemoteException e2) {
                    e = e2;
                    throw e.rethrowFromSystemServer();
                }
            } catch (RemoteException e3) {
                e = e3;
                throw e.rethrowFromSystemServer();
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:76:0x0186, code lost:
        if (r4 == false) goto L_0x0190;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0188, code lost:
        sendPackageAddedForUser(r13, r7, r15);
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x018f, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x0190, code lost:
        if (r5 == false) goto L_0x01a6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0192, code lost:
        killApplication(r13, android.os.UserHandle.getUid(r15, r7.appId), "hiding pkg");
        sendApplicationHiddenForUser(r13, r7, r15);
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x01a5, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x01a6, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x01aa, code lost:
        return false;
     */
    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx;
        if (!hidden || (iHwPackageManagerServiceEx = mHwPMSEx) == null || !iHwPackageManagerServiceEx.isNeedForbidShellFunc(packageName)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
            int callingUid = Binder.getCallingUid();
            PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
            permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, true, "setApplicationHiddenSetting for user " + userId);
            if (!hidden || !isPackageDeviceAdmin(packageName, userId)) {
                long callingId = Binder.clearCallingIdentity();
                boolean sendAdded = false;
                boolean sendRemoved = false;
                try {
                    synchronized (this.mPackages) {
                        PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                        if (pkgSetting == null) {
                            return false;
                        }
                        if (hidden && HwPackageManagerServiceUtils.isInAntiFillingWhiteList(packageName, hasSystemFeature("android.software.home_screen", 0))) {
                            Slog.w(TAG, "Not hiding package " + packageName + ": limited by anti-filling");
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if ((pkgSetting.pkgFlags & 1) != 0 && ("com.google.android.gms".equals(packageName) || "com.google.android.gsf".equals(packageName))) {
                            Slog.w(TAG, "Not hiding package " + packageName + ": limited because it's gms app");
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if (filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                            Slog.w(TAG, "Cannot hide package: android");
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else {
                            PackageParser.Package pkg = this.mPackages.get(packageName);
                            if (pkg != null && pkg.staticSharedLibName != null) {
                                Slog.w(TAG, "Cannot hide package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            } else if (hidden && !UserHandle.isSameApp(callingUid, pkgSetting.appId) && this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                                Slog.w(TAG, "Not hiding protected package: " + packageName);
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            } else if (pkgSetting.getHidden(userId) != hidden) {
                                pkgSetting.setHidden(hidden, userId);
                                this.mSettings.writePackageRestrictionsLPr(userId);
                                if (hidden) {
                                    sendRemoved = true;
                                } else {
                                    sendAdded = true;
                                }
                            }
                        }
                    }
                } finally {
                    Binder.restoreCallingIdentity(callingId);
                }
            } else {
                Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
                return false;
            }
        } else {
            Slog.i(TAG, "hidePackage NeedForbidShellFunc, " + packageName + " won't be hidden");
            return false;
        }
    }

    public void setSystemAppHiddenUntilInstalled(String packageName, boolean hidden) {
        enforceSystemOrPhoneCaller("setSystemAppHiddenUntilInstalled");
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (pkgSetting.isSystem()) {
                    PackageParser.Package pkg = pkgSetting.pkg;
                    if (!(pkg == null || pkg.applicationInfo == null)) {
                        pkg.applicationInfo.hiddenUntilInstalled = hidden;
                    }
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageName);
                    if (disabledPs != null) {
                        PackageParser.Package pkg2 = disabledPs.pkg;
                        if (!(pkg2 == null || pkg2.applicationInfo == null)) {
                            pkg2.applicationInfo.hiddenUntilInstalled = hidden;
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:13:0x0026, code lost:
        r0 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x002b, code lost:
        if (r11 == false) goto L_0x003c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:?, code lost:
        installExistingPackageAsUser(r10, r12, 4194304, 3, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x003b, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x003c, code lost:
        deletePackageVersioned(new android.content.pm.VersionedPackage(r10, -1), new android.content.pm.PackageManager.LegacyPackageDeleteObserver((android.content.pm.IPackageDeleteObserver) null).getBinder(), r12, 4);
        android.os.Binder.restoreCallingIdentity(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:21:0x0054, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x0055, code lost:
        r2 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x0056, code lost:
        android.os.Binder.restoreCallingIdentity(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0059, code lost:
        throw r2;
     */
    public boolean setSystemAppInstallState(String packageName, boolean installed, int userId) {
        enforceSystemOrPhoneCaller("setSystemAppInstallState");
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (pkgSetting.isSystem()) {
                    if (pkgSetting.getInstalled(userId) == installed) {
                        return false;
                    }
                }
            }
            return false;
        }
    }

    private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        info.removedPackage = packageName;
        info.installerPackageName = pkgSetting.installerPackageName;
        info.removedUsers = new int[]{userId};
        info.broadcastUsers = new int[]{userId};
        info.uid = UserHandle.getUid(userId, pkgSetting.appId);
        info.sendPackageRemovedBroadcasts(true);
    }

    private void sendDistractingPackagesChanged(String[] pkgList, int[] uidList, int userId, int distractionFlags) {
        Bundle extras = new Bundle(3);
        extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
        extras.putIntArray("android.intent.extra.changed_uid_list", uidList);
        extras.putInt("android.intent.extra.distraction_restrictions", distractionFlags);
        sendPackageBroadcast("android.intent.action.DISTRACTING_PACKAGES_CHANGED", null, extras, 1073741824, null, null, new int[]{userId}, null);
    }

    private void sendPackagesSuspendedForUser(String[] pkgList, int[] uidList, int userId, boolean suspended, PersistableBundle launcherExtras) {
        String str;
        Bundle extras = new Bundle(3);
        extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
        extras.putIntArray("android.intent.extra.changed_uid_list", uidList);
        if (launcherExtras != null) {
            extras.putBundle("android.intent.extra.LAUNCHER_EXTRAS", new Bundle(launcherExtras.deepCopy()));
        }
        if (suspended) {
            str = "android.intent.action.PACKAGES_SUSPENDED";
        } else {
            str = "android.intent.action.PACKAGES_UNSUSPENDED";
        }
        sendPackageBroadcast(str, null, extras, 1073741824, null, null, new int[]{userId}, null);
    }

    public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, false, "getApplicationHidden for user " + userId);
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    return true;
                }
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                }
                boolean hidden = ps.getHidden(userId);
                Binder.restoreCallingIdentity(callingId);
                return hidden;
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions) {
        return installExistingPackageAsUser(packageName, userId, installFlags, installReason, whiteListedPermissions, null);
    }

    /* access modifiers changed from: package-private */
    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions, IntentSender intentSender) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "installExistingPackageAsUser package=" + packageName + " userId=" + userId + " installFlags=" + installFlags + " installReason=" + installReason + " whiteListedPermissions=" + whiteListedPermissions);
        }
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") == 0 || this.mContext.checkCallingOrSelfPermission("com.android.permission.INSTALL_EXISTING_PACKAGES") == 0) {
            return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason, whiteListedPermissions, intentSender);
        }
        throw new SecurityException("Neither user " + callingUid + " nor current process has " + "android.permission.INSTALL_PACKAGES" + ".");
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00ca, code lost:
        if (r5 == false) goto L_0x0136;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00cf, code lost:
        if ((4194304 & r24) == 0) goto L_0x00db;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x00d3, code lost:
        if (r0.pkg == null) goto L_0x00db;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x00d9, code lost:
        r7 = r0.pkg.requestedPermissions;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x00db, code lost:
        r7 = r26;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:?, code lost:
        setWhitelistedRestrictedPermissions(r22, r7, 2, r23);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x00e3, code lost:
        if (r0.pkg == null) goto L_0x00f2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x00e5, code lost:
        r14 = r21.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x00e7, code lost:
        monitor-enter(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:?, code lost:
        prepareAppDataAfterInstallLIF(r0.pkg);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x00ed, code lost:
        monitor-exit(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x00f2, code lost:
        sendPackageAddedForUser(r22, r0, r23);
        r14 = r21.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x00f7, code lost:
        monitor-enter(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:?, code lost:
        updateSequenceNumberLP(r0, new int[]{r23});
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x0101, code lost:
        monitor-exit(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0102, code lost:
        r2 = createPackageInstalledInfo(1);
        r2.pkg = r0.pkg;
        r2.newUsers = new int[]{r23};
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0115, code lost:
        if (r27 != null) goto L_0x011b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0117, code lost:
        r14 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x011b, code lost:
        r14 = new com.android.server.pm.PackageManagerService.PostInstallData(null, r2, new com.android.server.pm.$$Lambda$PackageManagerService$8FSabwMrLfv86v6b7KOV49TGXmk(r21, r2, r27));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0128, code lost:
        restoreAndPostInstall(r23, r2, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x0132, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x0134, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x013a, code lost:
        android.os.Binder.restoreCallingIdentity(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x013f, code lost:
        return 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x0149, code lost:
        r0 = th;
     */
    public int installExistingPackageAsUserInternal(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions, IntentSender intentSender) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "installExistingPackage for user " + userId);
        if (isUserRestricted(userId, "no_install_apps")) {
            return -111;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean installed = false;
        boolean instantApp = (installFlags & 2048) != 0;
        boolean fullApp = (installFlags & 16384) != 0;
        try {
            synchronized (this.mPackages) {
                try {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting == null) {
                        Binder.restoreCallingIdentity(callingId);
                        return -3;
                    }
                    if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {
                        int[] userIds = sUserManager.getUserIds();
                        int length = userIds.length;
                        boolean installAllowed = false;
                        int i = 0;
                        while (i < length) {
                            installAllowed = !pkgSetting.getInstantApp(userIds[i]);
                            if (installAllowed) {
                                break;
                            }
                            i++;
                            userIds = userIds;
                        }
                        if (!installAllowed) {
                            Binder.restoreCallingIdentity(callingId);
                            return -3;
                        }
                    }
                    if (!pkgSetting.getInstalled(userId)) {
                        pkgSetting.setInstalled(true, userId);
                        pkgSetting.setHidden(false, userId);
                        try {
                            pkgSetting.setInstallReason(installReason, userId);
                            this.mSettings.writePackageRestrictionsLPr(userId);
                            this.mSettings.writeKernelMappingLPr(pkgSetting);
                            installed = true;
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } else if (fullApp && pkgSetting.getInstantApp(userId)) {
                        installed = true;
                    }
                    try {
                        setInstantAppForUser(pkgSetting, userId, instantApp, fullApp);
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        } catch (Throwable th4) {
            th = th4;
            Binder.restoreCallingIdentity(callingId);
            throw th;
        }
        while (true) {
        }
    }

    public /* synthetic */ void lambda$installExistingPackageAsUserInternal$11$PackageManagerService(PackageInstalledInfo res, IntentSender intentSender) {
        onRestoreComplete(res.returnCode, this.mContext, intentSender);
    }

    static void onRestoreComplete(int returnCode, Context context, IntentSender target) {
        Intent fillIn = new Intent();
        fillIn.putExtra("android.content.pm.extra.STATUS", PackageManager.installStatusToPublicStatus(returnCode));
        try {
            target.sendIntent(context, 0, fillIn, null, null);
        } catch (IntentSender.SendIntentException e) {
        }
    }

    static void setInstantAppForUser(PackageSetting pkgSetting, int userId, boolean instantApp, boolean fullApp) {
        if (!instantApp && !fullApp) {
            return;
        }
        if (userId == -1) {
            int[] userIds = sUserManager.getUserIds();
            for (int currentUserId : userIds) {
                if (instantApp && !pkgSetting.getInstantApp(currentUserId)) {
                    pkgSetting.setInstantApp(true, currentUserId);
                } else if (fullApp && pkgSetting.getInstantApp(currentUserId)) {
                    pkgSetting.setInstantApp(false, currentUserId);
                }
            }
        } else if (instantApp && !pkgSetting.getInstantApp(userId)) {
            pkgSetting.setInstantApp(true, userId);
        } else if (fullApp && pkgSetting.getInstantApp(userId)) {
            pkgSetting.setInstantApp(false, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isUserRestricted(int userId, String restrictionKey) {
        if (!sUserManager.getUserRestrictions(userId).getBoolean(restrictionKey, false)) {
            return false;
        }
        Log.w(TAG, "User is restricted: " + restrictionKey);
        return true;
    }

    public String[] setDistractingPackageRestrictionsAsUser(String[] packageNames, int restrictionFlags, int userId) {
        boolean[] canRestrict;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "setDistractingPackageRestrictionsAsUser");
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000 || UserHandle.getUserId(callingUid) == userId) {
            Preconditions.checkNotNull(packageNames, "packageNames cannot be null");
            List<String> changedPackagesList = new ArrayList<>(packageNames.length);
            IntArray changedUids = new IntArray(packageNames.length);
            List<String> unactionedPackages = new ArrayList<>(packageNames.length);
            if (restrictionFlags != 0) {
                canRestrict = canSuspendPackageForUserInternal(packageNames, userId);
            } else {
                canRestrict = null;
            }
            for (int i = 0; i < packageNames.length; i++) {
                String packageName = packageNames[i];
                synchronized (this.mPackages) {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting != null) {
                        if (!filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                            if (canRestrict == null || canRestrict[i]) {
                                synchronized (this.mPackages) {
                                    if (restrictionFlags != pkgSetting.getDistractionFlags(userId)) {
                                        pkgSetting.setDistractionFlags(restrictionFlags, userId);
                                        changedPackagesList.add(packageName);
                                        changedUids.add(UserHandle.getUid(userId, pkgSetting.appId));
                                    }
                                }
                            } else {
                                unactionedPackages.add(packageName);
                            }
                        }
                    }
                    Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping...");
                    unactionedPackages.add(packageName);
                }
            }
            if (!changedPackagesList.isEmpty()) {
                sendDistractingPackagesChanged((String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]), changedUids.toArray(), userId, restrictionFlags);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(userId);
                }
            }
            return (String[]) unactionedPackages.toArray(new String[0]);
        }
        throw new SecurityException("Calling uid " + callingUid + " cannot call for user " + userId);
    }

    private void enforceCanSetPackagesSuspendedAsUser(String callingPackage, int callingUid, int userId, String callingMethod) {
        if (callingUid != 0 && callingUid != 1000) {
            String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(userId);
            boolean allowedShell = false;
            if (ownerPackage == null) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", callingMethod);
                int packageUid = getPackageUid(callingPackage, 0, userId);
                boolean allowedPackageUid = packageUid == callingUid;
                if (callingUid == 2000 && UserHandle.isSameApp(packageUid, callingUid)) {
                    allowedShell = true;
                }
                if (!allowedShell && !allowedPackageUid) {
                    throw new SecurityException("Calling package " + callingPackage + " in user " + userId + " does not belong to calling uid " + callingUid);
                }
            } else if (getPackageUid(ownerPackage, 0, userId) != callingUid) {
                throw new UnsupportedOperationException("Cannot suspend/unsuspend packages. User " + userId + " has an active DO or PO");
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:33:0x00ce, code lost:
        if (r0 == null) goto L_0x00dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x00d2, code lost:
        if (r0[r14] != false) goto L_0x00dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x00d4, code lost:
        r15.add(r13);
        r18 = r3;
        r19 = r14;
        r8 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x00dd, code lost:
        r11 = r20.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x00df, code lost:
        monitor-enter(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x00e0, code lost:
        r18 = r3;
        r19 = r14;
        r8 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:?, code lost:
        r0.setSuspended(r22, r26, r25, r23, r24, r27);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x00f9, code lost:
        monitor-exit(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x00fa, code lost:
        r0.add(r13);
        r0.add(android.os.UserHandle.getUid(r27, r0.appId));
     */
    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended, PersistableBundle appExtras, PersistableBundle launcherExtras, SuspendDialogInfo dialogInfo, String callingPackage, int userId) {
        boolean[] canSuspend;
        int i;
        int callingUid;
        List<String> unactionedPackages;
        String packageName;
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx;
        String[] strArr = packageNames;
        String str = callingPackage;
        int callingUid2 = Binder.getCallingUid();
        enforceCanSetPackagesSuspendedAsUser(str, callingUid2, userId, "setPackagesSuspendedAsUser");
        if (ArrayUtils.isEmpty(packageNames)) {
            return strArr;
        }
        List<String> changedPackagesList = new ArrayList<>(strArr.length);
        IntArray changedUids = new IntArray(strArr.length);
        List<String> unactionedPackages2 = new ArrayList<>(strArr.length);
        if (suspended) {
            canSuspend = canSuspendPackageForUserInternal(strArr, userId);
        } else {
            canSuspend = null;
        }
        int i2 = 0;
        while (i2 < strArr.length) {
            String packageName2 = strArr[i2];
            if (suspended && (iHwPackageManagerServiceEx = mHwPMSEx) != null && iHwPackageManagerServiceEx.isNeedForbidShellFunc(packageName2)) {
                unactionedPackages2.add(packageName2);
                Slog.i(TAG, "suspendPackage NeedForbidShellFunc, " + packageName2 + " won't be suspend");
                callingUid = callingUid2;
                i = i2;
                unactionedPackages = unactionedPackages2;
            } else if (str.equals(packageName2)) {
                StringBuilder sb = new StringBuilder();
                sb.append("Calling package: ");
                sb.append(str);
                sb.append(" trying to ");
                sb.append(suspended ? "" : "un");
                sb.append("suspend itself. Ignoring");
                Slog.w(TAG, sb.toString());
                unactionedPackages2.add(packageName2);
                callingUid = callingUid2;
                i = i2;
                unactionedPackages = unactionedPackages2;
            } else {
                synchronized (this.mPackages) {
                    try {
                        PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName2);
                        if (pkgSetting == null) {
                            callingUid = callingUid2;
                            packageName = packageName2;
                            i = i2;
                            unactionedPackages = unactionedPackages2;
                        } else if (filterAppAccessLPr(pkgSetting, callingUid2, userId)) {
                            callingUid = callingUid2;
                            packageName = packageName2;
                            i = i2;
                            unactionedPackages = unactionedPackages2;
                        }
                        Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping suspending/un-suspending.");
                        unactionedPackages.add(packageName);
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                }
            }
            i2 = i + 1;
            str = callingPackage;
            unactionedPackages2 = unactionedPackages;
            callingUid2 = callingUid;
            strArr = packageNames;
        }
        if (!changedPackagesList.isEmpty()) {
            String[] changedPackages = (String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]);
            sendPackagesSuspendedForUser(changedPackages, changedUids.toArray(), userId, suspended, launcherExtras);
            sendMyPackageSuspendedOrUnsuspended(changedPackages, suspended, appExtras, userId);
            synchronized (this.mPackages) {
                scheduleWritePackageRestrictionsLocked(userId);
            }
        }
        return (String[]) unactionedPackages2.toArray(new String[unactionedPackages2.size()]);
    }

    public PersistableBundle getSuspendedPackageAppExtras(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getPackageUid(packageName, 0, userId) == callingUid) {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new IllegalArgumentException("Unknown target package: " + packageName);
                }
                PackageUserState packageUserState = ps.readUserState(userId);
                if (!packageUserState.suspended) {
                    return null;
                }
                return packageUserState.suspendedAppExtras;
            }
        }
        throw new SecurityException("Calling package " + packageName + " does not belong to calling uid " + callingUid);
    }

    private void sendMyPackageSuspendedOrUnsuspended(String[] affectedPackages, boolean suspended, PersistableBundle appExtras, int userId) {
        String action;
        Bundle intentExtras = new Bundle();
        if (suspended) {
            if (appExtras != null) {
                intentExtras.putBundle("android.intent.extra.SUSPENDED_PACKAGE_EXTRAS", new Bundle(appExtras.deepCopy()));
            }
            action = "android.intent.action.MY_PACKAGE_SUSPENDED";
        } else {
            action = "android.intent.action.MY_PACKAGE_UNSUSPENDED";
        }
        this.mHandler.post(new Runnable(suspended, userId, affectedPackages, action, intentExtras) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$lmWx5KdKJSi601pB8nl6c_pFRXI */
            private final /* synthetic */ boolean f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ String[] f$3;
            private final /* synthetic */ String f$4;
            private final /* synthetic */ Bundle f$5;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$sendMyPackageSuspendedOrUnsuspended$12$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
            }
        });
    }

    public /* synthetic */ void lambda$sendMyPackageSuspendedOrUnsuspended$12$PackageManagerService(boolean suspended, int userId, String[] affectedPackages, String action, Bundle intentExtras) {
        try {
            IActivityManager am = ActivityManager.getService();
            if (am == null) {
                StringBuilder sb = new StringBuilder();
                sb.append("IActivityManager null. Cannot send MY_PACKAGE_ ");
                sb.append(suspended ? "" : "UN");
                sb.append("SUSPENDED broadcasts");
                Slog.wtf(TAG, sb.toString());
                return;
            }
            int[] targetUserIds = {userId};
            for (String packageName : affectedPackages) {
                doSendBroadcast(am, action, null, intentExtras, DumpState.DUMP_SERVICE_PERMISSIONS, packageName, null, targetUserIds, false);
            }
        } catch (RemoteException e) {
        }
    }

    public boolean isPackageSuspendedForUser(String packageName, int userId) {
        boolean suspended;
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, false, "isPackageSuspendedForUser for user " + userId);
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                throw new IllegalArgumentException("Unknown target package: " + packageName);
            }
            suspended = ps.getSuspended(userId);
        }
        return suspended;
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForSuspendingPackage(String packageName, int affectedUser) {
        int[] userIds = affectedUser == -1 ? sUserManager.getUserIds() : new int[]{affectedUser};
        for (int userId : userIds) {
            Objects.requireNonNull(packageName);
            unsuspendForSuspendingPackages(new Predicate(packageName) {
                /* class com.android.server.pm.$$Lambda$S4BXTl5Ly3EHhXAReFCtlz2B8eo */
                private final /* synthetic */ String f$0;

                {
                    this.f$0 = r1;
                }

                @Override // java.util.function.Predicate
                public final boolean test(Object obj) {
                    return this.f$0.equals((String) obj);
                }
            }, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForNonSystemSuspendingPackages(ArraySet<Integer> userIds) {
        int sz = userIds.size();
        for (int i = 0; i < sz; i++) {
            unsuspendForSuspendingPackages($$Lambda$PackageManagerService$8F_cRTr5jDNmLElQPCCP6cIQBH4.INSTANCE, userIds.valueAt(i).intValue());
        }
    }

    static /* synthetic */ boolean lambda$unsuspendForNonSystemSuspendingPackages$13(String suspendingPackage) {
        return !PLATFORM_PACKAGE_NAME.equals(suspendingPackage);
    }

    private void unsuspendForSuspendingPackages(Predicate<String> packagePredicate, int userId) {
        List<String> affectedPackages = new ArrayList<>();
        IntArray affectedUids = new IntArray();
        synchronized (this.mPackages) {
            for (PackageSetting ps : this.mSettings.mPackages.values()) {
                PackageUserState pus = ps.readUserState(userId);
                if (pus.suspended && packagePredicate.test(pus.suspendingPackage)) {
                    ps.setSuspended(false, null, null, null, null, userId);
                    affectedPackages.add(ps.name);
                    affectedUids.add(UserHandle.getUid(userId, ps.getAppId()));
                }
            }
        }
        if (!affectedPackages.isEmpty()) {
            String[] packageArray = (String[]) affectedPackages.toArray(new String[affectedPackages.size()]);
            sendMyPackageSuspendedOrUnsuspended(packageArray, false, null, userId);
            sendPackagesSuspendedForUser(packageArray, affectedUids.toArray(), userId, false, null);
            this.mSettings.writePackageRestrictionsLPr(userId);
        }
    }

    public String[] getUnsuspendablePackagesForUser(String[] packageNames, int userId) {
        Preconditions.checkNotNull("packageNames cannot be null", packageNames);
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "getUnsuspendablePackagesForUser");
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) == userId) {
            ArraySet<String> unactionablePackages = new ArraySet<>();
            boolean[] canSuspend = canSuspendPackageForUserInternal(packageNames, userId);
            for (int i = 0; i < packageNames.length; i++) {
                if (!canSuspend[i]) {
                    unactionablePackages.add(packageNames[i]);
                }
            }
            return (String[]) unactionablePackages.toArray(new String[unactionablePackages.size()]);
        }
        throw new SecurityException("Calling uid " + callingUid + " cannot query getUnsuspendablePackagesForUser for user " + userId);
    }

    private boolean[] canSuspendPackageForUserInternal(String[] packageNames, int userId) {
        boolean[] canSuspend = new boolean[packageNames.length];
        long callingId = Binder.clearCallingIdentity();
        try {
            String activeLauncherPackageName = getActiveLauncherPackageName(userId);
            String dialerPackageName = getDefaultDialerPackageName(userId);
            for (int i = 0; i < packageNames.length; i++) {
                canSuspend[i] = false;
                String packageName = packageNames[i];
                if (isPackageDeviceAdmin(packageName, userId)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": has an active device admin");
                } else if (packageName.equals(activeLauncherPackageName)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": contains the active launcher");
                } else if (packageName.equals(this.mRequiredInstallerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package installation");
                } else if (packageName.equals(this.mRequiredUninstallerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package uninstallation");
                } else if (packageName.equals(this.mRequiredVerifierPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package verification");
                } else if (packageName.equals(dialerPackageName)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": is the default dialer");
                } else if (packageName.equals(this.mRequiredPermissionControllerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for permissions management");
                } else {
                    synchronized (this.mPackages) {
                        if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": protected package");
                        } else {
                            PackageParser.Package pkg = this.mPackages.get(packageName);
                            if (pkg != null && pkg.applicationInfo.isStaticSharedLibrary()) {
                                Slog.w(TAG, "Cannot suspend package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                            } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                                Slog.w(TAG, "Cannot suspend the platform package: " + packageName);
                            } else {
                                canSuspend[i] = true;
                            }
                        }
                    }
                }
            }
            return canSuspend;
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private String getActiveLauncherPackageName(int userId) {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        ResolveInfo resolveInfo = resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 65536, userId);
        if (resolveInfo == null) {
            return null;
        }
        return resolveInfo.activityInfo.packageName;
    }

    private String getDefaultDialerPackageName(int userId) {
        PackageManagerInternal.DefaultDialerProvider provider;
        synchronized (this.mPackages) {
            provider = this.mDefaultDialerProvider;
        }
        if (provider != null) {
            return provider.getDefaultDialer(userId);
        }
        Slog.e(TAG, "mDefaultDialerProvider is null");
        return null;
    }

    public void verifyPendingInstall(int id, int verificationCode) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(15);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCode, Binder.getCallingUid());
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can extend verification timeouts");
        PackageVerificationState state = this.mPendingVerification.get(id);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCodeAtTimeout, Binder.getCallingUid());
        if (millisecondsToDelay > AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT) {
            millisecondsToDelay = AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT;
        }
        if (millisecondsToDelay < 0) {
            millisecondsToDelay = 0;
        }
        if (!(verificationCodeAtTimeout == 1 || verificationCodeAtTimeout == -1)) {
        }
        if (state != null && !state.timeoutExtended()) {
            state.extendTimeout();
            Message msg = this.mHandler.obtainMessage(15);
            msg.arg1 = id;
            msg.obj = response;
            this.mHandler.sendMessageDelayed(msg, millisecondsToDelay);
        }
    }

    /* access modifiers changed from: private */
    public void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) {
        Intent intent = new Intent("android.intent.action.PACKAGE_VERIFIED");
        intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE);
        intent.addFlags(1);
        intent.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
        intent.putExtra("android.content.pm.extra.VERIFICATION_RESULT", verificationCode);
        this.mContext.sendBroadcastAsUser(intent, user, "android.permission.PACKAGE_VERIFICATION_AGENT");
    }

    /* access modifiers changed from: private */
    public ComponentName matchComponentForVerifier(String packageName, List<ResolveInfo> receivers) {
        ActivityInfo targetReceiver = null;
        int NR = receivers.size();
        int i = 0;
        while (true) {
            if (i >= NR) {
                break;
            }
            ResolveInfo info = receivers.get(i);
            if (info.activityInfo != null && packageName.equals(info.activityInfo.packageName)) {
                targetReceiver = info.activityInfo;
                break;
            }
            i++;
        }
        if (targetReceiver == null) {
            return null;
        }
        return new ComponentName(targetReceiver.packageName, targetReceiver.name);
    }

    /* access modifiers changed from: private */
    public List<ComponentName> matchVerifiers(PackageInfoLite pkgInfo, List<ResolveInfo> receivers, PackageVerificationState verificationState) {
        int verifierUid;
        if (pkgInfo.verifiers.length == 0) {
            return null;
        }
        int N = pkgInfo.verifiers.length;
        List<ComponentName> sufficientVerifiers = new ArrayList<>(N + 1);
        for (int i = 0; i < N; i++) {
            VerifierInfo verifierInfo = pkgInfo.verifiers[i];
            ComponentName comp = matchComponentForVerifier(verifierInfo.packageName, receivers);
            if (!(comp == null || (verifierUid = getUidForVerifier(verifierInfo)) == -1)) {
                if (DEBUG_VERIFY) {
                    Slog.d(TAG, "Added sufficient verifier " + verifierInfo.packageName + " with the correct signature");
                }
                sufficientVerifiers.add(comp);
                verificationState.addSufficientVerifier(verifierUid);
            }
        }
        return sufficientVerifiers;
    }

    private int getUidForVerifier(VerifierInfo verifierInfo) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(verifierInfo.packageName);
            if (pkg == null) {
                return -1;
            }
            if (pkg.mSigningDetails.signatures.length != 1) {
                Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " has more than one signature; ignoring");
                return -1;
            }
            try {
                if (!Arrays.equals(verifierInfo.publicKey.getEncoded(), pkg.mSigningDetails.signatures[0].getPublicKey().getEncoded())) {
                    Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " does not have the expected public key; ignoring");
                    return -1;
                }
                return pkg.applicationInfo.uid;
            } catch (CertificateException e) {
                return -1;
            }
        }
    }

    /* access modifiers changed from: private */
    public void setEnableRollbackCode(int token, int enableRollbackCode) {
        Message msg = this.mHandler.obtainMessage(21);
        msg.arg1 = token;
        msg.arg2 = enableRollbackCode;
        this.mHandler.sendMessage(msg);
    }

    public void finishPackageInstall(int token, boolean didLaunch) {
        enforceSystemOrRoot("Only the system is allowed to finish installs");
        if (DEBUG_INSTALL) {
            Slog.v(TAG, "BM finishing package install for " + token);
        }
        Trace.asyncTraceEnd(262144, "restore", token);
        this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, didLaunch ? 1 : 0));
    }

    /* access modifiers changed from: private */
    public long getVerificationTimeout() {
        return Settings.Global.getLong(this.mContext.getContentResolver(), "verifier_timeout", JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
    }

    /* access modifiers changed from: private */
    public int getDefaultVerificationResponse(UserHandle user) {
        if (sUserManager.hasUserRestriction("ensure_verify_apps", user.getIdentifier())) {
            return -1;
        }
        return Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_default_response", 1);
    }

    /* access modifiers changed from: private */
    public boolean isVerificationEnabled(int userId, int installFlags, int installerUid) {
        ActivityInfo activityInfo;
        if ((524288 & installFlags) != 0) {
            return false;
        }
        boolean ensureVerifyAppsEnabled = isUserRestricted(userId, "ensure_verify_apps");
        if ((installFlags & 32) != 0) {
            if (ActivityManager.isRunningInTestHarness()) {
                return false;
            }
            if (ensureVerifyAppsEnabled) {
                return true;
            }
            if (Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_verify_adb_installs", 1) == 0) {
                return false;
            }
        } else if (!((installFlags & 2048) == 0 || (activityInfo = this.mInstantAppInstallerActivity) == null || !activityInfo.packageName.equals(this.mRequiredVerifierPackage))) {
            try {
                ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(installerUid, this.mRequiredVerifierPackage);
                if (DEBUG_VERIFY) {
                    Slog.i(TAG, "disable verification for instant app");
                }
                return false;
            } catch (SecurityException e) {
            }
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        if (Settings.Global.getInt(this.mContext.getContentResolver(), "package_verifier_enable", 1) == 1) {
            return true;
        }
        return false;
    }

    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", "Only intentfilter verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(18);
        IntentFilterVerificationResponse response = new IntentFilterVerificationResponse(Binder.getCallingUid(), verificationCode, failedDomains);
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public int getIntentVerificationStatus(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getIntentVerificationStatus" + userId);
        }
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                }
            }
            return 0;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x002f, code lost:
        if (r3 == false) goto L_0x0034;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0031, code lost:
        scheduleWritePackageRestrictionsLocked(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0034, code lost:
        return r3;
     */
    public boolean updateIntentVerificationStatus(String packageName, int status, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            boolean result = this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, status, userId);
        }
    }

    public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                return ParceledListSlice.emptyList();
            }
            return new ParceledListSlice<>(this.mSettings.getIntentFilterVerificationsLPr(packageName));
        }
    }

    public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
        if (TextUtils.isEmpty(packageName)) {
            return ParceledListSlice.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg != null) {
                if (pkg.activities != null) {
                    if (pkg.mExtras == null) {
                        return ParceledListSlice.emptyList();
                    } else if (filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                        return ParceledListSlice.emptyList();
                    } else {
                        int count = pkg.activities.size();
                        ArrayList<IntentFilter> result = new ArrayList<>();
                        for (int n = 0; n < count; n++) {
                            PackageParser.Activity activity = (PackageParser.Activity) pkg.activities.get(n);
                            if (activity.intents != null && activity.intents.size() > 0) {
                                result.addAll(activity.intents);
                            }
                        }
                        return new ParceledListSlice<>(result);
                    }
                }
            }
            return ParceledListSlice.emptyList();
        }
    }

    public boolean setDefaultBrowserPackageName(String packageName, int userId) {
        PackageManagerInternal.DefaultBrowserProvider provider;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (userId == -1) {
            return false;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultBrowserProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "mDefaultBrowserProvider is null");
            return false;
        } else if (!provider.setDefaultBrowser(packageName, userId)) {
            return false;
        } else {
            if (packageName == null) {
                return true;
            }
            synchronized (this.mPackages) {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
            }
            return true;
        }
    }

    private void setDefaultBrowserAsyncLPw(String packageName, int userId) {
        if (userId != -1) {
            PackageManagerInternal.DefaultBrowserProvider defaultBrowserProvider = this.mDefaultBrowserProvider;
            if (defaultBrowserProvider == null) {
                Slog.e(TAG, "mDefaultBrowserProvider is null");
                return;
            }
            defaultBrowserProvider.setDefaultBrowserAsync(packageName, userId);
            if (packageName != null) {
                synchronized (this.mPackages) {
                    this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
                }
            }
        }
    }

    public String getDefaultBrowserPackageName(int userId) {
        PackageManagerInternal.DefaultBrowserProvider provider;
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultBrowserProvider;
        }
        if (provider != null) {
            return provider.getDefaultBrowser(userId);
        }
        Slog.e(TAG, "mDefaultBrowserProvider is null");
        return null;
    }

    private int getUnknownSourcesSettings() {
        return Settings.Secure.getInt(this.mContext.getContentResolver(), "install_non_market_apps", -1);
    }

    public void setInstallerPackageName(String targetPackage, String installerPackageName) {
        PackageSetting installerPackageSetting;
        Signature[] callerSignature;
        PackageSetting setting;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageSetting targetPackageSetting = this.mSettings.mPackages.get(targetPackage);
                if (targetPackageSetting == null || filterAppAccessLPr(targetPackageSetting, callingUid, UserHandle.getUserId(callingUid))) {
                    throw new IllegalArgumentException("Unknown target package: " + targetPackage);
                }
                if (installerPackageName != null) {
                    installerPackageSetting = this.mSettings.mPackages.get(installerPackageName);
                    if (installerPackageSetting == null) {
                        throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
                    }
                } else {
                    installerPackageSetting = null;
                }
                Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(callingUid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        callerSignature = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                    } else if (obj instanceof PackageSetting) {
                        callerSignature = ((PackageSetting) obj).signatures.mSigningDetails.signatures;
                    } else {
                        throw new SecurityException("Bad object " + obj + " for uid " + callingUid);
                    }
                    if (installerPackageSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, installerPackageSetting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
                        }
                    }
                    if (!(targetPackageSetting.installerPackageName == null || (setting = this.mSettings.mPackages.get(targetPackageSetting.installerPackageName)) == null)) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, setting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as old installer package " + targetPackageSetting.installerPackageName);
                        }
                    }
                    targetPackageSetting.installerPackageName = installerPackageName;
                    if (installerPackageName != null) {
                        this.mSettings.mInstallerPackages.add(installerPackageName);
                    }
                    scheduleWriteSettingsLocked();
                } else {
                    throw new SecurityException("Unknown calling UID: " + callingUid);
                }
            }
        }
    }

    public void setApplicationCategoryHint(String packageName, int categoryHint, String callerPackageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(Binder.getCallingUid(), callerPackageName);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (!Objects.equals(callerPackageName, ps.installerPackageName)) {
                    throw new IllegalArgumentException("Calling package " + callerPackageName + " is not installer for " + packageName);
                } else if (ps.categoryHint != categoryHint) {
                    ps.categoryHint = categoryHint;
                    scheduleWriteSettingsLocked();
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* access modifiers changed from: private */
    public void processPendingInstall(InstallArgs args, int currentStatus) {
        if (args.mMultiPackageInstallParams != null) {
            args.mMultiPackageInstallParams.tryProcessInstallRequest(args, currentStatus);
            return;
        }
        PackageInstalledInfo res = createPackageInstalledInfo(currentStatus);
        boolean z = true;
        if (res.returnCode != 1) {
            z = false;
        }
        processInstallRequestsAsync(z, Collections.singletonList(new InstallRequest(args, res)));
    }

    /* access modifiers changed from: private */
    public void processInstallRequestsAsync(boolean success, List<InstallRequest> installRequests) {
        this.mHandler.post(new Runnable(success, installRequests) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$6_Yp7BSB4TgtrWSoFlODKgHIvZY */
            private final /* synthetic */ boolean f$1;
            private final /* synthetic */ List f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$processInstallRequestsAsync$14$PackageManagerService(this.f$1, this.f$2);
            }
        });
    }

    public /* synthetic */ void lambda$processInstallRequestsAsync$14$PackageManagerService(boolean success, List installRequests) {
        if (success) {
            long installBeginTime = SystemClock.elapsedRealtime();
            Iterator it = installRequests.iterator();
            while (it.hasNext()) {
                InstallRequest request = (InstallRequest) it.next();
                request.args.doPreInstall(request.installResult.returnCode);
            }
            synchronized (this.mInstallLock) {
                installPackagesTracedLI(installRequests);
            }
            Iterator it2 = installRequests.iterator();
            while (it2.hasNext()) {
                InstallRequest request2 = (InstallRequest) it2.next();
                PackageParser.Package pkg = request2.installResult.pkg;
                String pkgName = null;
                if (pkg != null) {
                    pkgName = pkg.packageName;
                }
                if (pkgName != null) {
                    InstallerMgr.getInstance().installPackage(1, request2.args.installerPackageName, pkgName);
                }
            }
            Iterator it3 = installRequests.iterator();
            while (it3.hasNext()) {
                InstallRequest request3 = (InstallRequest) it3.next();
                request3.args.doPostInstall(request3.installResult.returnCode, request3.installResult.uid);
                if (request3.installResult.returnCode == 1) {
                    PackageParser.Package pkg2 = request3.installResult.pkg;
                    String pkgName2 = null;
                    if (pkg2 != null) {
                        pkgName2 = pkg2.packageName;
                    }
                    if (pkgName2 != null) {
                        mHwPMSEx.recordInstallAppInfo(pkgName2, installBeginTime, 0);
                    }
                }
            }
        }
        Iterator it4 = installRequests.iterator();
        while (it4.hasNext()) {
            InstallRequest request4 = (InstallRequest) it4.next();
            restoreAndPostInstall(request4.args.user.getIdentifier(), request4.installResult, new PostInstallData(request4.args, request4.installResult, null));
        }
    }

    /* access modifiers changed from: private */
    public PackageInstalledInfo createPackageInstalledInfo(int currentStatus) {
        PackageInstalledInfo res = new PackageInstalledInfo();
        res.setReturnCode(currentStatus);
        res.uid = -1;
        res.pkg = null;
        res.removedInfo = null;
        return res;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:78:0x016b, code lost:
        r5 = 262144;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:?, code lost:
        r19.snapshotAndRestoreUserData(r12, r0, r21, r22, r11, r9);
     */
    /* JADX WARNING: Removed duplicated region for block: B:103:? A[RETURN, SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:95:0x01ae  */
    private void restoreAndPostInstall(int userId, PackageInstalledInfo res, PostInstallData data) {
        int userId2;
        long j;
        long ceDataInode;
        int appId;
        int userId3;
        if (!(!DEBUG_INSTALL || res == null || res.pkg == null)) {
            Log.v(TAG, "restoreAndPostInstall userId=" + userId + " package=" + res.pkg.packageName);
        }
        boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
        boolean doRestore = !update && (32768 & (res.pkg == null ? 0 : res.pkg.applicationInfo.flags)) != 0;
        if (this.mNextInstallToken < 0) {
            this.mNextInstallToken = 1;
        }
        int token = this.mNextInstallToken;
        this.mNextInstallToken = token + 1;
        if (data != null) {
            this.mRunningInstalls.put(token, data);
        } else if (DEBUG_INSTALL) {
            Log.v(TAG, "No post-install required for " + token);
        }
        if (DEBUG_INSTALL) {
            Log.v(TAG, "+ starting restore round-trip " + token);
        }
        if (res.returnCode != 1 || !doRestore) {
            userId2 = userId;
        } else {
            IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
            if (bm != null) {
                if (userId == -1) {
                    userId3 = 0;
                } else {
                    userId3 = userId;
                }
                if (DEBUG_INSTALL) {
                    Log.v(TAG, "token " + token + " to BM for possible restore for user " + userId3);
                }
                Trace.asyncTraceBegin(262144, "restore", token);
                try {
                    if (bm.isBackupServiceActive(userId3)) {
                        bm.restoreAtInstallForUser(userId3, res.pkg.applicationInfo.packageName, token);
                    } else {
                        doRestore = false;
                    }
                } catch (RemoteException e) {
                } catch (Exception e2) {
                    Slog.e(TAG, "Exception trying to enqueue restore", e2);
                    doRestore = false;
                }
                userId2 = userId3;
            } else {
                Slog.e(TAG, "Backup Manager not found!");
                doRestore = false;
                userId2 = userId;
            }
        }
        if (res.returnCode != 1 || doRestore || !update) {
            j = 262144;
        } else {
            IRollbackManager rm = IRollbackManager.Stub.asInterface(ServiceManager.getService("rollback"));
            String packageName = res.pkg.applicationInfo.packageName;
            String seInfo = res.pkg.applicationInfo.seInfo;
            int[] allUsers = sUserManager.getUserIds();
            synchronized (this.mSettings) {
                try {
                    PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                    if (ps != null) {
                        try {
                            appId = ps.appId;
                            ceDataInode = ps.getCeDataInode(userId2);
                        } catch (Throwable th) {
                            th = th;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th2) {
                                    th = th2;
                                }
                            }
                            throw th;
                        }
                    } else {
                        appId = -1;
                        ceDataInode = -1;
                    }
                    try {
                        int[] installedUsers = ps.queryInstalledUsers(allUsers, true);
                        try {
                        } catch (Throwable th3) {
                            th = th3;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } catch (Throwable th4) {
                        th = th4;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                } catch (Throwable th5) {
                    th = th5;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        }
        if (doRestore) {
            if (DEBUG_INSTALL) {
                Log.v(TAG, "No restore - queue post-install for " + token);
            }
            Trace.asyncTraceBegin(j, "postInstall", token);
            this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, 0));
            return;
        }
        return;
        doRestore = true;
        if (doRestore) {
        }
    }

    /* access modifiers changed from: package-private */
    public void notifyFirstLaunch(String packageName, String installerPackage, int userId) {
        this.mHandler.post(new Runnable(packageName, userId, installerPackage) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$SxjjyVM6HSS7vYvHTON2BdU4enc */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ String f$3;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
            }

            public final void run() {
                PackageManagerService.this.lambda$notifyFirstLaunch$15$PackageManagerService(this.f$1, this.f$2, this.f$3);
            }
        });
    }

    public /* synthetic */ void lambda$notifyFirstLaunch$15$PackageManagerService(String packageName, int userId, String installerPackage) {
        for (int i = 0; i < this.mRunningInstalls.size(); i++) {
            PostInstallData data = this.mRunningInstalls.valueAt(i);
            if (data.res.returnCode == 1 && packageName.equals(data.res.pkg.applicationInfo.packageName)) {
                int uIndex = 0;
                while (uIndex < data.res.newUsers.length) {
                    if (userId != data.res.newUsers[uIndex]) {
                        uIndex++;
                    } else if (DEBUG_BACKUP) {
                        Slog.i(TAG, "Package " + packageName + " being restored so deferring FIRST_LAUNCH");
                        return;
                    } else {
                        return;
                    }
                }
                continue;
            }
        }
        if (DEBUG_BACKUP) {
            Slog.i(TAG, "Package " + packageName + " sending normal FIRST_LAUNCH");
        }
        boolean isInstantApp = isInstantApp(packageName, userId);
        sendFirstLaunchBroadcast(packageName, installerPackage, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    private void sendFirstLaunchBroadcast(String pkgName, String installerPkg, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast("android.intent.action.PACKAGE_FIRST_LAUNCH", pkgName, null, 0, installerPkg, null, userIds, instantUserIds);
    }

    private abstract class HandlerParams {
        private final UserHandle mUser;
        int traceCookie;
        String traceMethod;

        /* access modifiers changed from: package-private */
        public abstract void handleReturnCode();

        /* access modifiers changed from: package-private */
        public abstract void handleStartCopy();

        HandlerParams(UserHandle user) {
            this.mUser = user;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getRollbackUser() {
            if (this.mUser == UserHandle.ALL) {
                return UserHandle.SYSTEM;
            }
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceMethod(String traceMethod2) {
            this.traceMethod = traceMethod2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceCookie(int traceCookie2) {
            this.traceCookie = traceCookie2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public final void startCopy() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.i(PackageManagerService.TAG, "startCopy " + this.mUser + ": " + this);
            }
            handleStartCopy();
            handleReturnCode();
        }
    }

    static class OriginInfo {
        final boolean existing;
        final File file;
        final File resolvedFile;
        final String resolvedPath;
        final boolean staged;

        static OriginInfo fromNothing() {
            return new OriginInfo(null, false, false);
        }

        static OriginInfo fromUntrustedFile(File file2) {
            return new OriginInfo(file2, false, false);
        }

        static OriginInfo fromExistingFile(File file2) {
            return new OriginInfo(file2, false, true);
        }

        static OriginInfo fromStagedFile(File file2) {
            return new OriginInfo(file2, true, false);
        }

        private OriginInfo(File file2, boolean staged2, boolean existing2) {
            this.file = file2;
            this.staged = staged2;
            this.existing = existing2;
            if (file2 != null) {
                this.resolvedPath = file2.getAbsolutePath();
                this.resolvedFile = file2;
                return;
            }
            this.resolvedPath = null;
            this.resolvedFile = null;
        }
    }

    static class MoveInfo {
        final int appId;
        final String dataAppName;
        final String fromUuid;
        final int moveId;
        final String packageName;
        final String seinfo;
        final int targetSdkVersion;
        final String toUuid;

        public MoveInfo(int moveId2, String fromUuid2, String toUuid2, String packageName2, String dataAppName2, int appId2, String seinfo2, int targetSdkVersion2) {
            this.moveId = moveId2;
            this.fromUuid = fromUuid2;
            this.toUuid = toUuid2;
            this.packageName = packageName2;
            this.dataAppName = dataAppName2;
            this.appId = appId2;
            this.seinfo = seinfo2;
            this.targetSdkVersion = targetSdkVersion2;
        }
    }

    static class VerificationInfo {
        public static final int NO_UID = -1;
        final int installerUid;
        final int originatingUid;
        final Uri originatingUri;
        final Uri referrer;

        VerificationInfo(Uri originatingUri2, Uri referrer2, int originatingUid2, int installerUid2) {
            this.originatingUri = originatingUri2;
            this.referrer = referrer2;
            this.originatingUid = originatingUid2;
            this.installerUid = installerUid2;
        }
    }

    class MultiPackageInstallParams extends HandlerParams {
        private final ArrayList<InstallParams> mChildParams;
        private final Map<InstallArgs, Integer> mCurrentState;
        private int mRet = 1;

        MultiPackageInstallParams(UserHandle user, List<ActiveInstallSession> activeInstallSessions) throws PackageManagerException {
            super(user);
            if (activeInstallSessions.size() != 0) {
                this.mChildParams = new ArrayList<>(activeInstallSessions.size());
                for (int i = 0; i < activeInstallSessions.size(); i++) {
                    InstallParams childParams = new InstallParams(activeInstallSessions.get(i));
                    childParams.mParentInstallParams = this;
                    this.mChildParams.add(childParams);
                }
                this.mCurrentState = new ArrayMap(this.mChildParams.size());
                return;
            }
            throw new PackageManagerException("No child sessions found!");
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleStartCopy() {
            Iterator<InstallParams> it = this.mChildParams.iterator();
            while (it.hasNext()) {
                InstallParams params = it.next();
                params.handleStartCopy();
                if (params.mRet != 1) {
                    this.mRet = params.mRet;
                }
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleReturnCode() {
            Iterator<InstallParams> it = this.mChildParams.iterator();
            while (it.hasNext()) {
                InstallParams params = it.next();
                params.handleReturnCode();
                if (params.mRet != 1) {
                    this.mRet = params.mRet;
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void tryProcessInstallRequest(InstallArgs args, int currentStatus) {
            boolean z;
            this.mCurrentState.put(args, Integer.valueOf(currentStatus));
            if (this.mCurrentState.size() == this.mChildParams.size()) {
                int completeStatus = 1;
                Iterator<Integer> it = this.mCurrentState.values().iterator();
                while (true) {
                    z = true;
                    if (!it.hasNext()) {
                        break;
                    }
                    Integer status = it.next();
                    if (status.intValue() != 0) {
                        if (status.intValue() != 1) {
                            completeStatus = status.intValue();
                            break;
                        }
                    } else {
                        return;
                    }
                }
                List<InstallRequest> installRequests = new ArrayList<>(this.mCurrentState.size());
                for (Map.Entry<InstallArgs, Integer> entry : this.mCurrentState.entrySet()) {
                    installRequests.add(new InstallRequest(entry.getKey(), PackageManagerService.this.createPackageInstalledInfo(completeStatus)));
                }
                PackageManagerService packageManagerService = PackageManagerService.this;
                if (completeStatus != 1) {
                    z = false;
                }
                packageManagerService.processInstallRequestsAsync(z, installRequests);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public class InstallParams extends HandlerParams {
        final List<String> addSplitList;
        final String[] grantedRuntimePermissions;
        int installFlags;
        final int installReason;
        final String installerPackageName;
        /* access modifiers changed from: private */
        public InstallArgs mArgs;
        private boolean mEnableRollbackCompleted;
        MultiPackageInstallParams mParentInstallParams;
        int mRet;
        private boolean mVerificationCompleted;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final String packageAbiOverride;
        final List<String> removeSplitList;
        final long requiredInstalledVersionCode;
        final PackageParser.SigningDetails signingDetails;
        final VerificationInfo verificationInfo;
        final String volumeUuid;
        final List<String> whitelistedRestrictedPermissions;

        InstallParams(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, VerificationInfo verificationInfo2, UserHandle user, String packageAbiOverride2, String[] grantedPermissions, List<String> whitelistedRestrictedPermissions2, PackageParser.SigningDetails signingDetails2, int installReason2, long requiredInstalledVersionCode2) {
            super(user);
            this.origin = origin2;
            this.move = move2;
            this.observer = observer2;
            this.installFlags = installFlags2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.verificationInfo = verificationInfo2;
            this.packageAbiOverride = packageAbiOverride2;
            this.grantedRuntimePermissions = grantedPermissions;
            this.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
            this.requiredInstalledVersionCode = requiredInstalledVersionCode2;
            this.removeSplitList = null;
            this.addSplitList = null;
        }

        InstallParams(ActiveInstallSession activeInstallSession) {
            super(activeInstallSession.getUser());
            if (PackageManagerService.DEBUG_INSTANT && (activeInstallSession.getSessionParams().installFlags & 2048) != 0) {
                Slog.d(PackageManagerService.TAG, "Ephemeral install of " + activeInstallSession.getPackageName());
            }
            this.verificationInfo = new VerificationInfo(activeInstallSession.getSessionParams().originatingUri, activeInstallSession.getSessionParams().referrerUri, activeInstallSession.getSessionParams().originatingUid, activeInstallSession.getInstallerUid());
            this.origin = OriginInfo.fromStagedFile(activeInstallSession.getStagedDir());
            this.move = null;
            this.installReason = PackageManagerService.this.fixUpInstallReason(activeInstallSession.getInstallerPackageName(), activeInstallSession.getInstallerUid(), activeInstallSession.getSessionParams().installReason);
            this.observer = activeInstallSession.getObserver();
            this.installFlags = activeInstallSession.getSessionParams().installFlags;
            this.installerPackageName = activeInstallSession.getInstallerPackageName();
            this.volumeUuid = activeInstallSession.getSessionParams().volumeUuid;
            this.packageAbiOverride = activeInstallSession.getSessionParams().abiOverride;
            this.grantedRuntimePermissions = activeInstallSession.getSessionParams().grantedRuntimePermissions;
            this.whitelistedRestrictedPermissions = activeInstallSession.getSessionParams().whitelistedRestrictedPermissions;
            this.signingDetails = activeInstallSession.getSigningDetails();
            this.requiredInstalledVersionCode = activeInstallSession.getSessionParams().requiredInstalledVersionCode;
            this.removeSplitList = activeInstallSession.getSessionParams().removeSplitList;
            this.addSplitList = activeInstallSession.getSessionParams().addSplitList;
        }

        public String toString() {
            return "InstallParams{" + Integer.toHexString(System.identityHashCode(this)) + " file=" + this.origin.file + "}";
        }

        private int installLocationPolicy(PackageInfoLite pkgLite) {
            PackageSetting ps;
            String packageName = pkgLite.packageName;
            int installLocation = pkgLite.installLocation;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package installedPkg = PackageManagerService.this.mPackages.get(packageName);
                PackageParser.Package dataOwnerPkg = installedPkg;
                if (dataOwnerPkg == null && (ps = PackageManagerService.this.mSettings.mPackages.get(packageName)) != null) {
                    dataOwnerPkg = ps.pkg;
                }
                if (this.requiredInstalledVersionCode != -1) {
                    if (dataOwnerPkg == null) {
                        Slog.w(PackageManagerService.TAG, "Required installed version code was " + this.requiredInstalledVersionCode + " but package is not installed");
                        return -8;
                    } else if (dataOwnerPkg.getLongVersionCode() != this.requiredInstalledVersionCode) {
                        Slog.w(PackageManagerService.TAG, "Required installed version code was " + this.requiredInstalledVersionCode + " but actual installed version is " + dataOwnerPkg.getLongVersionCode());
                        return -8;
                    }
                }
                if (dataOwnerPkg != null && !PackageManagerServiceUtils.isDowngradePermitted(this.installFlags, dataOwnerPkg.applicationInfo.flags)) {
                    try {
                        PackageManagerService.checkDowngrade(dataOwnerPkg, pkgLite);
                    } catch (PackageManagerException e) {
                        Slog.w(PackageManagerService.TAG, "Downgrade detected: " + e.getMessage());
                        return -7;
                    }
                }
                if (installedPkg != null) {
                    if ((this.installFlags & 2) == 0) {
                        return -4;
                    }
                    if ((installedPkg.applicationInfo.flags & 1) != 0) {
                        return 1;
                    }
                    if (installLocation == 1) {
                        return 1;
                    }
                    if (installLocation != 2) {
                        if (PackageManagerService.isExternal(installedPkg)) {
                            return 2;
                        }
                        return 1;
                    }
                }
                return pkgLite.recommendedInstallLocation;
            }
        }

        /* JADX WARNING: Removed duplicated region for block: B:129:0x0391  */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleStartCopy() {
            int ret;
            UserHandle verifierUser;
            int requiredUid;
            int[] installedUsers;
            int ret2;
            int ret3;
            int ret4 = 1;
            if (this.origin.staged) {
                if (this.origin.file != null) {
                    this.installFlags |= 16;
                } else {
                    throw new IllegalStateException("Invalid stage location");
                }
            }
            boolean onInt = (this.installFlags & 16) != 0;
            boolean ephemeral = (this.installFlags & 2048) != 0;
            PackageInfoLite pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(PackageManagerService.this.mContext, this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
            if (PackageManagerService.DEBUG_INSTANT && ephemeral) {
                Slog.v(PackageManagerService.TAG, "pkgLite for install: " + pkgLite);
            }
            if (!this.origin.staged && pkgLite.recommendedInstallLocation == -1) {
                long lowThreshold = StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory());
                long sizeBytes = PackageManagerServiceUtils.calculateInstalledSize(this.origin.resolvedPath, this.packageAbiOverride);
                if (sizeBytes >= 0) {
                    try {
                        PackageManagerService.this.mInstaller.freeCache(null, sizeBytes + lowThreshold, 0, 0);
                        pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(PackageManagerService.this.mContext, this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, "Failed to free cache", e);
                    }
                }
                if (pkgLite.recommendedInstallLocation == -6) {
                    pkgLite.recommendedInstallLocation = -1;
                }
            }
            if (PackageManagerService.mHwPMSEx.isOldPackageNameCanNotInstall(pkgLite.packageName)) {
                Slog.i(PackageManagerService.TAG, pkgLite.packageName + " is the old package name and can not install.");
                ret4 = -5;
            }
            if (ret4 == 1) {
                int loc = pkgLite.recommendedInstallLocation;
                if (loc == -3) {
                    ret4 = -19;
                } else if (loc == -4) {
                    ret4 = -1;
                } else if (loc == -1) {
                    ret4 = -4;
                } else if (loc == -2) {
                    ret4 = -2;
                } else if (loc == -6) {
                    ret4 = -3;
                } else if (loc == -5) {
                    ret4 = -20;
                } else {
                    int loc2 = installLocationPolicy(pkgLite);
                    if (loc2 == -7) {
                        ret4 = -25;
                    } else if (loc2 == -8) {
                        ret4 = -121;
                    } else if (!onInt) {
                        if (loc2 == 2) {
                            this.installFlags &= -17;
                        } else if (loc2 == 3) {
                            if (PackageManagerService.DEBUG_INSTANT) {
                                Slog.v(PackageManagerService.TAG, "...setting INSTALL_EPHEMERAL install flag");
                            }
                            this.installFlags |= 2048;
                            this.installFlags &= -17;
                        } else {
                            this.installFlags |= 16;
                        }
                    }
                }
            }
            InstallArgs args = PackageManagerService.this.createInstallArgs(this);
            this.mVerificationCompleted = true;
            this.mEnableRollbackCompleted = true;
            this.mArgs = args;
            PackageManagerService.mHwPMSEx.verifyPackageSecurityPolicy(pkgLite.packageName, this.origin.file);
            if (ret == 1) {
                UserHandle verifierUser2 = getUser();
                if (verifierUser2.equals(UserHandle.ALL)) {
                    verifierUser = UserHandle.SYSTEM;
                } else {
                    verifierUser = verifierUser2;
                }
                if (PackageManagerService.this.mRequiredVerifierPackage == null) {
                    requiredUid = -1;
                } else {
                    PackageManagerService packageManagerService = PackageManagerService.this;
                    requiredUid = packageManagerService.getPackageUid(packageManagerService.mRequiredVerifierPackage, 268435456, verifierUser.getIdentifier());
                }
                VerificationInfo verificationInfo2 = this.verificationInfo;
                int installerUid = verificationInfo2 == null ? -1 : verificationInfo2.installerUid;
                Slog.d(PackageManagerService.TAG, "VerifierPackage requiredUid:" + requiredUid);
                if (this.origin.existing || requiredUid == -1) {
                    ret2 = ret;
                } else if (PackageManagerService.this.isVerificationEnabled(verifierUser.getIdentifier(), this.installFlags, installerUid)) {
                    Intent verification = new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                    verification.addFlags(268435456);
                    verification.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                    verification.addFlags(1);
                    List<ResolveInfo> receivers = PackageManagerService.this.queryIntentReceiversInternal(verification, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false);
                    if (PackageManagerService.DEBUG_VERIFY) {
                        Slog.d(PackageManagerService.TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
                    }
                    final int verificationId = PackageManagerService.access$3408(PackageManagerService.this);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE", this.installerPackageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALL_FLAGS", this.installFlags);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_PACKAGE_NAME", pkgLite.packageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_VERSION_CODE", pkgLite.versionCode);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_LONG_VERSION_CODE", pkgLite.getLongVersionCode());
                    VerificationInfo verificationInfo3 = this.verificationInfo;
                    if (verificationInfo3 != null) {
                        if (verificationInfo3.originatingUri != null) {
                            verification.putExtra("android.intent.extra.ORIGINATING_URI", this.verificationInfo.originatingUri);
                        }
                        if (this.verificationInfo.referrer != null) {
                            verification.putExtra("android.intent.extra.REFERRER", this.verificationInfo.referrer);
                        }
                        if (this.verificationInfo.originatingUid >= 0) {
                            verification.putExtra("android.intent.extra.ORIGINATING_UID", this.verificationInfo.originatingUid);
                        }
                        if (this.verificationInfo.installerUid >= 0) {
                            verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_UID", this.verificationInfo.installerUid);
                        }
                    }
                    PackageVerificationState verificationState = new PackageVerificationState(requiredUid, this);
                    PackageManagerService.this.mPendingVerification.append(verificationId, verificationState);
                    List<ComponentName> sufficientVerifiers = PackageManagerService.this.matchVerifiers(pkgLite, receivers, verificationState);
                    DeviceIdleController.LocalService idleController = PackageManagerService.this.getDeviceIdleController();
                    long idleDuration = PackageManagerService.this.getVerificationTimeout();
                    if (sufficientVerifiers != null) {
                        int N = sufficientVerifiers.size();
                        if (N == 0) {
                            Slog.i(PackageManagerService.TAG, "Additional verifiers required, but none installed.");
                            ret = -22;
                            PackageManagerService packageManagerService2 = PackageManagerService.this;
                            ComponentName requiredVerifierComponent = packageManagerService2.matchComponentForVerifier(packageManagerService2.mRequiredVerifierPackage, receivers);
                            if (ret != 1 && PackageManagerService.this.mRequiredVerifierPackage != null) {
                                Trace.asyncTraceBegin(262144, "verification", verificationId);
                                verification.setComponent(requiredVerifierComponent);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), PackageManagerService.this.mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(verification, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", new BroadcastReceiver() {
                                    /* class com.android.server.pm.PackageManagerService.InstallParams.AnonymousClass1 */

                                    public void onReceive(Context context, Intent intent) {
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                        msg.arg1 = verificationId;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                                    }
                                }, null, 0, null, null);
                                this.mVerificationCompleted = false;
                            }
                            if ((this.installFlags & 262144) != 0) {
                                final int enableRollbackToken = PackageManagerService.access$3708(PackageManagerService.this);
                                Trace.asyncTraceBegin(262144, "enable_rollback", enableRollbackToken);
                                PackageManagerService.this.mPendingEnableRollback.append(enableRollbackToken, this);
                                synchronized (PackageManagerService.this.mPackages) {
                                    PackageSetting ps = PackageManagerService.this.mSettings.getPackageLPr(pkgLite.packageName);
                                    if (ps != null) {
                                        installedUsers = ps.queryInstalledUsers(PackageManagerService.sUserManager.getUserIds(), true);
                                    } else {
                                        installedUsers = new int[0];
                                    }
                                }
                                Intent enableRollbackIntent = new Intent("android.intent.action.PACKAGE_ENABLE_ROLLBACK");
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_TOKEN", enableRollbackToken);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_INSTALL_FLAGS", this.installFlags);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_INSTALLED_USERS", installedUsers);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_USER", getRollbackUser().getIdentifier());
                                enableRollbackIntent.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                                enableRollbackIntent.addFlags(1);
                                enableRollbackIntent.addFlags(DumpState.DUMP_HANDLE);
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(enableRollbackIntent, UserHandle.SYSTEM, "android.permission.PACKAGE_ROLLBACK_AGENT", new BroadcastReceiver() {
                                    /* class com.android.server.pm.PackageManagerService.InstallParams.AnonymousClass2 */

                                    public void onReceive(Context context, Intent intent) {
                                        long rollbackTimeout = DeviceConfig.getLong("rollback", PackageManagerService.PROPERTY_ENABLE_ROLLBACK_TIMEOUT_MILLIS, (long) JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
                                        if (rollbackTimeout < 0) {
                                            rollbackTimeout = JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY;
                                        }
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(22);
                                        msg.arg1 = enableRollbackToken;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, rollbackTimeout);
                                    }
                                }, null, 0, null, null);
                                this.mEnableRollbackCompleted = false;
                            }
                        } else {
                            ret3 = ret;
                            int i = 0;
                            while (i < N) {
                                ComponentName verifierComponent = sufficientVerifiers.get(i);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                Intent sufficientIntent = new Intent(verification);
                                sufficientIntent.setComponent(verifierComponent);
                                PackageManagerService.this.mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
                                i++;
                                onInt = onInt;
                            }
                        }
                    } else {
                        ret3 = ret;
                    }
                    ret = ret3;
                    PackageManagerService packageManagerService22 = PackageManagerService.this;
                    ComponentName requiredVerifierComponent2 = packageManagerService22.matchComponentForVerifier(packageManagerService22.mRequiredVerifierPackage, receivers);
                    if (ret != 1) {
                    }
                    if ((this.installFlags & 262144) != 0) {
                    }
                } else {
                    ret2 = ret;
                }
                ret = ret2;
                if ((this.installFlags & 262144) != 0) {
                }
            }
            this.mRet = ret;
        }

        /* access modifiers changed from: package-private */
        public void setReturnCode(int ret) {
            if (this.mRet == 1) {
                this.mRet = ret;
            }
        }

        /* access modifiers changed from: package-private */
        public void handleVerificationFinished() {
            this.mVerificationCompleted = true;
            handleReturnCode();
        }

        /* access modifiers changed from: package-private */
        public void handleRollbackEnabled() {
            this.mEnableRollbackCompleted = true;
            handleReturnCode();
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleReturnCode() {
            if (this.mVerificationCompleted && this.mEnableRollbackCompleted) {
                if ((this.installFlags & 8388608) != 0) {
                    String packageName = "";
                    try {
                        new PackageParser();
                        packageName = PackageParser.parsePackageLite(this.origin.file, 0).packageName;
                    } catch (PackageParser.PackageParserException e) {
                        Slog.e(PackageManagerService.TAG, "Can't parse package at " + this.origin.file.getAbsolutePath(), e);
                    }
                    try {
                        this.observer.onPackageInstalled(packageName, this.mRet, "Dry run", new Bundle());
                    } catch (RemoteException e2) {
                        Slog.i(PackageManagerService.TAG, "Observer no longer exists.");
                    }
                } else {
                    if (this.mRet == 1) {
                        this.mRet = this.mArgs.copyApk();
                    }
                    PackageManagerService.this.processPendingInstall(this.mArgs, this.mRet);
                }
            }
        }
    }

    /* access modifiers changed from: private */
    public InstallArgs createInstallArgs(InstallParams params) {
        if (params.move != null) {
            return new MoveInstallArgs(params);
        }
        return new FileInstallArgs(params);
    }

    private InstallArgs createInstallArgsForExisting(String codePath, String resourcePath, String[] instructionSets) {
        return new FileInstallArgs(codePath, resourcePath, instructionSets);
    }

    /* access modifiers changed from: package-private */
    public static abstract class InstallArgs {
        final String abiOverride;
        List<String> addSplitList;
        final int installFlags;
        final String[] installGrantPermissions;
        final int installReason;
        final String installerPackageName;
        String[] instructionSets;
        final MultiPackageInstallParams mMultiPackageInstallParams;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        String packageName;
        int packageVersion;
        List<String> removeSplitList;
        final PackageParser.SigningDetails signingDetails;
        final int traceCookie;
        final String traceMethod;
        final UserHandle user;
        final String volumeUuid;
        final List<String> whitelistedRestrictedPermissions;

        /* access modifiers changed from: package-private */
        public abstract void cleanUpResourcesLI();

        /* access modifiers changed from: package-private */
        public abstract int copyApk();

        /* access modifiers changed from: package-private */
        public abstract boolean doPostDeleteLI(boolean z);

        /* access modifiers changed from: package-private */
        public abstract int doPostInstall(int i, int i2);

        /* access modifiers changed from: package-private */
        public abstract int doPreInstall(int i);

        /* access modifiers changed from: package-private */
        public abstract boolean doRename(int i, PackageParser.Package v);

        /* access modifiers changed from: package-private */
        public abstract String getCodePath();

        /* access modifiers changed from: package-private */
        public abstract String getResourcePath();

        InstallArgs(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, UserHandle user2, String[] instructionSets2, String abiOverride2, String[] installGrantPermissions2, List<String> whitelistedRestrictedPermissions2, String traceMethod2, int traceCookie2, PackageParser.SigningDetails signingDetails2, int installReason2, MultiPackageInstallParams multiPackageInstallParams) {
            this.origin = origin2;
            this.move = move2;
            this.installFlags = installFlags2;
            this.observer = observer2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.user = user2;
            this.instructionSets = instructionSets2;
            this.abiOverride = abiOverride2;
            this.installGrantPermissions = installGrantPermissions2;
            this.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions2;
            this.traceMethod = traceMethod2;
            this.traceCookie = traceCookie2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
            this.mMultiPackageInstallParams = multiPackageInstallParams;
        }

        /* access modifiers changed from: package-private */
        public int doPreCopy() {
            return 1;
        }

        /* access modifiers changed from: package-private */
        public int doPostCopy(int uid) {
            return 1;
        }

        /* access modifiers changed from: protected */
        public boolean isEphemeral() {
            return (this.installFlags & 2048) != 0;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.user;
        }
    }

    /* access modifiers changed from: package-private */
    public void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
        if (allCodePaths.isEmpty()) {
            return;
        }
        if (instructionSets != null) {
            String[] dexCodeInstructionSets = InstructionSets.getDexCodeInstructionSets(instructionSets);
            for (String codePath : allCodePaths) {
                for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                    try {
                        this.mInstaller.rmdex(codePath, dexCodeInstructionSet);
                    } catch (Installer.InstallerException e) {
                    }
                }
            }
            return;
        }
        throw new IllegalStateException("instructionSet == null");
    }

    class FileInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        FileInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.whitelistedRestrictedPermissions, params.traceMethod, params.traceCookie, params.signingDetails, params.installReason, params.mParentInstallParams);
            this.removeSplitList = params.removeSplitList;
            this.addSplitList = params.addSplitList;
        }

        FileInstallArgs(String codePath, String resourcePath, String[] instructionSets) {
            super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, null, 0, PackageParser.SigningDetails.UNKNOWN, 0, null);
            File file = null;
            this.codeFile = codePath != null ? new File(codePath) : null;
            this.resourceFile = resourcePath != null ? new File(resourcePath) : file;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int copyApk() {
            Trace.traceBegin(262144, "copyApk");
            try {
                return doCopyApk();
            } finally {
                Trace.traceEnd(262144);
            }
        }

        private int doCopyApk() {
            int ret;
            if (this.origin.staged) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.d(PackageManagerService.TAG, this.origin.file + " already staged; skipping copy");
                }
                this.codeFile = this.origin.file;
                this.resourceFile = this.origin.file;
                return 1;
            }
            try {
                File tempDir = PackageManagerService.this.mInstallerService.allocateStageDirLegacy(this.volumeUuid, (this.installFlags & 2048) != 0);
                this.codeFile = tempDir;
                this.resourceFile = tempDir;
                int ret2 = PackageManagerServiceUtils.copyPackage(this.origin.file.getAbsolutePath(), this.codeFile);
                if (ret2 != 1) {
                    Slog.e(PackageManagerService.TAG, "Failed to copy package");
                    return ret2;
                }
                File libraryRoot = new File(this.codeFile, "lib");
                NativeLibraryHelper.Handle handle = null;
                try {
                    handle = NativeLibraryHelper.Handle.create(this.codeFile);
                    ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, this.abiOverride);
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Copying native libraries failed", e);
                    ret = RequestStatus.SYS_ETIMEDOUT;
                } catch (Throwable th) {
                    IoUtils.closeQuietly(handle);
                    throw th;
                }
                IoUtils.closeQuietly(handle);
                return ret;
            } catch (IOException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to create copy file: " + e2);
                return -4;
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doRename(int status, PackageParser.Package pkg) {
            if (status != 1) {
                cleanUp();
                return false;
            }
            File targetDir = this.codeFile.getParentFile();
            File beforeCodeFile = this.codeFile;
            File afterCodeFile = PackageManagerService.this.getNextCodePath(targetDir, pkg.packageName);
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
            }
            try {
                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
                if (!SELinux.restoreconRecursive(afterCodeFile)) {
                    Slog.w(PackageManagerService.TAG, "Failed to restorecon");
                    return false;
                }
                this.codeFile = afterCodeFile;
                this.resourceFile = afterCodeFile;
                try {
                    pkg.setCodePath(afterCodeFile.getCanonicalPath());
                    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                    pkg.setApplicationInfoCodePath(pkg.codePath);
                    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                    pkg.setApplicationInfoResourcePath(pkg.codePath);
                    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                    return true;
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Failed to get path: " + afterCodeFile, e);
                    return false;
                }
            } catch (ErrnoException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to rename", e2);
                return false;
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
                PackageManagerService.mHwPMSEx.cleanUpHwCert();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getCodePath() {
            File file = this.codeFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getResourcePath() {
            File file = this.resourceFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp() {
            File file = this.codeFile;
            if (file == null || !file.exists()) {
                return false;
            }
            PackageManagerService.this.removeCodePathLI(this.codeFile);
            File file2 = this.resourceFile;
            if (file2 == null || FileUtils.contains(this.codeFile, file2)) {
                return true;
            }
            this.resourceFile.delete();
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public void cleanUpResourcesLI() {
            List<String> allCodePaths = Collections.EMPTY_LIST;
            File file = this.codeFile;
            if (file != null && file.exists()) {
                try {
                    allCodePaths = PackageParser.parsePackageLite(this.codeFile, 0).getAllCodePaths();
                } catch (PackageParser.PackageParserException e) {
                }
            }
            cleanUp();
            PackageManagerService.this.removeDexFiles(allCodePaths, this.instructionSets);
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doPostDeleteLI(boolean delete) {
            cleanUpResourcesLI();
            return true;
        }
    }

    private static void maybeThrowExceptionForMultiArchCopy(String message, int copyRet) throws PackageManagerException {
        if (copyRet < 0 && copyRet != -114 && copyRet != -113) {
            throw new PackageManagerException(copyRet, message);
        }
    }

    class MoveInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        MoveInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.whitelistedRestrictedPermissions, params.traceMethod, params.traceCookie, params.signingDetails, params.installReason, params.mParentInstallParams);
            this.removeSplitList = params.removeSplitList;
            this.addSplitList = params.addSplitList;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int copyApk() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Moving " + this.move.packageName + " from " + this.move.fromUuid + " to " + this.move.toUuid);
            }
            synchronized (PackageManagerService.this.mInstaller) {
                try {
                    PackageManagerService.this.mInstaller.moveCompleteApp(this.move.fromUuid, this.move.toUuid, this.move.packageName, this.move.dataAppName, this.move.appId, this.move.seinfo, this.move.targetSdkVersion);
                } catch (Installer.InstallerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move app", e);
                    return RequestStatus.SYS_ETIMEDOUT;
                }
            }
            this.codeFile = new File(Environment.getDataAppDirectory(this.move.toUuid), this.move.dataAppName);
            this.resourceFile = this.codeFile;
            if (!PackageManagerService.DEBUG_INSTALL) {
                return 1;
            }
            Slog.d(PackageManagerService.TAG, "codeFile after move is " + this.codeFile);
            return 1;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doRename(int status, PackageParser.Package pkg) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
                return false;
            }
            pkg.setApplicationVolumeUuid(pkg.volumeUuid);
            pkg.setApplicationInfoCodePath(pkg.codePath);
            pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
            pkg.setApplicationInfoResourcePath(pkg.codePath);
            pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPostInstall(int status, int uid) {
            if (status == 1) {
                cleanUp(this.move.fromUuid);
            } else {
                PackageManagerService.mHwPMSEx.cleanUpHwCert();
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getCodePath() {
            File file = this.codeFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getResourcePath() {
            File file = this.resourceFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp(String volumeUuid) {
            File codeFile2 = new File(Environment.getDataAppDirectory(volumeUuid), this.move.dataAppName);
            Slog.d(PackageManagerService.TAG, "Cleaning up " + this.move.packageName + " on " + volumeUuid);
            int[] userIds = PackageManagerService.sUserManager.getUserIds();
            synchronized (PackageManagerService.this.mInstallLock) {
                for (int userId : userIds) {
                    try {
                        PackageManagerService.this.mInstaller.destroyAppData(volumeUuid, this.move.packageName, userId, 3, 0);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, String.valueOf(e));
                    }
                }
                PackageManagerService.this.removeCodePathLI(codeFile2);
            }
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public void cleanUpResourcesLI() {
            throw new UnsupportedOperationException();
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doPostDeleteLI(boolean delete) {
            throw new UnsupportedOperationException();
        }
    }

    /* access modifiers changed from: private */
    public File getNextCodePath(File targetDir, String packageName) {
        File result;
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[16];
        do {
            random.nextBytes(bytes);
            String suffix = Base64.encodeToString(bytes, 10);
            result = new File(targetDir, packageName + "-" + suffix);
        } while (result.exists());
        return result;
    }

    static String deriveCodePathName(String codePath) {
        if (codePath == null) {
            return null;
        }
        File codeFile = new File(codePath);
        String name = codeFile.getName();
        if (codeFile.isDirectory()) {
            return name;
        }
        if (name.endsWith(".apk") || name.endsWith(".tmp")) {
            return name.substring(0, name.lastIndexOf(46));
        }
        Slog.w(TAG, "Odd, " + codePath + " doesn't look like an APK");
        return null;
    }

    /* access modifiers changed from: package-private */
    public static class PackageInstalledInfo {
        ArrayMap<String, PackageInstalledInfo> addedChildPackages;
        String installerPackageName;
        String name;
        int[] newUsers;
        String origPackage;
        String origPermission;
        int[] origUsers;
        PackageParser.Package pkg;
        PackageRemovedInfo removedInfo;
        int returnCode;
        String returnMsg;
        int uid;

        PackageInstalledInfo() {
        }

        public void setError(int code, String msg) {
            setReturnCode(code);
            setReturnMessage(msg);
            Slog.w(PackageManagerService.TAG, msg);
        }

        public void setError(String msg, PackageParser.PackageParserException e) {
            setReturnCode(e.error);
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setError(String msg, PackageManagerException e) {
            this.returnCode = e.error;
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setReturnCode(int returnCode2) {
            this.returnCode = returnCode2;
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnCode = returnCode2;
            }
        }

        private void setReturnMessage(String returnMsg2) {
            this.returnMsg = returnMsg2;
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnMsg = returnMsg2;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0019, code lost:
        r2 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x001a, code lost:
        $closeResource(r1, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x001d, code lost:
        throw r2;
     */
    private static void updateDigest(MessageDigest digest, File file) throws IOException {
        DigestInputStream digestStream = new DigestInputStream(new FileInputStream(file), digest);
        do {
        } while (digestStream.read() != -1);
        $closeResource(null, digestStream);
    }

    private String getParentOrChildPackageChangedSharedUser(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        if (!Objects.equals(oldPkg.mSharedUserId, newPkg.mSharedUserId)) {
            return newPkg.packageName;
        }
        int newChildCount = 0;
        int oldChildCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        if (newPkg.childPackages != null) {
            newChildCount = newPkg.childPackages.size();
        }
        for (int i = 0; i < newChildCount; i++) {
            PackageParser.Package newChildPkg = (PackageParser.Package) newPkg.childPackages.get(i);
            for (int j = 0; j < oldChildCount; j++) {
                PackageParser.Package oldChildPkg = (PackageParser.Package) oldPkg.childPackages.get(j);
                if (newChildPkg.packageName.equals(oldChildPkg.packageName) && !Objects.equals(newChildPkg.mSharedUserId, oldChildPkg.mSharedUserId)) {
                    return newChildPkg.packageName;
                }
            }
        }
        return null;
    }

    private void removeNativeBinariesLI(PackageSetting ps) {
        PackageSetting childPs;
        if (ps != null) {
            NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString);
            int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
            for (int i = 0; i < childCount; i++) {
                synchronized (this.mPackages) {
                    childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i));
                }
                if (childPs != null) {
                    NativeLibraryHelper.removeNativeBinariesLI(childPs.legacyNativeLibraryPathString);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void enableSystemPackageLPw(PackageParser.Package pkg) {
        this.mSettings.enableSystemPackageLPw(pkg.packageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.enableSystemPackageLPw(((PackageParser.Package) pkg.childPackages.get(i)).packageName);
        }
    }

    @GuardedBy({"mPackages"})
    private boolean disableSystemPackageLPw(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        boolean disabled = this.mSettings.disableSystemPackageLPw(oldPkg.packageName, true);
        int childCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = (PackageParser.Package) oldPkg.childPackages.get(i);
            disabled |= this.mSettings.disableSystemPackageLPw(childPkg.packageName, newPkg.hasChildPackage(childPkg.packageName));
        }
        return disabled;
    }

    @GuardedBy({"mPackages"})
    private void setInstallerPackageNameLPw(PackageParser.Package pkg, String installerPackageName) {
        this.mSettings.setInstallerPackageName(pkg.packageName, installerPackageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.setInstallerPackageName(((PackageParser.Package) pkg.childPackages.get(i)).packageName, installerPackageName);
        }
    }

    /* access modifiers changed from: protected */
    public void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsInternalLI(newPackage, installerPackageName, allUsers, res.origUsers, res, user, installReason);
        int childCount = newPackage.childPackages != null ? newPackage.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPackage = (PackageParser.Package) newPackage.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPackage.packageName);
            updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user, installReason);
        }
    }

    private void updateSettingsInternalLI(PackageParser.Package pkg, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        int i;
        boolean isUpdate;
        int origUserId;
        Trace.traceBegin(262144, "updateSettings");
        String pkgName = pkg.packageName;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "New package installed in " + pkg.codePath);
        }
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                arrayMap = arrayMap2;
                try {
                    this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                    PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                    boolean isUpdate2 = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
                    if (!isUpdate2 && ps != null) {
                        mHwPMSEx.updateUseSideMode(pkgName, ps);
                        mHwPMSEx.updateForceDarkMode(pkgName, ps);
                    }
                    if (!(ps == null || ps.pkg == null || ps.pkg.applicationInfo == null)) {
                        ps.pkg.applicationInfo.forceDarkMode = ps.forceDarkMode;
                        Slog.i(TAG, "applicationInfo.forceDarkMode of pkgName: " + pkgName + " is " + ps.pkg.applicationInfo.forceDarkMode);
                    }
                    HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
                    int userId = user.getIdentifier();
                    if (ps != null) {
                        int i2 = -1;
                        if (isSystemApp(pkg)) {
                            if (DEBUG_INSTALL) {
                                Slog.d(TAG, "Implicitly enabling system package on upgrade: " + pkgName);
                            }
                            if (res.origUsers != null) {
                                int[] iArr = res.origUsers;
                                int length = iArr.length;
                                int i3 = 0;
                                while (i3 < length) {
                                    int origUserId2 = iArr[i3];
                                    if (userId != i2) {
                                        origUserId = origUserId2;
                                        if (userId != origUserId) {
                                            i3++;
                                            i2 = -1;
                                        }
                                    } else {
                                        origUserId = origUserId2;
                                    }
                                    ps.setEnabled(0, origUserId, installerPackageName);
                                    i3++;
                                    i2 = -1;
                                }
                            }
                            if (allUsers != null && installedForUsers != null) {
                                int length2 = allUsers.length;
                                int i4 = 0;
                                while (i4 < length2) {
                                    int currentUserId = allUsers[i4];
                                    boolean installed = ArrayUtils.contains(installedForUsers, currentUserId);
                                    if (DEBUG_INSTALL) {
                                        isUpdate = isUpdate2;
                                        StringBuilder sb = new StringBuilder();
                                        i = length2;
                                        sb.append("    user ");
                                        sb.append(currentUserId);
                                        sb.append(" => ");
                                        sb.append(installed);
                                        Slog.d(TAG, sb.toString());
                                    } else {
                                        isUpdate = isUpdate2;
                                        i = length2;
                                    }
                                    ps.setInstalled(installed, currentUserId);
                                    i4++;
                                    isUpdate2 = isUpdate;
                                    length2 = i;
                                }
                            }
                        }
                        if (userId != -1) {
                            ps.setInstalled(true, userId);
                            ps.setEnabled(0, userId, installerPackageName);
                        }
                        Set<Integer> previousUserIds = new ArraySet<>();
                        if (!(res.removedInfo == null || res.removedInfo.installReasons == null)) {
                            int installReasonCount = res.removedInfo.installReasons.size();
                            for (int i5 = 0; i5 < installReasonCount; i5++) {
                                int previousUserId = res.removedInfo.installReasons.keyAt(i5);
                                ps.setInstallReason(res.removedInfo.installReasons.valueAt(i5).intValue(), previousUserId);
                                previousUserIds.add(Integer.valueOf(previousUserId));
                            }
                        }
                        if (userId == -1) {
                            int[] userIds = sUserManager.getUserIds();
                            for (int currentUserId2 : userIds) {
                                if (!previousUserIds.contains(Integer.valueOf(currentUserId2))) {
                                    ps.setInstallReason(installReason, currentUserId2);
                                }
                            }
                        } else if (!previousUserIds.contains(Integer.valueOf(userId))) {
                            ps.setInstallReason(installReason, userId);
                        }
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                    res.name = pkgName;
                    res.uid = pkg.applicationInfo.uid;
                    res.pkg = pkg;
                    this.mSettings.setInstallerPackageName(pkgName, installerPackageName);
                    res.setReturnCode(1);
                    Trace.traceBegin(262144, "writeSettings");
                    this.mSettings.writeLPr();
                    Trace.traceEnd(262144);
                    Trace.traceEnd(262144);
                } catch (Throwable th) {
                    th = th;
                    throw th;
                }
            } catch (Throwable th2) {
                th = th2;
                arrayMap = arrayMap2;
                throw th;
            }
        }
    }

    private static class InstallRequest {
        public final InstallArgs args;
        public final PackageInstalledInfo installResult;

        private InstallRequest(InstallArgs args2, PackageInstalledInfo res) {
            this.args = args2;
            this.installResult = res;
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private void installPackagesTracedLI(List<InstallRequest> requests) {
        try {
            Trace.traceBegin(262144, "installPackages");
            installPackagesLI(requests);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private static class CommitRequest {
        final int[] mAllUsers;
        final Map<String, ReconciledPackage> reconciledPackages;

        private CommitRequest(Map<String, ReconciledPackage> reconciledPackages2, int[] allUsers) {
            this.reconciledPackages = reconciledPackages2;
            this.mAllUsers = allUsers;
        }
    }

    private static class ReconcileRequest {
        public final Map<String, PackageParser.Package> allPackages;
        public final Map<String, InstallArgs> installArgs;
        public final Map<String, PackageInstalledInfo> installResults;
        public final Map<String, PackageSetting> lastStaticSharedLibSettings;
        public final Map<String, PrepareResult> preparedPackages;
        public final Map<String, ScanResult> scannedPackages;
        public final Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource;
        public final Map<String, Settings.VersionInfo> versionInfos;

        private ReconcileRequest(Map<String, ScanResult> scannedPackages2, Map<String, InstallArgs> installArgs2, Map<String, PackageInstalledInfo> installResults2, Map<String, PrepareResult> preparedPackages2, Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource2, Map<String, PackageParser.Package> allPackages2, Map<String, Settings.VersionInfo> versionInfos2, Map<String, PackageSetting> lastStaticSharedLibSettings2) {
            this.scannedPackages = scannedPackages2;
            this.installArgs = installArgs2;
            this.installResults = installResults2;
            this.preparedPackages = preparedPackages2;
            this.sharedLibrarySource = sharedLibrarySource2;
            this.allPackages = allPackages2;
            this.versionInfos = versionInfos2;
            this.lastStaticSharedLibSettings = lastStaticSharedLibSettings2;
        }

        private ReconcileRequest(Map<String, ScanResult> scannedPackages2, Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource2, Map<String, PackageParser.Package> allPackages2, Map<String, Settings.VersionInfo> versionInfos2, Map<String, PackageSetting> lastStaticSharedLibSettings2) {
            this(scannedPackages2, Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), sharedLibrarySource2, allPackages2, versionInfos2, lastStaticSharedLibSettings2);
        }
    }

    private static class ReconcileFailure extends PackageManagerException {
        ReconcileFailure(String message) {
            super("Reconcile failed: " + message);
        }

        ReconcileFailure(int reason, String message) {
            super(reason, "Reconcile failed: " + message);
        }

        ReconcileFailure(PackageManagerException e) {
            this(e.error, e.getMessage());
        }
    }

    private static class ReconciledPackage {
        public final List<SharedLibraryInfo> allowedSharedLibraryInfos;
        public ArrayList<SharedLibraryInfo> collectedSharedLibraryInfos;
        public final DeletePackageAction deletePackageAction;
        public final InstallArgs installArgs;
        public final PackageInstalledInfo installResult;
        public final PackageSetting pkgSetting;
        public final PrepareResult prepareResult;
        public final boolean removeAppKeySetData;
        public final ReconcileRequest request;
        public final ScanResult scanResult;
        public final boolean sharedUserSignaturesChanged;
        public final PackageParser.SigningDetails signingDetails;

        private ReconciledPackage(ReconcileRequest request2, InstallArgs installArgs2, PackageSetting pkgSetting2, PackageInstalledInfo installResult2, PrepareResult prepareResult2, ScanResult scanResult2, DeletePackageAction deletePackageAction2, List<SharedLibraryInfo> allowedSharedLibraryInfos2, PackageParser.SigningDetails signingDetails2, boolean sharedUserSignaturesChanged2, boolean removeAppKeySetData2) {
            this.request = request2;
            this.installArgs = installArgs2;
            this.pkgSetting = pkgSetting2;
            this.installResult = installResult2;
            this.prepareResult = prepareResult2;
            this.scanResult = scanResult2;
            this.deletePackageAction = deletePackageAction2;
            this.allowedSharedLibraryInfos = allowedSharedLibraryInfos2;
            this.signingDetails = signingDetails2;
            this.sharedUserSignaturesChanged = sharedUserSignaturesChanged2;
            this.removeAppKeySetData = removeAppKeySetData2;
        }

        /* access modifiers changed from: private */
        public Map<String, PackageParser.Package> getCombinedPackages() {
            ArrayMap<String, PackageParser.Package> combinedPackages = new ArrayMap<>(this.request.allPackages.size() + this.request.scannedPackages.size());
            combinedPackages.putAll(this.request.allPackages);
            for (ScanResult scanResult2 : this.request.scannedPackages.values()) {
                combinedPackages.put(scanResult2.pkgSetting.name, scanResult2.request.pkg);
            }
            return combinedPackages;
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:131:0x032b A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x0245  */
    @GuardedBy({"mPackages"})
    private static Map<String, ReconciledPackage> reconcilePackagesLocked(ReconcileRequest request, KeySetManagerService ksms) throws ReconcileFailure {
        DeletePackageAction deletePackageAction;
        PackageSetting signatureCheckPs;
        PackageSetting disabledPkgSetting;
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries;
        PackageParser.SigningDetails signingDetails;
        KeySetManagerService keySetManagerService = ksms;
        Map<String, ScanResult> scannedPackages = request.scannedPackages;
        Map<String, ReconciledPackage> result = new ArrayMap<>(scannedPackages.size());
        ArrayMap<String, PackageParser.Package> combinedPackages = new ArrayMap<>(request.allPackages.size() + scannedPackages.size());
        combinedPackages.putAll(request.allPackages);
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries2 = new ArrayMap<>();
        for (String installPackageName : scannedPackages.keySet()) {
            ScanResult scanResult = scannedPackages.get(installPackageName);
            combinedPackages.put(scanResult.pkgSetting.name, scanResult.request.pkg);
            List<SharedLibraryInfo> allowedSharedLibInfos = getAllowedSharedLibInfos(scanResult, request.sharedLibrarySource);
            SharedLibraryInfo staticLib = scanResult.staticSharedLibraryInfo;
            if (allowedSharedLibInfos != null) {
                for (SharedLibraryInfo info : allowedSharedLibInfos) {
                    if (!addSharedLibraryToPackageVersionMap(incomingSharedLibraries2, info)) {
                        throw new ReconcileFailure("Static Shared Library " + staticLib.getName() + " is being installed twice in this set!");
                    }
                }
            }
            InstallArgs installArgs = request.installArgs.get(installPackageName);
            PackageInstalledInfo res = request.installResults.get(installPackageName);
            PrepareResult prepareResult = request.preparedPackages.get(installPackageName);
            boolean isInstall = installArgs != null;
            if (!isInstall || !(res == null || prepareResult == null)) {
                if (!isInstall || !prepareResult.replace || prepareResult.system) {
                    deletePackageAction = null;
                } else {
                    DeletePackageAction deletePackageAction2 = mayDeletePackageLocked(res.removedInfo, prepareResult.originalPs, prepareResult.disabledPs, prepareResult.childPackageSettings, 1 | ((scanResult.request.scanFlags & 2048) == 0 ? 0 : 8), null);
                    if (deletePackageAction2 != null) {
                        deletePackageAction = deletePackageAction2;
                    } else {
                        throw new ReconcileFailure(-10, "May not delete " + installPackageName + " to replace");
                    }
                }
                int scanFlags = scanResult.request.scanFlags;
                int parseFlags = scanResult.request.parseFlags;
                PackageParser.Package pkg = scanResult.request.pkg;
                PackageSetting disabledPkgSetting2 = scanResult.request.disabledPkgSetting;
                PackageSetting lastStaticSharedLibSetting = request.lastStaticSharedLibSettings.get(installPackageName);
                if (prepareResult == null || lastStaticSharedLibSetting == null) {
                    signatureCheckPs = scanResult.pkgSetting;
                } else {
                    signatureCheckPs = lastStaticSharedLibSetting;
                }
                boolean removeAppKeySetData = false;
                boolean sharedUserSignaturesChanged = false;
                if (keySetManagerService.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                    if (!keySetManagerService.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                        if ((parseFlags & 16) != 0) {
                            reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                        } else {
                            throw new ReconcileFailure(-7, "Package " + pkg.packageName + " upgrade keys do not match the previously installed version");
                        }
                    }
                    signingDetails = pkg.mSigningDetails;
                    disabledPkgSetting = disabledPkgSetting2;
                    incomingSharedLibraries = incomingSharedLibraries2;
                } else {
                    try {
                        Settings.VersionInfo versionInfo = request.versionInfos.get(installPackageName);
                        incomingSharedLibraries = incomingSharedLibraries2;
                        try {
                            if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, disabledPkgSetting2, pkg.mSigningDetails, isCompatSignatureUpdateNeeded(versionInfo), isRecoverSignatureUpdateNeeded(versionInfo))) {
                                removeAppKeySetData = true;
                            }
                            signingDetails = pkg.mSigningDetails;
                            if (signatureCheckPs.sharedUser != null) {
                                disabledPkgSetting = disabledPkgSetting2;
                                try {
                                    if (pkg.mSigningDetails.hasAncestor(signatureCheckPs.sharedUser.signatures.mSigningDetails)) {
                                        signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                                    }
                                    if (signatureCheckPs.sharedUser.signaturesChanged == null) {
                                        signatureCheckPs.sharedUser.signaturesChanged = Boolean.FALSE;
                                    }
                                } catch (PackageManagerException e) {
                                    e = e;
                                    if ((parseFlags & 16) != 0) {
                                    }
                                } catch (IllegalArgumentException e2) {
                                    e = e2;
                                    throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e);
                                }
                            } else {
                                disabledPkgSetting = disabledPkgSetting2;
                            }
                        } catch (PackageManagerException e3) {
                            e = e3;
                            disabledPkgSetting = disabledPkgSetting2;
                            if ((parseFlags & 16) != 0) {
                            }
                        } catch (IllegalArgumentException e4) {
                            e = e4;
                            throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e);
                        }
                    } catch (PackageManagerException e5) {
                        e = e5;
                        disabledPkgSetting = disabledPkgSetting2;
                        incomingSharedLibraries = incomingSharedLibraries2;
                        if ((parseFlags & 16) != 0) {
                            PackageParser.SigningDetails signingDetails2 = pkg.mSigningDetails;
                            if (signatureCheckPs.sharedUser != null) {
                                Signature[] sharedUserSignatures = signatureCheckPs.sharedUser.signatures.mSigningDetails.signatures;
                                if (signatureCheckPs.sharedUser.signaturesChanged == null || PackageManagerServiceUtils.compareSignatures(sharedUserSignatures, pkg.mSigningDetails.signatures) == 0) {
                                    sharedUserSignaturesChanged = true;
                                    signingDetails = signingDetails2;
                                    signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                                    signatureCheckPs.sharedUser.signaturesChanged = Boolean.TRUE;
                                } else if (SystemProperties.getInt("ro.product.first_api_level", 0) <= 29) {
                                    throw new ReconcileFailure(-104, "Signature mismatch for shared user: " + scanResult.pkgSetting.sharedUser);
                                } else {
                                    throw new IllegalStateException("Signature mismatch on system package " + pkg.packageName + " for shared user " + scanResult.pkgSetting.sharedUser);
                                }
                            } else {
                                signingDetails = signingDetails2;
                            }
                            reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                            result.put(installPackageName, new ReconciledPackage(request, installArgs, scanResult.pkgSetting, res, request.preparedPackages.get(installPackageName), scanResult, deletePackageAction, allowedSharedLibInfos, signingDetails, sharedUserSignaturesChanged, removeAppKeySetData));
                            result = result;
                            scannedPackages = scannedPackages;
                            incomingSharedLibraries2 = incomingSharedLibraries;
                            combinedPackages = combinedPackages;
                            keySetManagerService = ksms;
                        } else {
                            throw new ReconcileFailure(e);
                        }
                    } catch (IllegalArgumentException e6) {
                        e = e6;
                        throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e);
                    }
                }
                result.put(installPackageName, new ReconciledPackage(request, installArgs, scanResult.pkgSetting, res, request.preparedPackages.get(installPackageName), scanResult, deletePackageAction, allowedSharedLibInfos, signingDetails, sharedUserSignaturesChanged, removeAppKeySetData));
                result = result;
                scannedPackages = scannedPackages;
                incomingSharedLibraries2 = incomingSharedLibraries;
                combinedPackages = combinedPackages;
                keySetManagerService = ksms;
            } else {
                throw new ReconcileFailure("Reconcile arguments are not balanced for " + installPackageName + "!");
            }
        }
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries3 = incomingSharedLibraries2;
        ArrayMap<String, PackageParser.Package> combinedPackages2 = combinedPackages;
        Map<String, ScanResult> scannedPackages2 = scannedPackages;
        for (String installPackageName2 : scannedPackages2.keySet()) {
            ScanResult scanResult2 = scannedPackages2.get(installPackageName2);
            if ((scanResult2.request.scanFlags & 16) != 0) {
                scannedPackages2 = scannedPackages2;
            } else if ((scanResult2.request.parseFlags & 16) != 0) {
                scannedPackages2 = scannedPackages2;
            } else {
                try {
                    try {
                        result.get(installPackageName2).collectedSharedLibraryInfos = collectSharedLibraryInfos(scanResult2.request.pkg, combinedPackages2, request.sharedLibrarySource, incomingSharedLibraries3);
                        scannedPackages2 = scannedPackages2;
                        combinedPackages2 = combinedPackages2;
                        incomingSharedLibraries3 = incomingSharedLibraries3;
                    } catch (PackageManagerException e7) {
                        e = e7;
                        throw new ReconcileFailure(e.error, e.getMessage());
                    }
                } catch (PackageManagerException e8) {
                    e = e8;
                    throw new ReconcileFailure(e.error, e.getMessage());
                }
            }
        }
        return result;
    }

    private static List<SharedLibraryInfo> getAllowedSharedLibInfos(ScanResult scanResult, Map<String, LongSparseArray<SharedLibraryInfo>> existingSharedLibraries) {
        PackageSetting updatedSystemPs;
        PackageParser.Package pkg = scanResult.request.pkg;
        if (scanResult.staticSharedLibraryInfo == null && scanResult.dynamicSharedLibraryInfos == null) {
            return null;
        }
        if (scanResult.staticSharedLibraryInfo != null) {
            return Collections.singletonList(scanResult.staticSharedLibraryInfo);
        }
        boolean hasDynamicLibraries = true;
        if (((pkg.applicationInfo.flags & 1) == 0 && !isSystemAppGrantByMdmAndNonPreload(pkg)) || scanResult.dynamicSharedLibraryInfos == null) {
            hasDynamicLibraries = false;
        }
        if (!hasDynamicLibraries) {
            return null;
        }
        boolean isUpdatedSystemApp = pkg.isUpdatedSystemApp();
        if (!isUpdatedSystemApp) {
            updatedSystemPs = null;
        } else if (scanResult.request.disabledPkgSetting == null) {
            updatedSystemPs = scanResult.request.oldPkgSetting;
        } else {
            updatedSystemPs = scanResult.request.disabledPkgSetting;
        }
        if (!isUpdatedSystemApp || !(updatedSystemPs == null || updatedSystemPs.pkg == null || updatedSystemPs.pkg.libraryNames == null)) {
            ArrayList<SharedLibraryInfo> infos = new ArrayList<>(scanResult.dynamicSharedLibraryInfos.size());
            for (SharedLibraryInfo info : scanResult.dynamicSharedLibraryInfos) {
                String name = info.getName();
                if (isUpdatedSystemApp && !updatedSystemPs.pkg.libraryNames.contains(name)) {
                    Slog.w(TAG, "Package " + pkg.packageName + " declares library " + name + " that is not declared on system image; skipping");
                } else if (sharedLibExists(name, -1, existingSharedLibraries)) {
                    Slog.w(TAG, "Package " + pkg.packageName + " declares library " + name + " that already exists; skipping");
                } else {
                    infos.add(info);
                }
            }
            return infos;
        }
        Slog.w(TAG, "Package " + pkg.packageName + " declares libraries that are not declared on the system image; skipping");
        return null;
    }

    private static boolean addSharedLibraryToPackageVersionMap(Map<String, LongSparseArray<SharedLibraryInfo>> target, SharedLibraryInfo library) {
        String name = library.getName();
        if (!target.containsKey(name)) {
            target.put(name, new LongSparseArray<>());
        } else if (library.getType() != 2 || target.get(name).indexOfKey(library.getLongVersion()) >= 0) {
            return false;
        }
        target.get(name).put(library.getLongVersion(), library);
        return true;
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r1v3 */
    /* JADX WARN: Type inference failed for: r1v70 */
    /* JADX WARNING: Code restructure failed: missing block: B:40:0x00f7, code lost:
        if (r3.childPackages == null) goto L_0x0100;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x00f9, code lost:
        r5 = r3.childPackages.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x0100, code lost:
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x0101, code lost:
        r0 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x0104, code lost:
        if (r14.childPackages == null) goto L_0x010d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x0106, code lost:
        r5 = r14.childPackages.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x010d, code lost:
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x010e, code lost:
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x0111, code lost:
        if (r5 >= r0) goto L_0x01a9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x0113, code lost:
        r4 = (android.content.pm.PackageParser.Package) r3.childPackages.get(r5);
        r1 = true;
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x011e, code lost:
        if (r2 >= r5) goto L_0x0141;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0120, code lost:
        r17 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0134, code lost:
        if (r4.packageName.equals(((android.content.pm.PackageParser.Package) r14.childPackages.get(r2)).packageName) == false) goto L_0x013a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x0136, code lost:
        r22 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x013a, code lost:
        r2 = r2 + 1;
        r0 = r17;
        r1 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x0141, code lost:
        r17 = r0;
        r22 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x0145, code lost:
        if (r22 == false) goto L_0x019b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x0147, code lost:
        r0 = r29.mSettings.getDisabledSystemPkgLPr(r4.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x014f, code lost:
        if (r0 == null) goto L_0x0194;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x0155, code lost:
        if (r7.removedInfo.removedChildPackages == null) goto L_0x0194;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x0157, code lost:
        r3 = r7.removedInfo.removedChildPackages.get(r4.packageName);
        r27 = r5;
        r23 = r6;
        removePackageDataLIF(r0, r30.mAllUsers, r3, 0, false);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x018a, code lost:
        if (r29.mPackages.get(r0.name) != null) goto L_0x018e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x018c, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x018e, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x018f, code lost:
        r3.removedForAllUsers = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x0194, code lost:
        r27 = r5;
        r23 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x019b, code lost:
        r27 = r5;
        r23 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x01a1, code lost:
        r5 = r27 + 1;
        r0 = r17;
        r6 = r23;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x01a9, code lost:
        r12 = r7;
     */
    /* JADX WARNING: Removed duplicated region for block: B:103:0x025e  */
    /* JADX WARNING: Removed duplicated region for block: B:106:0x0264  */
    /* JADX WARNING: Removed duplicated region for block: B:111:0x028e  */
    /* JADX WARNING: Removed duplicated region for block: B:131:0x02f6  */
    /* JADX WARNING: Removed duplicated region for block: B:137:0x030b  */
    /* JADX WARNING: Removed duplicated region for block: B:140:0x0336  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x0348  */
    /* JADX WARNING: Removed duplicated region for block: B:144:0x034e  */
    /* JADX WARNING: Removed duplicated region for block: B:147:0x0357  */
    /* JADX WARNING: Removed duplicated region for block: B:150:0x0361  */
    /* JADX WARNING: Removed duplicated region for block: B:156:0x0392  */
    /* JADX WARNING: Removed duplicated region for block: B:162:0x039a A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x01e7  */
    /* JADX WARNING: Removed duplicated region for block: B:97:0x023a  */
    @GuardedBy({"mPackages"})
    private void commitPackagesLocked(CommitRequest request) {
        PackageParser.Package r20;
        PackageInstalledInfo res;
        PackageSetting ps;
        int i;
        boolean z;
        int childCount;
        int i2;
        PackageInstalledInfo res2;
        Set set;
        PackageSetting ps1;
        for (PackageParser.Package oldPackage = request.reconciledPackages.values().iterator(); oldPackage.hasNext(); oldPackage = r20) {
            ReconciledPackage reconciledPkg = oldPackage.next();
            PackageParser.Package pkg = reconciledPkg.scanResult.request.pkg;
            String packageName = pkg.packageName;
            PackageInstalledInfo res3 = reconciledPkg.installResult;
            if (reconciledPkg.prepareResult.replace) {
                PackageParser.Package oldPackage2 = this.mPackages.get(packageName);
                r20 = oldPackage;
                setInstallAndUpdateTime(pkg, ((PackageSetting) oldPackage2.mExtras).firstInstallTime, System.currentTimeMillis());
                PackageSetting deletePackageSetting = this.mSettings.mPackages.get(oldPackage2.packageName);
                if (reconciledPkg.prepareResult.system) {
                    removePackageLI(oldPackage2, true);
                    if (!disableSystemPackageLPw(oldPackage2, pkg)) {
                        res3.removedInfo.args = createInstallArgsForExisting(oldPackage2.applicationInfo.getCodePath(), oldPackage2.applicationInfo.getResourcePath(), InstructionSets.getAppDexInstructionSets(oldPackage2.applicationInfo));
                    } else {
                        res3.removedInfo.args = null;
                    }
                    synchronized (this.mPackages) {
                        try {
                            String disableSysPath = this.mSettings.getDisabledSysPackagesPath(packageName);
                            PackageSetting disableSysSetting = this.mSettings.getDisabledSystemPkgLPr(packageName);
                            boolean disableSysPathInDel = false;
                            disableSysPathInDel = false;
                            boolean disableSysInData = false;
                            disableSysInData = false;
                            if (disableSysPath != null) {
                                try {
                                    if (mHwPMSEx.containDelPath(disableSysPath) || mHwPMSEx.isPreRemovableApp(disableSysPath)) {
                                        disableSysPathInDel = true;
                                    }
                                } catch (Throwable th) {
                                    th = th;
                                    while (true) {
                                        try {
                                            break;
                                        } catch (Throwable th2) {
                                            th = th2;
                                        }
                                    }
                                    throw th;
                                }
                            }
                            if (disableSysSetting != null && mHwPMSEx.isDelappInData(disableSysSetting)) {
                                disableSysInData = true;
                            }
                            if (mHwPMSEx.containDelPath(oldPackage2.applicationInfo.sourceDir) || mHwPMSEx.isPreRemovableApp(oldPackage2.applicationInfo.sourceDir) || mHwPMSEx.isDelappInData(deletePackageSetting) || disableSysPathInDel || disableSysInData) {
                                pkg.applicationInfo.hwFlags |= DumpState.DUMP_HANDLE;
                            }
                        } catch (Throwable th3) {
                            th = th3;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    }
                } else {
                    try {
                        set = null;
                        res2 = res3;
                        try {
                            executeDeletePackageLIF(reconciledPkg.deletePackageAction, packageName, true, request.mAllUsers, true, pkg);
                        } catch (SystemDeleteException e) {
                            e = e;
                        }
                    } catch (SystemDeleteException e2) {
                        e = e2;
                        set = null;
                        res2 = res3;
                        if (Build.IS_ENG) {
                            throw new RuntimeException("Unexpected failure", e);
                        }
                        if (DEBUG_INSTALL) {
                        }
                        int[] uidArray = {oldPackage2.applicationInfo.uid};
                        ArrayList<String> pkgList = new ArrayList<>(1);
                        pkgList.add(oldPackage2.applicationInfo.packageName);
                        sendResourcesChangedBroadcast(false, true, pkgList, uidArray, (IIntentReceiver) null);
                        ps1 = this.mSettings.mPackages.get(reconciledPkg.prepareResult.existingPackage.packageName);
                        if ((reconciledPkg.installArgs.installFlags & 1) != 0) {
                        }
                        if (ps1.childPackageNames != null) {
                        }
                        if (reconciledPkg.installResult.returnCode != 1) {
                        }
                        if (res.returnCode == 1) {
                        }
                        commitReconciledScanResultLocked(reconciledPkg);
                        updateSettingsLI(pkg, reconciledPkg.installArgs.installerPackageName, request.mAllUsers, res, reconciledPkg.installArgs.user, reconciledPkg.installArgs.installReason);
                        ps = this.mSettings.mPackages.get(packageName);
                        if (ps == null) {
                        }
                        if (res.returnCode == i) {
                        }
                        childCount = z;
                        if (pkg.childPackages != null) {
                        }
                        while (i2 < childCount) {
                        }
                        if (res.returnCode != 1) {
                        }
                    }
                    if (oldPackage2.isForwardLocked() || isExternal(oldPackage2)) {
                        if (DEBUG_INSTALL) {
                            Slog.i(TAG, "upgrading pkg " + oldPackage2 + " is ASEC-hosted -> UNAVAILABLE");
                        }
                        int[] uidArray2 = {oldPackage2.applicationInfo.uid};
                        ArrayList<String> pkgList2 = new ArrayList<>(1);
                        pkgList2.add(oldPackage2.applicationInfo.packageName);
                        sendResourcesChangedBroadcast(false, true, pkgList2, uidArray2, (IIntentReceiver) null);
                    }
                    ps1 = this.mSettings.mPackages.get(reconciledPkg.prepareResult.existingPackage.packageName);
                    if ((reconciledPkg.installArgs.installFlags & 1) != 0) {
                        if (ps1.mOldCodePaths == null) {
                            ps1.mOldCodePaths = new ArraySet();
                        }
                        Collections.addAll(ps1.mOldCodePaths, oldPackage2.baseCodePath);
                        if (oldPackage2.splitCodePaths != null) {
                            Collections.addAll(ps1.mOldCodePaths, oldPackage2.splitCodePaths);
                        }
                    } else {
                        ps1.mOldCodePaths = set;
                    }
                    if (ps1.childPackageNames != null) {
                        for (int i3 = ps1.childPackageNames.size() - 1; i3 >= 0; i3--) {
                            this.mSettings.mPackages.get((String) ps1.childPackageNames.get(i3)).mOldCodePaths = ps1.mOldCodePaths;
                        }
                    }
                    if (reconciledPkg.installResult.returnCode != 1) {
                        PackageSetting ps2 = this.mSettings.getPackageLPr(pkg.packageName);
                        if (ps2 != null) {
                            res = res2;
                            res.removedInfo.removedForAllUsers = this.mPackages.get(ps2.name) == null;
                            if (res.removedInfo.removedChildPackages != null) {
                                for (int i4 = res.removedInfo.removedChildPackages.size() - 1; i4 >= 0; i4--) {
                                    if (res.addedChildPackages.containsKey(res.removedInfo.removedChildPackages.keyAt(i4))) {
                                        res.removedInfo.removedChildPackages.removeAt(i4);
                                    } else {
                                        PackageRemovedInfo childInfo = res.removedInfo.removedChildPackages.valueAt(i4);
                                        childInfo.removedForAllUsers = this.mPackages.get(childInfo.removedPackage) == null;
                                    }
                                }
                            }
                        } else {
                            res = res2;
                        }
                    } else {
                        res = res2;
                    }
                }
            } else {
                r20 = oldPackage;
                res = res3;
            }
            if (res.returnCode == 1) {
                updateDisablePluginsLocked(pkg, reconciledPkg.installArgs.removeSplitList);
            }
            commitReconciledScanResultLocked(reconciledPkg);
            updateSettingsLI(pkg, reconciledPkg.installArgs.installerPackageName, request.mAllUsers, res, reconciledPkg.installArgs.user, reconciledPkg.installArgs.installReason);
            ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                i = 1;
                res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                z = false;
                ps.setUpdateAvailable(false);
            } else {
                z = false;
                i = 1;
            }
            if (res.returnCode == i) {
                mHwPMSEx.writeCertCompatPackages(z);
            }
            childCount = z;
            if (pkg.childPackages != null) {
                childCount = pkg.childPackages.size();
            }
            for (i2 = 0; i2 < childCount; i2++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i2);
                PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
                PackageSetting childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
            }
            if (res.returnCode != 1) {
                updateSequenceNumberLP(ps, res.newUsers);
                updateInstantAppInstallerLocked(packageName);
            }
        }
    }

    /* JADX INFO: Multiple debug info for r12v4 'createdAppId'  java.util.Map<java.lang.String, java.lang.Boolean>: [D('deviceProvisionedState' int), D('createdAppId' java.util.Map<java.lang.String, java.lang.Boolean>)] */
    /* JADX INFO: Multiple debug info for r9v28 'request'  com.android.server.pm.PackageManagerService$InstallRequest: [D('request' com.android.server.pm.PackageManagerService$InstallRequest), D('createdAppId' java.util.Map<java.lang.String, java.lang.Boolean>)] */
    /* JADX INFO: Multiple debug info for r14v17 java.util.Map<java.lang.String, com.android.server.pm.Settings$VersionInfo>: [D('installArgs' java.util.Map<java.lang.String, com.android.server.pm.PackageManagerService$InstallArgs>), D('versionInfos' java.util.Map<java.lang.String, com.android.server.pm.Settings$VersionInfo>)] */
    /* JADX INFO: Multiple debug info for r20v16 'installResults'  java.util.Map<java.lang.String, com.android.server.pm.PackageManagerService$PackageInstalledInfo>: [D('versionInfos' java.util.Map<java.lang.String, com.android.server.pm.Settings$VersionInfo>), D('installResults' java.util.Map<java.lang.String, com.android.server.pm.PackageManagerService$PackageInstalledInfo>)] */
    /* JADX INFO: Multiple debug info for r13v32 java.util.Map<java.lang.String, com.android.server.pm.PackageSetting>: [D('installResults' java.util.Map<java.lang.String, com.android.server.pm.PackageManagerService$PackageInstalledInfo>), D('lastStaticSharedLibSettings' java.util.Map<java.lang.String, com.android.server.pm.PackageSetting>)] */
    /*  JADX ERROR: StackOverflowError in pass: MarkFinallyVisitor
        java.lang.StackOverflowError
        	at jadx.core.dex.visitors.MarkFinallyVisitor.sameInsns(MarkFinallyVisitor.java:451)
        	at jadx.core.dex.visitors.MarkFinallyVisitor.compareBlocks(MarkFinallyVisitor.java:436)
        	at jadx.core.dex.visitors.MarkFinallyVisitor.checkBlocksTree(MarkFinallyVisitor.java:408)
        	at jadx.core.dex.visitors.MarkFinallyVisitor.checkBlocksTree(MarkFinallyVisitor.java:411)
        */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:102:0x02e8  */
    /* JADX WARNING: Removed duplicated region for block: B:117:0x033d  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x03fa  */
    /* JADX WARNING: Removed duplicated region for block: B:156:0x044f  */
    /* JADX WARNING: Removed duplicated region for block: B:264:0x065f  */
    /* JADX WARNING: Removed duplicated region for block: B:280:0x06b6  */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x0299 A[ExcHandler: all (th java.lang.Throwable), Splitter:B:50:0x0159] */
    @com.android.internal.annotations.GuardedBy({"mInstallLock"})
    private void installPackagesLI(List<InstallRequest> r30) {
        /*
            r29 = this;
            r8 = r29
            android.content.Context r0 = r8.mContext
            android.content.ContentResolver r0 = r0.getContentResolver()
            r9 = 0
            java.lang.Boolean r10 = java.lang.Boolean.valueOf(r9)
            java.lang.String r1 = "hw_suw_frp_state"
            int r11 = android.provider.Settings.Secure.getInt(r0, r1, r9)
            android.content.Context r0 = r8.mContext
            android.content.ContentResolver r0 = r0.getContentResolver()
            java.lang.String r1 = "device_provisioned"
            int r12 = android.provider.Settings.Global.getInt(r0, r1, r9)
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r15 = r0
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r14 = r0
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r13 = r0
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r7 = r0
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r5 = r0
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r6 = r0
            android.util.ArrayMap r0 = new android.util.ArrayMap
            int r1 = r30.size()
            r0.<init>(r1)
            r4 = r0
            r23 = 0
            r3 = 1
            r1 = 262144(0x40000, double:1.295163E-318)
            java.lang.String r0 = "installPackagesLI"
            android.os.Trace.traceBegin(r1, r0)     // Catch:{ all -> 0x0650 }
            java.util.Iterator r0 = r30.iterator()     // Catch:{ all -> 0x0650 }
        L_0x0076:
            boolean r16 = r0.hasNext()     // Catch:{ all -> 0x0650 }
            if (r16 == 0) goto L_0x0487
            java.lang.Object r16 = r0.next()     // Catch:{ all -> 0x0472 }
            com.android.server.pm.PackageManagerService$InstallRequest r16 = (com.android.server.pm.PackageManagerService.InstallRequest) r16     // Catch:{ all -> 0x0472 }
            r17 = r16
            if (r11 != r3) goto L_0x0115
            if (r12 == r3) goto L_0x0115
            r1 = r17
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r0 = r1.installResult     // Catch:{ all -> 0x0106 }
            r2 = -110(0xffffffffffffff92, float:NaN)
            r0.setReturnCode(r2)     // Catch:{ all -> 0x0106 }
            java.lang.String r0 = "PackageManager"
            java.lang.String r2 = "can not install packages before FRP unlock"
            android.util.Log.w(r0, r2)     // Catch:{ all -> 0x0106 }
            if (r23 != 0) goto L_0x00e1
            java.util.Collection r0 = r15.values()
            java.util.Iterator r0 = r0.iterator()
        L_0x00a2:
            boolean r2 = r0.hasNext()
            if (r2 == 0) goto L_0x00c5
            java.lang.Object r2 = r0.next()
            com.android.server.pm.PackageManagerService$ScanResult r2 = (com.android.server.pm.PackageManagerService.ScanResult) r2
            com.android.server.pm.PackageManagerService$ScanRequest r9 = r2.request
            android.content.pm.PackageParser$Package r9 = r9.pkg
            java.lang.String r9 = r9.packageName
            java.lang.Object r9 = r4.getOrDefault(r9, r10)
            java.lang.Boolean r9 = (java.lang.Boolean) r9
            boolean r9 = r9.booleanValue()
            if (r9 == 0) goto L_0x00c3
            r8.cleanUpAppIdCreation(r2)
        L_0x00c3:
            r9 = 0
            goto L_0x00a2
        L_0x00c5:
            java.util.Iterator r0 = r30.iterator()
        L_0x00c9:
            boolean r2 = r0.hasNext()
            if (r2 == 0) goto L_0x00e1
            java.lang.Object r2 = r0.next()
            com.android.server.pm.PackageManagerService$InstallRequest r2 = (com.android.server.pm.PackageManagerService.InstallRequest) r2
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r9 = r2.installResult
            int r9 = r9.returnCode
            if (r9 != r3) goto L_0x00e0
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r9 = r2.installResult
            r10 = 0
            r9.returnCode = r10
        L_0x00e0:
            goto L_0x00c9
        L_0x00e1:
            java.util.Collection r0 = r7.values()
            java.util.Iterator r0 = r0.iterator()
        L_0x00e9:
            boolean r2 = r0.hasNext()
            if (r2 == 0) goto L_0x00ff
            java.lang.Object r2 = r0.next()
            com.android.server.pm.PackageManagerService$PrepareResult r2 = (com.android.server.pm.PackageManagerService.PrepareResult) r2
            com.android.server.pm.PackageManagerService$PackageFreezer r3 = r2.freezer
            if (r3 == 0) goto L_0x00fe
            com.android.server.pm.PackageManagerService$PackageFreezer r3 = r2.freezer
            r3.close()
        L_0x00fe:
            goto L_0x00e9
        L_0x00ff:
            r2 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r2)
            return
        L_0x0106:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r3 = r13
            r7 = r15
            r12 = r4
            r4 = r6
            r6 = r5
            r5 = r14
            goto L_0x065d
        L_0x0115:
            r1 = r17
            java.lang.String r2 = "preparePackage"
            r9 = r4
            r3 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceBegin(r3, r2)     // Catch:{ PrepareFailure -> 0x03a6, all -> 0x0393 }
            com.android.server.pm.PackageManagerService$InstallArgs r2 = r1.args     // Catch:{ PrepareFailure -> 0x0384, all -> 0x0375 }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r3 = r1.installResult     // Catch:{ PrepareFailure -> 0x0384, all -> 0x0375 }
            com.android.server.pm.PackageManagerService$PrepareResult r2 = r8.preparePackageLI(r2, r3)     // Catch:{ PrepareFailure -> 0x0384, all -> 0x0375 }
            r4 = r2
            r2 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r2)     // Catch:{ all -> 0x0360 }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r2 = r1.installResult     // Catch:{ all -> 0x0351 }
            r3 = 1
            r2.setReturnCode(r3)     // Catch:{ all -> 0x0351 }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r2 = r1.installResult     // Catch:{ all -> 0x0351 }
            com.android.server.pm.PackageManagerService$InstallArgs r3 = r1.args     // Catch:{ all -> 0x0351 }
            java.lang.String r3 = r3.installerPackageName     // Catch:{ all -> 0x0351 }
            r2.installerPackageName = r3     // Catch:{ all -> 0x0351 }
            android.content.pm.PackageParser$Package r2 = r4.packageToScan     // Catch:{ all -> 0x0351 }
            java.lang.String r2 = r2.packageName     // Catch:{ all -> 0x0351 }
            r3 = r2
            r7.put(r3, r4)     // Catch:{ all -> 0x0351 }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r2 = r1.installResult     // Catch:{ all -> 0x0351 }
            r13.put(r3, r2)     // Catch:{ all -> 0x0351 }
            com.android.server.pm.PackageManagerService$InstallArgs r2 = r1.args     // Catch:{ all -> 0x0351 }
            r14.put(r3, r2)     // Catch:{ all -> 0x0351 }
            android.content.pm.PackageParser$Package r2 = r4.packageToScan     // Catch:{ PackageManagerException -> 0x02ca }
            r17 = r0
            int r0 = r4.parseFlags     // Catch:{ PackageManagerException -> 0x02ca }
            r20 = r5
            int r5 = r4.scanFlags     // Catch:{ PackageManagerException -> 0x02b3, all -> 0x0299 }
            long r21 = java.lang.System.currentTimeMillis()     // Catch:{ PackageManagerException -> 0x02b3, all -> 0x0299 }
            r24 = r3
            com.android.server.pm.PackageManagerService$InstallArgs r3 = r1.args     // Catch:{ PackageManagerException -> 0x0281, all -> 0x0299 }
            android.os.UserHandle r3 = r3.user     // Catch:{ PackageManagerException -> 0x0281, all -> 0x0299 }
            r25 = r9
            r26 = 262144(0x40000, double:1.295163E-318)
            r9 = r1
            r1 = r29
            r16 = r3
            r28 = r11
            r11 = r24
            r24 = r12
            r12 = 1
            r3 = r0
            r18 = r4
            r12 = r25
            r4 = r5
            r19 = r14
            r14 = r20
            r20 = r13
            r13 = r6
            r5 = r21
            r25 = r7
            r7 = r16
            java.util.List r0 = r1.scanPackageTracedLI(r2, r3, r4, r5, r7)     // Catch:{ PackageManagerException -> 0x027e }
            java.util.Iterator r1 = r0.iterator()     // Catch:{ PackageManagerException -> 0x027e }
        L_0x0191:
            boolean r2 = r1.hasNext()     // Catch:{ PackageManagerException -> 0x027e }
            if (r2 == 0) goto L_0x0268
            java.lang.Object r2 = r1.next()     // Catch:{ PackageManagerException -> 0x027e }
            com.android.server.pm.PackageManagerService$ScanResult r2 = (com.android.server.pm.PackageManagerService.ScanResult) r2     // Catch:{ PackageManagerException -> 0x027e }
            com.android.server.pm.PackageSetting r3 = r2.pkgSetting     // Catch:{ PackageManagerException -> 0x027e }
            android.content.pm.PackageParser$Package r3 = r3.pkg     // Catch:{ PackageManagerException -> 0x027e }
            java.lang.String r3 = r3.packageName     // Catch:{ PackageManagerException -> 0x027e }
            java.lang.Object r3 = r15.put(r3, r2)     // Catch:{ PackageManagerException -> 0x027e }
            if (r3 == 0) goto L_0x0236
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r1 = r9.installResult     // Catch:{ PackageManagerException -> 0x027e }
            r3 = -5
            java.lang.StringBuilder r4 = new java.lang.StringBuilder     // Catch:{ PackageManagerException -> 0x027e }
            r4.<init>()     // Catch:{ PackageManagerException -> 0x027e }
            java.lang.String r5 = "Duplicate package "
            r4.append(r5)     // Catch:{ PackageManagerException -> 0x027e }
            com.android.server.pm.PackageSetting r5 = r2.pkgSetting     // Catch:{ PackageManagerException -> 0x027e }
            android.content.pm.PackageParser$Package r5 = r5.pkg     // Catch:{ PackageManagerException -> 0x027e }
            java.lang.String r5 = r5.packageName     // Catch:{ PackageManagerException -> 0x027e }
            r4.append(r5)     // Catch:{ PackageManagerException -> 0x027e }
            java.lang.String r5 = " in multi-package install request."
            r4.append(r5)     // Catch:{ PackageManagerException -> 0x027e }
            java.lang.String r4 = r4.toString()     // Catch:{ PackageManagerException -> 0x027e }
            r1.setError(r3, r4)     // Catch:{ PackageManagerException -> 0x027e }
            if (r23 != 0) goto L_0x0214
            java.util.Collection r1 = r15.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x01d5:
            boolean r3 = r1.hasNext()
            if (r3 == 0) goto L_0x01f7
            java.lang.Object r3 = r1.next()
            com.android.server.pm.PackageManagerService$ScanResult r3 = (com.android.server.pm.PackageManagerService.ScanResult) r3
            com.android.server.pm.PackageManagerService$ScanRequest r4 = r3.request
            android.content.pm.PackageParser$Package r4 = r4.pkg
            java.lang.String r4 = r4.packageName
            java.lang.Object r4 = r12.getOrDefault(r4, r10)
            java.lang.Boolean r4 = (java.lang.Boolean) r4
            boolean r4 = r4.booleanValue()
            if (r4 == 0) goto L_0x01f6
            r8.cleanUpAppIdCreation(r3)
        L_0x01f6:
            goto L_0x01d5
        L_0x01f7:
            java.util.Iterator r1 = r30.iterator()
        L_0x01fb:
            boolean r3 = r1.hasNext()
            if (r3 == 0) goto L_0x0214
            java.lang.Object r3 = r1.next()
            com.android.server.pm.PackageManagerService$InstallRequest r3 = (com.android.server.pm.PackageManagerService.InstallRequest) r3
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r4 = r3.installResult
            int r4 = r4.returnCode
            r5 = 1
            if (r4 != r5) goto L_0x0213
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r4 = r3.installResult
            r5 = 0
            r4.returnCode = r5
        L_0x0213:
            goto L_0x01fb
        L_0x0214:
            java.util.Collection r1 = r25.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x021c:
            boolean r3 = r1.hasNext()
            if (r3 == 0) goto L_0x0232
            java.lang.Object r3 = r1.next()
            com.android.server.pm.PackageManagerService$PrepareResult r3 = (com.android.server.pm.PackageManagerService.PrepareResult) r3
            com.android.server.pm.PackageManagerService$PackageFreezer r4 = r3.freezer
            if (r4 == 0) goto L_0x0231
            com.android.server.pm.PackageManagerService$PackageFreezer r4 = r3.freezer
            r4.close()
        L_0x0231:
            goto L_0x021c
        L_0x0232:
            android.os.Trace.traceEnd(r26)
            return
        L_0x0236:
            boolean r3 = r8.optimisticallyRegisterAppId(r2)
            java.lang.Boolean r3 = java.lang.Boolean.valueOf(r3)
            r12.put(r11, r3)
            com.android.server.pm.PackageSetting r3 = r2.pkgSetting
            android.content.pm.PackageParser$Package r3 = r3.pkg
            java.lang.String r3 = r3.packageName
            com.android.server.pm.PackageSetting r4 = r2.pkgSetting
            android.content.pm.PackageParser$Package r4 = r4.pkg
            com.android.server.pm.Settings$VersionInfo r4 = r8.getSettingsVersionForPackage(r4)
            r14.put(r3, r4)
            android.content.pm.SharedLibraryInfo r3 = r2.staticSharedLibraryInfo
            if (r3 == 0) goto L_0x0266
            com.android.server.pm.PackageSetting r3 = r8.getSharedLibLatestVersionSetting(r2)
            if (r3 == 0) goto L_0x0266
            com.android.server.pm.PackageSetting r4 = r2.pkgSetting
            android.content.pm.PackageParser$Package r4 = r4.pkg
            java.lang.String r4 = r4.packageName
            r13.put(r4, r3)
        L_0x0266:
            goto L_0x0191
        L_0x0268:
            r4 = r12
            r6 = r13
            r5 = r14
            r0 = r17
            r14 = r19
            r13 = r20
            r12 = r24
            r7 = r25
            r1 = r26
            r11 = r28
            r3 = 1
            r9 = 0
            goto L_0x0076
        L_0x027e:
            r0 = move-exception
            goto L_0x02df
        L_0x0281:
            r0 = move-exception
            r18 = r4
            r25 = r7
            r28 = r11
            r19 = r14
            r14 = r20
            r11 = r24
            r26 = 262144(0x40000, double:1.295163E-318)
            r24 = r12
            r20 = r13
            r13 = r6
            r12 = r9
            r9 = r1
            goto L_0x02df
        L_0x0299:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r19 = r14
            r14 = r20
            r26 = 262144(0x40000, double:1.295163E-318)
            r12 = r9
            r20 = r13
            r4 = r6
            r6 = r14
            r7 = r15
            r5 = r19
            r3 = r20
            goto L_0x065d
        L_0x02b3:
            r0 = move-exception
            r18 = r4
            r25 = r7
            r28 = r11
            r24 = r12
            r19 = r14
            r14 = r20
            r26 = 262144(0x40000, double:1.295163E-318)
            r11 = r3
            r12 = r9
            r20 = r13
            r9 = r1
            r13 = r6
            goto L_0x02df
        L_0x02ca:
            r0 = move-exception
            r18 = r4
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r26 = 262144(0x40000, double:1.295163E-318)
            r11 = r3
            r14 = r5
            r13 = r6
            r12 = r9
            r9 = r1
        L_0x02df:
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r1 = r9.installResult     // Catch:{ all -> 0x0468 }
            java.lang.String r2 = "Scanning Failed."
            r1.setError(r2, r0)     // Catch:{ all -> 0x0468 }
            if (r23 != 0) goto L_0x032f
            java.util.Collection r1 = r15.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x02f0:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x0312
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$ScanResult r2 = (com.android.server.pm.PackageManagerService.ScanResult) r2
            com.android.server.pm.PackageManagerService$ScanRequest r3 = r2.request
            android.content.pm.PackageParser$Package r3 = r3.pkg
            java.lang.String r3 = r3.packageName
            java.lang.Object r3 = r12.getOrDefault(r3, r10)
            java.lang.Boolean r3 = (java.lang.Boolean) r3
            boolean r3 = r3.booleanValue()
            if (r3 == 0) goto L_0x0311
            r8.cleanUpAppIdCreation(r2)
        L_0x0311:
            goto L_0x02f0
        L_0x0312:
            java.util.Iterator r1 = r30.iterator()
        L_0x0316:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x032f
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$InstallRequest r2 = (com.android.server.pm.PackageManagerService.InstallRequest) r2
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r3 = r2.installResult
            int r3 = r3.returnCode
            r4 = 1
            if (r3 != r4) goto L_0x032e
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r3 = r2.installResult
            r4 = 0
            r3.returnCode = r4
        L_0x032e:
            goto L_0x0316
        L_0x032f:
            java.util.Collection r1 = r25.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x0337:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x034d
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$PrepareResult r2 = (com.android.server.pm.PackageManagerService.PrepareResult) r2
            com.android.server.pm.PackageManagerService$PackageFreezer r3 = r2.freezer
            if (r3 == 0) goto L_0x034c
            com.android.server.pm.PackageManagerService$PackageFreezer r3 = r2.freezer
            r3.close()
        L_0x034c:
            goto L_0x0337
        L_0x034d:
            android.os.Trace.traceEnd(r26)
            return
        L_0x0351:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r26 = 262144(0x40000, double:1.295163E-318)
            goto L_0x036b
        L_0x0360:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
        L_0x036b:
            r12 = r9
            r4 = r6
            r7 = r15
            r3 = r20
            r6 = r5
            r5 = r19
            goto L_0x065d
        L_0x0375:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r26 = 262144(0x40000, double:1.295163E-318)
            goto L_0x03a0
        L_0x0384:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r26 = 262144(0x40000, double:1.295163E-318)
            goto L_0x03b3
        L_0x0393:
            r0 = move-exception
            r26 = r3
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
        L_0x03a0:
            r14 = r5
            r13 = r6
            r12 = r9
            r9 = r1
            goto L_0x0464
        L_0x03a6:
            r0 = move-exception
            r26 = r3
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
        L_0x03b3:
            r14 = r5
            r13 = r6
            r12 = r9
            r9 = r1
            goto L_0x03de
        L_0x03b8:
            r0 = move-exception
            r9 = r1
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r26 = 262144(0x40000, double:1.295163E-318)
            r12 = r4
            r14 = r5
            r13 = r6
            goto L_0x0464
        L_0x03cc:
            r0 = move-exception
            r9 = r1
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r26 = 262144(0x40000, double:1.295163E-318)
            r12 = r4
            r14 = r5
            r13 = r6
        L_0x03de:
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r1 = r9.installResult     // Catch:{ all -> 0x0463 }
            int r2 = r0.error     // Catch:{ all -> 0x0463 }
            java.lang.String r3 = r0.getMessage()     // Catch:{ all -> 0x0463 }
            r1.setError(r2, r3)     // Catch:{ all -> 0x0463 }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r1 = r9.installResult     // Catch:{ all -> 0x0463 }
            java.lang.String r2 = r0.conflictingPackage     // Catch:{ all -> 0x0463 }
            r1.origPackage = r2     // Catch:{ all -> 0x0463 }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r1 = r9.installResult     // Catch:{ all -> 0x0463 }
            java.lang.String r2 = r0.conflictingPermission     // Catch:{ all -> 0x0463 }
            r1.origPermission = r2     // Catch:{ all -> 0x0463 }
            android.os.Trace.traceEnd(r26)
            if (r23 != 0) goto L_0x0441
            java.util.Collection r1 = r15.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x0402:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x0424
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$ScanResult r2 = (com.android.server.pm.PackageManagerService.ScanResult) r2
            com.android.server.pm.PackageManagerService$ScanRequest r3 = r2.request
            android.content.pm.PackageParser$Package r3 = r3.pkg
            java.lang.String r3 = r3.packageName
            java.lang.Object r3 = r12.getOrDefault(r3, r10)
            java.lang.Boolean r3 = (java.lang.Boolean) r3
            boolean r3 = r3.booleanValue()
            if (r3 == 0) goto L_0x0423
            r8.cleanUpAppIdCreation(r2)
        L_0x0423:
            goto L_0x0402
        L_0x0424:
            java.util.Iterator r1 = r30.iterator()
        L_0x0428:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x0441
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$InstallRequest r2 = (com.android.server.pm.PackageManagerService.InstallRequest) r2
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r3 = r2.installResult
            int r3 = r3.returnCode
            r4 = 1
            if (r3 != r4) goto L_0x0440
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r3 = r2.installResult
            r4 = 0
            r3.returnCode = r4
        L_0x0440:
            goto L_0x0428
        L_0x0441:
            java.util.Collection r1 = r25.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x0449:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x045f
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$PrepareResult r2 = (com.android.server.pm.PackageManagerService.PrepareResult) r2
            com.android.server.pm.PackageManagerService$PackageFreezer r3 = r2.freezer
            if (r3 == 0) goto L_0x045e
            com.android.server.pm.PackageManagerService$PackageFreezer r3 = r2.freezer
            r3.close()
        L_0x045e:
            goto L_0x0449
        L_0x045f:
            android.os.Trace.traceEnd(r26)
            return
        L_0x0463:
            r0 = move-exception
        L_0x0464:
            android.os.Trace.traceEnd(r26)
            throw r0
        L_0x0468:
            r0 = move-exception
            r4 = r13
            r6 = r14
            r7 = r15
            r5 = r19
            r3 = r20
            goto L_0x065d
        L_0x0472:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r12 = r4
            r4 = r6
            r7 = r15
            r3 = r20
            r6 = r5
            r5 = r19
            goto L_0x065d
        L_0x0487:
            r26 = r1
            r25 = r7
            r28 = r11
            r24 = r12
            r20 = r13
            r19 = r14
            r12 = r4
            r14 = r5
            r13 = r6
            com.android.server.pm.PackageManagerService$ReconcileRequest r0 = new com.android.server.pm.PackageManagerService$ReconcileRequest     // Catch:{ all -> 0x0647 }
            android.util.ArrayMap<java.lang.String, android.util.LongSparseArray<android.content.pm.SharedLibraryInfo>> r1 = r8.mSharedLibraries     // Catch:{ all -> 0x0647 }
            android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package> r2 = r8.mPackages     // Catch:{ all -> 0x0647 }
            java.util.Map r2 = java.util.Collections.unmodifiableMap(r2)     // Catch:{ all -> 0x0647 }
            r22 = 0
            r4 = r13
            r3 = r20
            r13 = r0
            r6 = r14
            r5 = r19
            r14 = r15
            r7 = r15
            r15 = r5
            r16 = r3
            r17 = r25
            r18 = r1
            r19 = r2
            r20 = r6
            r21 = r4
            r13.<init>(r14, r15, r16, r17, r18, r19, r20, r21)     // Catch:{ all -> 0x0645 }
            r1 = r0
            r2 = 0
            android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package> r9 = r8.mPackages     // Catch:{ all -> 0x0645 }
            monitor-enter(r9)     // Catch:{ all -> 0x0645 }
            java.lang.String r0 = "reconcilePackages"
            r13 = r26
            android.os.Trace.traceBegin(r13, r0)     // Catch:{ ReconcileFailure -> 0x05ad }
            com.android.server.pm.Settings r0 = r8.mSettings     // Catch:{ ReconcileFailure -> 0x05ad }
            com.android.server.pm.KeySetManagerService r0 = r0.mKeySetManagerService     // Catch:{ ReconcileFailure -> 0x05ad }
            java.util.Map r0 = reconcilePackagesLocked(r1, r0)     // Catch:{ ReconcileFailure -> 0x05ad }
            r11 = r0
            android.os.Trace.traceEnd(r13)     // Catch:{ all -> 0x0642 }
            java.lang.String r0 = "commitPackages"
            android.os.Trace.traceBegin(r13, r0)     // Catch:{ all -> 0x0584 }
            com.android.server.pm.PackageManagerService$CommitRequest r0 = new com.android.server.pm.PackageManagerService$CommitRequest     // Catch:{ all -> 0x0584 }
            com.android.server.pm.UserManagerService r15 = com.android.server.pm.PackageManagerService.sUserManager     // Catch:{ all -> 0x0584 }
            int[] r15 = r15.getUserIds()     // Catch:{ all -> 0x0584 }
            r13 = 0
            r0.<init>(r11, r15)     // Catch:{ all -> 0x0584 }
            r2 = r0
            r8.commitPackagesLocked(r2)     // Catch:{ all -> 0x0584 }
            r23 = 1
            java.util.Collection r0 = r25.values()
            java.util.Iterator r0 = r0.iterator()
        L_0x04f4:
            boolean r13 = r0.hasNext()
            if (r13 == 0) goto L_0x050a
            java.lang.Object r13 = r0.next()
            com.android.server.pm.PackageManagerService$PrepareResult r13 = (com.android.server.pm.PackageManagerService.PrepareResult) r13
            com.android.server.pm.PackageManagerService$PackageFreezer r14 = r13.freezer
            if (r14 == 0) goto L_0x0509
            com.android.server.pm.PackageManagerService$PackageFreezer r14 = r13.freezer
            r14.close()
        L_0x0509:
            goto L_0x04f4
        L_0x050a:
            r13 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r13)
            monitor-exit(r9)
            r8.executePostCommitSteps(r2)
            if (r23 != 0) goto L_0x055e
            java.util.Collection r0 = r7.values()
            java.util.Iterator r0 = r0.iterator()
        L_0x051f:
            boolean r1 = r0.hasNext()
            if (r1 == 0) goto L_0x0541
            java.lang.Object r1 = r0.next()
            com.android.server.pm.PackageManagerService$ScanResult r1 = (com.android.server.pm.PackageManagerService.ScanResult) r1
            com.android.server.pm.PackageManagerService$ScanRequest r2 = r1.request
            android.content.pm.PackageParser$Package r2 = r2.pkg
            java.lang.String r2 = r2.packageName
            java.lang.Object r2 = r12.getOrDefault(r2, r10)
            java.lang.Boolean r2 = (java.lang.Boolean) r2
            boolean r2 = r2.booleanValue()
            if (r2 == 0) goto L_0x0540
            r8.cleanUpAppIdCreation(r1)
        L_0x0540:
            goto L_0x051f
        L_0x0541:
            java.util.Iterator r0 = r30.iterator()
        L_0x0545:
            boolean r1 = r0.hasNext()
            if (r1 == 0) goto L_0x055e
            java.lang.Object r1 = r0.next()
            com.android.server.pm.PackageManagerService$InstallRequest r1 = (com.android.server.pm.PackageManagerService.InstallRequest) r1
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r2 = r1.installResult
            int r2 = r2.returnCode
            r9 = 1
            if (r2 != r9) goto L_0x055d
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r2 = r1.installResult
            r9 = 0
            r2.returnCode = r9
        L_0x055d:
            goto L_0x0545
        L_0x055e:
            java.util.Collection r0 = r25.values()
            java.util.Iterator r0 = r0.iterator()
        L_0x0566:
            boolean r1 = r0.hasNext()
            if (r1 == 0) goto L_0x057c
            java.lang.Object r1 = r0.next()
            com.android.server.pm.PackageManagerService$PrepareResult r1 = (com.android.server.pm.PackageManagerService.PrepareResult) r1
            com.android.server.pm.PackageManagerService$PackageFreezer r2 = r1.freezer
            if (r2 == 0) goto L_0x057b
            com.android.server.pm.PackageManagerService$PackageFreezer r2 = r1.freezer
            r2.close()
        L_0x057b:
            goto L_0x0566
        L_0x057c:
            r1 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r1)
            return
        L_0x0584:
            r0 = move-exception
            java.util.Collection r13 = r25.values()
            java.util.Iterator r13 = r13.iterator()
        L_0x058d:
            boolean r14 = r13.hasNext()
            if (r14 == 0) goto L_0x05a3
            java.lang.Object r14 = r13.next()
            com.android.server.pm.PackageManagerService$PrepareResult r14 = (com.android.server.pm.PackageManagerService.PrepareResult) r14
            com.android.server.pm.PackageManagerService$PackageFreezer r15 = r14.freezer
            if (r15 == 0) goto L_0x05a2
            com.android.server.pm.PackageManagerService$PackageFreezer r15 = r14.freezer
            r15.close()
        L_0x05a2:
            goto L_0x058d
        L_0x05a3:
            r13 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r13)
            throw r0
        L_0x05aa:
            r0 = move-exception
            goto L_0x063b
        L_0x05ad:
            r0 = move-exception
            java.util.Iterator r11 = r30.iterator()     // Catch:{ all -> 0x05aa }
        L_0x05b2:
            boolean r13 = r11.hasNext()     // Catch:{ all -> 0x05aa }
            if (r13 == 0) goto L_0x05c6
            java.lang.Object r13 = r11.next()     // Catch:{ all -> 0x05aa }
            com.android.server.pm.PackageManagerService$InstallRequest r13 = (com.android.server.pm.PackageManagerService.InstallRequest) r13     // Catch:{ all -> 0x05aa }
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r14 = r13.installResult     // Catch:{ all -> 0x05aa }
            java.lang.String r15 = "Reconciliation failed..."
            r14.setError(r15, r0)     // Catch:{ all -> 0x05aa }
            goto L_0x05b2
        L_0x05c6:
            r13 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r13)
            monitor-exit(r9)
            if (r23 != 0) goto L_0x0616
            java.util.Collection r9 = r7.values()
            java.util.Iterator r9 = r9.iterator()
        L_0x05d7:
            boolean r11 = r9.hasNext()
            if (r11 == 0) goto L_0x05f9
            java.lang.Object r11 = r9.next()
            com.android.server.pm.PackageManagerService$ScanResult r11 = (com.android.server.pm.PackageManagerService.ScanResult) r11
            com.android.server.pm.PackageManagerService$ScanRequest r13 = r11.request
            android.content.pm.PackageParser$Package r13 = r13.pkg
            java.lang.String r13 = r13.packageName
            java.lang.Object r13 = r12.getOrDefault(r13, r10)
            java.lang.Boolean r13 = (java.lang.Boolean) r13
            boolean r13 = r13.booleanValue()
            if (r13 == 0) goto L_0x05f8
            r8.cleanUpAppIdCreation(r11)
        L_0x05f8:
            goto L_0x05d7
        L_0x05f9:
            java.util.Iterator r9 = r30.iterator()
        L_0x05fd:
            boolean r10 = r9.hasNext()
            if (r10 == 0) goto L_0x0616
            java.lang.Object r10 = r9.next()
            com.android.server.pm.PackageManagerService$InstallRequest r10 = (com.android.server.pm.PackageManagerService.InstallRequest) r10
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r11 = r10.installResult
            int r11 = r11.returnCode
            r13 = 1
            if (r11 != r13) goto L_0x0615
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r11 = r10.installResult
            r13 = 0
            r11.returnCode = r13
        L_0x0615:
            goto L_0x05fd
        L_0x0616:
            java.util.Collection r9 = r25.values()
            java.util.Iterator r9 = r9.iterator()
        L_0x061e:
            boolean r10 = r9.hasNext()
            if (r10 == 0) goto L_0x0634
            java.lang.Object r10 = r9.next()
            com.android.server.pm.PackageManagerService$PrepareResult r10 = (com.android.server.pm.PackageManagerService.PrepareResult) r10
            com.android.server.pm.PackageManagerService$PackageFreezer r11 = r10.freezer
            if (r11 == 0) goto L_0x0633
            com.android.server.pm.PackageManagerService$PackageFreezer r11 = r10.freezer
            r11.close()
        L_0x0633:
            goto L_0x061e
        L_0x0634:
            r9 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r9)
            return
        L_0x063b:
            r13 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r13)
            throw r0
        L_0x0642:
            r0 = move-exception
            monitor-exit(r9)
            throw r0
        L_0x0645:
            r0 = move-exception
            goto L_0x065d
        L_0x0647:
            r0 = move-exception
            r4 = r13
            r6 = r14
            r7 = r15
            r5 = r19
            r3 = r20
            goto L_0x065d
        L_0x0650:
            r0 = move-exception
            r25 = r7
            r28 = r11
            r24 = r12
            r3 = r13
            r7 = r15
            r12 = r4
            r4 = r6
            r6 = r5
            r5 = r14
        L_0x065d:
            if (r23 != 0) goto L_0x06a8
            java.util.Collection r1 = r7.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x0667:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x0689
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$ScanResult r2 = (com.android.server.pm.PackageManagerService.ScanResult) r2
            com.android.server.pm.PackageManagerService$ScanRequest r9 = r2.request
            android.content.pm.PackageParser$Package r9 = r9.pkg
            java.lang.String r9 = r9.packageName
            java.lang.Object r9 = r12.getOrDefault(r9, r10)
            java.lang.Boolean r9 = (java.lang.Boolean) r9
            boolean r9 = r9.booleanValue()
            if (r9 == 0) goto L_0x0688
            r8.cleanUpAppIdCreation(r2)
        L_0x0688:
            goto L_0x0667
        L_0x0689:
            java.util.Iterator r1 = r30.iterator()
        L_0x068d:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x06a8
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$InstallRequest r2 = (com.android.server.pm.PackageManagerService.InstallRequest) r2
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r9 = r2.installResult
            int r9 = r9.returnCode
            r10 = 1
            if (r9 != r10) goto L_0x06a6
            com.android.server.pm.PackageManagerService$PackageInstalledInfo r9 = r2.installResult
            r11 = 0
            r9.returnCode = r11
            goto L_0x06a7
        L_0x06a6:
            r11 = 0
        L_0x06a7:
            goto L_0x068d
        L_0x06a8:
            java.util.Collection r1 = r25.values()
            java.util.Iterator r1 = r1.iterator()
        L_0x06b0:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x06c6
            java.lang.Object r2 = r1.next()
            com.android.server.pm.PackageManagerService$PrepareResult r2 = (com.android.server.pm.PackageManagerService.PrepareResult) r2
            com.android.server.pm.PackageManagerService$PackageFreezer r9 = r2.freezer
            if (r9 == 0) goto L_0x06c5
            com.android.server.pm.PackageManagerService$PackageFreezer r9 = r2.freezer
            r9.close()
        L_0x06c5:
            goto L_0x06b0
        L_0x06c6:
            r1 = 262144(0x40000, double:1.295163E-318)
            android.os.Trace.traceEnd(r1)
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.installPackagesLI(java.util.List):void");
    }

    private void executePostCommitSteps(CommitRequest commitRequest) {
        String str;
        PackageManagerService packageManagerService = this;
        for (ReconciledPackage reconciledPkg : commitRequest.reconciledPackages.values()) {
            boolean instantApp = (reconciledPkg.scanResult.request.scanFlags & 16384) != 0;
            PackageParser.Package pkg = reconciledPkg.pkgSetting.pkg;
            String packageName = pkg.packageName;
            packageManagerService.prepareAppDataAfterInstallLIF(pkg);
            if (reconciledPkg.prepareResult.clearCodeCache) {
                packageManagerService.clearAppDataLIF(pkg, -1, 39);
            }
            if (mHwPMSEx.isMplPackage(reconciledPkg.prepareResult.existingPackage)) {
                Slog.i(TAG, "[DCP] -> clearMplCacheLIF for package " + pkg);
                mHwPMSEx.clearMplCacheLIF(pkg, -1, 7);
            }
            if (reconciledPkg.prepareResult.replace) {
                packageManagerService.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
            }
            packageManagerService.mArtManagerService.prepareAppProfiles(pkg, packageManagerService.resolveUserIds(reconciledPkg.installArgs.user.getIdentifier()), true);
            if ((!instantApp || Settings.Global.getInt(packageManagerService.mContext.getContentResolver(), "instant_app_dexopt_enabled", 0) != 0) && (pkg.applicationInfo.flags & 2) == 0) {
                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
                    Trace.traceBegin(262144, "compileLayouts");
                    packageManagerService.mViewCompiler.compileLayouts(pkg);
                    Trace.traceEnd(262144);
                }
                Trace.traceBegin(262144, "dexopt");
                DexoptOptions dexoptOptions = new DexoptOptions(packageName, 2, (int) UsbTerminalTypes.TERMINAL_BIDIR_SKRPHONE_SUPRESS);
                PackageDexOptimizer packageDexOptimizer = packageManagerService.mPackageDexOptimizer;
                CompilerStats.PackageStats orCreateCompilerPackageStats = packageManagerService.getOrCreateCompilerPackageStats(pkg);
                PackageDexUsage.PackageUseInfo packageUseInfoOrDefault = packageManagerService.mDexManager.getPackageUseInfoOrDefault(packageName);
                str = TAG;
                packageDexOptimizer.performDexOpt(pkg, null, orCreateCompilerPackageStats, packageUseInfoOrDefault, dexoptOptions);
                Trace.traceEnd(262144);
            } else {
                str = TAG;
            }
            if (SystemProperties.getBoolean(MAPLE_DECOUPLE_CACHE_ENABLE, true) && mHwPMSEx.isMygoteEnabled() && !((pkg.applicationInfo.hwFlags & DumpState.DUMP_SERVICE_PERMISSIONS) == 0 && (pkg.applicationInfo.hwFlags & 8388608) == 0)) {
                Slog.i(str, "[DCP] -> executePostCommitSteps is called " + pkg.baseCodePath);
                long startTime = System.nanoTime();
                int cacheLevel = mHwPMSEx.getCacheLevelForMapleApp(pkg);
                String mapleClassPath = mHwPMSEx.obtainMapleClassPathByPkg(pkg);
                if (!(cacheLevel == -1 || mapleClassPath == null)) {
                    mHwPMSEx.callGenMplCacheAtPmsInstaller(pkg.baseCodePath, UserHandle.getSharedAppGid(pkg.applicationInfo.uid), cacheLevel, mapleClassPath);
                }
                Slog.i(str, "[DCP] -> extra time incurred at installation : " + ((int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime)) + " seconds");
            }
            BackgroundDexOptService.notifyPackageChanged(packageName);
            packageManagerService = this;
        }
    }

    private static class PrepareResult {
        public final PackageSetting[] childPackageSettings;
        public final boolean clearCodeCache;
        public final PackageSetting disabledPs;
        public final PackageParser.Package existingPackage;
        public final PackageFreezer freezer;
        public final int installReason;
        public final String installerPackageName;
        public final PackageSetting originalPs;
        public final PackageParser.Package packageToScan;
        public final int parseFlags;
        public final String renamedPackage;
        public final boolean replace;
        public final int scanFlags;
        public final boolean system;
        public final UserHandle user;
        public final String volumeUuid;

        private PrepareResult(int installReason2, String volumeUuid2, String installerPackageName2, UserHandle user2, boolean replace2, int scanFlags2, int parseFlags2, PackageParser.Package existingPackage2, PackageParser.Package packageToScan2, boolean clearCodeCache2, boolean system2, String renamedPackage2, PackageFreezer freezer2, PackageSetting originalPs2, PackageSetting disabledPs2, PackageSetting[] childPackageSettings2) {
            this.installReason = installReason2;
            this.volumeUuid = volumeUuid2;
            this.installerPackageName = installerPackageName2;
            this.user = user2;
            this.replace = replace2;
            this.scanFlags = scanFlags2;
            this.parseFlags = parseFlags2;
            this.existingPackage = existingPackage2;
            this.packageToScan = packageToScan2;
            this.clearCodeCache = clearCodeCache2;
            this.system = system2;
            this.renamedPackage = renamedPackage2;
            this.freezer = freezer2;
            this.originalPs = originalPs2;
            this.disabledPs = disabledPs2;
            this.childPackageSettings = childPackageSettings2;
        }
    }

    private static class PrepareFailure extends PackageManagerException {
        public String conflictingPackage;
        public String conflictingPermission;

        PrepareFailure(int error) {
            super(error, "Failed to prepare for install.");
        }

        PrepareFailure(int error, String detailMessage) {
            super(error, detailMessage);
        }

        /* JADX WARNING: Illegal instructions before constructor call */
        PrepareFailure(String message, Exception e) {
            super(r0, ExceptionUtils.getCompleteMessage(message, e));
            int i;
            if (e instanceof PackageParser.PackageParserException) {
                i = ((PackageParser.PackageParserException) e).error;
            } else {
                i = ((PackageManagerException) e).error;
            }
        }

        /* access modifiers changed from: package-private */
        public PrepareFailure conflictsWithExistingPermission(String conflictingPermission2, String conflictingPackage2) {
            this.conflictingPermission = conflictingPermission2;
            this.conflictingPackage = conflictingPackage2;
            return this;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:384:0x08f7, code lost:
        if (r30 == false) goto L_0x0912;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:385:0x08f9, code lost:
        if (r35 != false) goto L_0x0908;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:386:0x08fb, code lost:
        if (r5 != false) goto L_0x08fe;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:388:0x0907, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-116, "Cannot update a system app with an instant app");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:390:0x0911, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-19, "Cannot install updates to system apps on sdcard");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:391:0x0912, code lost:
        android.installermanager.InstallerMgr.getInstance().installPackage(0, r51.installerPackageName, r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:392:0x091e, code lost:
        if (r51.move == null) goto L_0x095b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:393:0x0920, code lost:
        r4 = (r5 | 1) | 256;
        r6 = r50.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:394:0x0926, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:396:?, code lost:
        r5 = r50.mSettings.mPackages.get(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:397:0x0931, code lost:
        if (r5 != null) goto L_0x0949;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:398:0x0933, code lost:
        r52.setError(android.hardware.biometrics.fingerprint.V2_1.RequestStatus.SYS_ETIMEDOUT, "Missing settings for moved package " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:399:0x0949, code lost:
        r14.applicationInfo.primaryCpuAbi = r5.primaryCpuAbiString;
        r14.applicationInfo.secondaryCpuAbi = r5.secondaryCpuAbiString;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:400:0x0955, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:406:0x095b, code lost:
        r5 = r5 | 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:409:0x0963, code lost:
        if (android.text.TextUtils.isEmpty(r14.cpuAbiOverride) == false) goto L_0x0978;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:411:?, code lost:
        r4 = r51.abiOverride;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:412:0x0968, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:413:0x0969, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:414:0x0978, code lost:
        r4 = r14.cpuAbiOverride;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:416:0x097e, code lost:
        if (r14.isLibrary() != false) goto L_0x0982;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:417:0x0980, code lost:
        r6 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:418:0x0982, code lost:
        r6 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:419:0x0983, code lost:
        derivePackageAbi(r14, r4, r6);
        r4 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:421:0x098d, code lost:
        if (r51.doRename(r52.returnCode, r14) == false) goto L_0x11e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:423:?, code lost:
        setUpFsVerityIfPossible(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:424:0x0993, code lost:
        if (r5 != false) goto L_0x09a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:425:0x0995, code lost:
        r6 = r33;
        startIntentFilterVerifications(r51.user.getIdentifier(), r6, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:426:0x09a1, code lost:
        r6 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:427:0x09a5, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x09bd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:428:0x09a7, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "Not verifying instant app install for app links: " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:430:0x09c1, code lost:
        if ((r32 & 4096) != 0) goto L_0x0a37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:431:0x09c3, code lost:
        r5 = com.huawei.android.app.HwActivityTaskManager.getLastResumedActivity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:432:0x09c7, code lost:
        if (r5 == null) goto L_0x0a37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:434:0x09cd, code lost:
        if (r5.getComponentName() == null) goto L_0x0a37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:435:0x09cf, code lost:
        r7 = r5.getComponentName().getPackageName();
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "top pkgName: " + r7 + ", update pkgName: " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:436:0x09fa, code lost:
        if (r11.equals(r7) == false) goto L_0x0a37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:437:0x09fc, code lost:
        r8 = getCallingAppName(r50.mContext, r14);
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "appName: " + r8);
        android.widget.Toast.makeText(r50.mContext, java.lang.String.format(java.util.Locale.ENGLISH, r50.mContext.getString(17041396), r8), 1).show();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:438:0x0a37, code lost:
        r32 = freezePackageForInstall(r11, r32, "installPackageLI");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:439:0x0a47, code lost:
        if (r6 == false) goto L_0x108c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:443:0x0a50, code lost:
        if (r14.applicationInfo.isStaticSharedLibrary() == false) goto L_0x0acb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:446:0x0a54, code lost:
        r33 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:448:?, code lost:
        r5 = r50.mPackages.get(r14.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:449:0x0a5e, code lost:
        if (r5 == null) goto L_0x0aa0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:451:0x0a62, code lost:
        r34 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:454:0x0a6a, code lost:
        if ("com.huawei.androidx".equals(r14.manifestPackageName) == false) goto L_0x0a78;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:455:0x0a6c, code lost:
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:456:0x0a76, code lost:
        if (r5.getLongVersionCode() <= r14.getLongVersionCode()) goto L_0x0acf;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:458:0x0a82, code lost:
        if (r5.getLongVersionCode() != r14.getLongVersionCode()) goto L_0x0a85;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:459:0x0a84, code lost:
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:461:0x0a8f, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-5, "Packages declaring static-shared libs cannot be updated");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:462:0x0a90, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:463:0x0a91, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:464:0x0aa0, code lost:
        r34 = r6;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:465:0x0aa5, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:466:0x0aa6, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:467:0x0ab7, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:468:0x0ab8, code lost:
        r33 = true;
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:469:0x0acb, code lost:
        r33 = true;
        r34 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:471:0x0ad1, code lost:
        if ((r4 & true) == false) goto L_0x0ad5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:472:0x0ad3, code lost:
        r5 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:473:0x0ad5, code lost:
        r5 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:475:?, code lost:
        r6 = r14.packageName;
        r10 = r50.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:476:0x0ada, code lost:
        monitor-enter(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:477:0x0adb, code lost:
        r36 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:479:?, code lost:
        r7 = r50.mPackages.get(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:480:0x0ae5, code lost:
        r37 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:482:?, code lost:
        r8 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:483:0x0aee, code lost:
        r40 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:485:?, code lost:
        r8.append("replacePackageLI: new = ");
        r8.append(r14);
        r8.append(", old = ");
        r8.append(r7);
        android.util.Flog.i(207, r8.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:486:0x0b0c, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0b4e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:489:?, code lost:
        r9 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:490:0x0b15, code lost:
        r41 = r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:492:?, code lost:
        r9.append("replacePackageLI: new=");
        r9.append(r14);
        r9.append(", old=");
        r9.append(r7);
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, r9.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:493:0x0b30, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:494:0x0b31, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:495:0x0b3e, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:496:0x0b3f, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:497:0x0b4e, code lost:
        r41 = r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:500:0x0b58, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.forbidGMSUpgrade(r14, r7, r50.callingSessionUid) != false) goto L_0x1002;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:501:0x0b5a, code lost:
        r8 = r50.mSettings.mPackages.get(r6);
        r9 = r50.mSettings.getDisabledSystemPkgLPr(r8);
        r12 = r50.mSettings.mKeySetManagerService;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:502:0x0b72, code lost:
        if (r12.shouldCheckUpgradeKeySetLocked(r8, r4) == false) goto L_0x0bae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:505:0x0b78, code lost:
        if (r12.checkUpgradeKeySetLocked(r8, r14) == false) goto L_0x0b82;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:506:0x0b7a, code lost:
        r42 = r9;
        r44 = r27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:507:0x0b82, code lost:
        r12 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:510:?, code lost:
        r12.append("New package not signed by keys specified by upgrade-keysets: ");
        r12.append(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:511:0x0b9f, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-7, r12.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:512:0x0ba0, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:513:0x0ba1, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:514:0x0bae, code lost:
        r42 = r9;
        r44 = r27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:517:0x0bbd, code lost:
        if (r14.mSigningDetails.checkCapability(r7.mSigningDetails, 1) != false) goto L_0x0c1d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:519:0x0bc9, code lost:
        if (r7.mSigningDetails.checkCapability(r14.mSigningDetails, 8) != false) goto L_0x0c1d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:521:0x0bd9, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isSystemSignatureUpdated(r7.mSigningDetails.signatures, r14.mSigningDetails.signatures) == false) goto L_0x0bf9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:522:0x0bdb, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "CertCompat: " + r14.packageName + " system signature updated. Ignore signature matching.");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:524:0x0c10, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-7, "New package has a different signature: " + r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:525:0x0c11, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:526:0x0c12, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:528:0x0c1f, code lost:
        if (r7.restrictUpdateHash == null) goto L_0x0cc2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:531:0x0c25, code lost:
        if (r7.isSystem() == false) goto L_0x0cc2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:534:?, code lost:
        r9 = java.security.MessageDigest.getInstance("SHA-512");
        updateDigest(r9, new java.io.File(r14.baseCodePath));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:535:0x0c3d, code lost:
        if (com.android.internal.util.ArrayUtils.isEmpty(r14.splitCodePaths) != false) goto L_0x0c60;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:536:0x0c3f, code lost:
        r12 = r14.splitCodePaths;
        r13 = r12.length;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:537:0x0c42, code lost:
        r16 = r32;
        r15 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:538:0x0c45, code lost:
        if (r15 >= r13) goto L_0x0c62;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:540:?, code lost:
        updateDigest(r9, new java.io.File(r12[r15]));
        r15 = r15 + 1;
        r12 = r12;
        r13 = r13;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:541:0x0c60, code lost:
        r16 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:546:0x0c6e, code lost:
        if (java.util.Arrays.equals(r7.restrictUpdateHash, r9.digest()) == false) goto L_0x0c75;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:547:0x0c70, code lost:
        r14.restrictUpdateHash = r7.restrictUpdateHash;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:549:0x0c8c, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-2, "New package fails restrict-update check: " + r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:555:0x0cab, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-2, "Could not compute hash: " + r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:556:0x0cac, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:557:0x0cad, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:558:0x0cb6, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:559:0x0cb7, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:560:0x0cc2, code lost:
        r16 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:562:?, code lost:
        r9 = getParentOrChildPackageChangedSharedUser(r7, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:563:0x0cc9, code lost:
        if (r9 != null) goto L_0x0fbe;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:564:0x0ccb, code lost:
        r12 = com.android.server.pm.PackageManagerService.sUserManager.getUserIds();
        r15 = r8.queryInstalledUsers(r12, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:566:0x0cd7, code lost:
        if (r5 == false) goto L_0x0d72;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:569:0x0cdb, code lost:
        if (r51.user == null) goto L_0x0d27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:572:0x0ce6, code lost:
        if (r51.user.getIdentifier() != -1) goto L_0x0ceb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:576:0x0cf5, code lost:
        if (r8.getInstantApp(r51.user.getIdentifier()) == false) goto L_0x0cf9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:578:0x0cf9, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Can't replace full app with instant app: " + r6 + " for user: " + r51.user.getIdentifier());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:579:0x0d26, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-116);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:581:0x0d2b, code lost:
        r5 = r12.length;
        r9 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:582:0x0d2d, code lost:
        if (r9 >= r5) goto L_0x0d76;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:583:0x0d2f, code lost:
        r15 = r12[r9];
     */
    /* JADX WARNING: Code restructure failed: missing block: B:584:0x0d35, code lost:
        if (r8.getInstantApp(r15) == false) goto L_0x0d3a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:585:0x0d37, code lost:
        r9 = r9 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:586:0x0d3a, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Can't replace full app with instant app: " + r6 + " for user: " + r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:587:0x0d5f, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-116);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:588:0x0d60, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:589:0x0d61, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:590:0x0d68, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:591:0x0d69, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:594:?, code lost:
        monitor-exit(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:596:?, code lost:
        r52.removedInfo = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r50);
        r52.removedInfo.uid = r7.applicationInfo.uid;
        r52.removedInfo.removedPackage = r7.packageName;
        r52.removedInfo.installerPackageName = r8.installerPackageName;
        r2 = r52.removedInfo;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:597:0x0d96, code lost:
        if (r14.staticSharedLibName == null) goto L_0x0d9a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:598:0x0d98, code lost:
        r5 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:599:0x0d9a, code lost:
        r5 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:600:0x0d9b, code lost:
        r2.isStaticSharedLib = r5;
        r52.removedInfo.isUpdate = true;
        r52.removedInfo.origUsers = r15;
        r52.removedInfo.installReasons = new android.util.SparseArray<>(r15.length);
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:602:0x0db5, code lost:
        if (r5 >= r15.length) goto L_0x0ddb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:604:?, code lost:
        r9 = r15[r5];
        r52.removedInfo.installReasons.put(r9, java.lang.Integer.valueOf(r8.getInstallReason(r9)));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:605:0x0dc8, code lost:
        r5 = r5 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:606:0x0dcb, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:607:0x0dcc, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:608:0x0ddb, code lost:
        r5 = r50.mSettings.getChildSettingsLPr(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:609:0x0de1, code lost:
        if (r5 == null) goto L_0x0e94;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:610:0x0de3, code lost:
        r9 = r5.length;
        r10 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:611:0x0de5, code lost:
        if (r10 >= r9) goto L_0x0e8d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:612:0x0de7, code lost:
        r15 = r5[r10];
        r18 = false;
        r18 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:613:0x0deb, code lost:
        if (r15 != null) goto L_0x0df2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:614:0x0ded, code lost:
        r2 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:615:0x0df2, code lost:
        r2 = r15.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:617:0x0df8, code lost:
        if (r52.addedChildPackages == null) goto L_0x0e33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:618:0x0dfa, code lost:
        r31 = r6;
        r5 = r52.addedChildPackages.get(r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:619:0x0e06, code lost:
        if (r5 == null) goto L_0x0e30;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:620:0x0e08, code lost:
        r45 = r8;
        r5.removedInfo.uid = r2.applicationInfo.uid;
        r5.removedInfo.removedPackage = r2.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:621:0x0e18, code lost:
        if (r15 == null) goto L_0x0e20;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:622:0x0e1a, code lost:
        r5.removedInfo.installerPackageName = r15.installerPackageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:623:0x0e20, code lost:
        r5.removedInfo.isUpdate = true;
        r5.removedInfo.installReasons = r52.removedInfo.installReasons;
        r18 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:624:0x0e30, code lost:
        r45 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:625:0x0e33, code lost:
        r31 = r6;
        r45 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:626:0x0e37, code lost:
        if (r18 != false) goto L_0x0e7d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:627:0x0e39, code lost:
        r5 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r50);
        r5.removedPackage = r2.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:628:0x0e42, code lost:
        if (r15 == null) goto L_0x0e48;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:629:0x0e44, code lost:
        r5.installerPackageName = r15.installerPackageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:630:0x0e48, code lost:
        r5.isUpdate = false;
        r5.dataRemoved = true;
        r8 = r50.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:631:0x0e50, code lost:
        monitor-enter(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:632:0x0e51, code lost:
        if (r15 == null) goto L_0x0e5d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:633:0x0e53, code lost:
        r43 = r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:635:?, code lost:
        r5.origUsers = r15.queryInstalledUsers(r12, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:636:0x0e5d, code lost:
        r43 = r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:637:0x0e5f, code lost:
        monitor-exit(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:639:0x0e64, code lost:
        if (r52.removedInfo.removedChildPackages != null) goto L_0x0e6f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:640:0x0e66, code lost:
        r52.removedInfo.removedChildPackages = new android.util.ArrayMap<>();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:641:0x0e6f, code lost:
        r52.removedInfo.removedChildPackages.put(r2.packageName, r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:646:0x0e7d, code lost:
        r43 = r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:647:0x0e7f, code lost:
        r10 = r10 + 1;
        r5 = r5;
        r6 = r31;
        r9 = r43;
        r8 = r45;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:648:0x0e8d, code lost:
        r22 = r5;
        r45 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:649:0x0e94, code lost:
        r22 = r5;
        r45 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:650:0x0e9a, code lost:
        r2 = isSystemApp(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:651:0x0e9e, code lost:
        if (r2 == false) goto L_0x0ea7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:653:0x0ea4, code lost:
        if (isSystemAppGrantByMdmAndNonPreload(r14) == false) goto L_0x0ea7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:654:0x0ea6, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:655:0x0ea7, code lost:
        android.util.Flog.i(207, "update pkg: " + r11 + ", old pkg is system: " + r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:656:0x0ec6, code lost:
        if (r2 == false) goto L_0x0f53;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:657:0x0ec8, code lost:
        r5 = isPrivilegedApp(r7);
        r6 = isOemApp(r7);
        r8 = isVendorApp(r7);
        r9 = isProductApp(r7);
        r10 = isOdmApp(r7);
        r18 = r4 | 131072;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:658:0x0ee2, code lost:
        if (r5 == false) goto L_0x0ee7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:659:0x0ee4, code lost:
        r19 = 262144;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:660:0x0ee7, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:661:0x0ee9, code lost:
        r18 = r18 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:662:0x0eeb, code lost:
        if (r6 == false) goto L_0x0ef0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:663:0x0eed, code lost:
        r19 = 524288;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:664:0x0ef0, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:665:0x0ef2, code lost:
        r18 = r18 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:666:0x0ef4, code lost:
        if (r8 == false) goto L_0x0ef9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:667:0x0ef6, code lost:
        r19 = 1048576;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:668:0x0ef9, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:669:0x0efb, code lost:
        r18 = r18 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:670:0x0efd, code lost:
        if (r9 == false) goto L_0x0f02;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:671:0x0eff, code lost:
        r19 = 2097152;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:672:0x0f02, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:673:0x0f04, code lost:
        r18 = r18 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:674:0x0f06, code lost:
        if (r10 == false) goto L_0x0f0b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:675:0x0f08, code lost:
        r19 = 8388608;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:676:0x0f0b, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:677:0x0f0d, code lost:
        r18 = r18 | r19;
        r19 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:679:?, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.resolvePersistentFlagForPackage(r7.applicationInfo.flags, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:680:0x0f1e, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0f42;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:681:0x0f20, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "replaceSystemPackageLI: new=" + r14 + ", old=" + r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:683:0x0f44, code lost:
        r52.setReturnCode(1);
        r14.setApplicationInfoFlags(128, 128);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:684:0x0f4f, code lost:
        r2 = r27;
        r4 = r18;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:685:0x0f53, code lost:
        r19 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:688:0x0f5a, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0f7b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:689:0x0f5c, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "replaceNonSystemPackageLI: new=" + r14 + ", old=" + r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:690:0x0f7b, code lost:
        r2 = r7.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:691:0x0f82, code lost:
        if (r14.mExtras == null) goto L_0x0f8a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:692:0x0f84, code lost:
        r9 = ((com.android.server.pm.PackageSetting) r14.mExtras).lastUpdateTime;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:693:0x0f8a, code lost:
        r34 = true;
        r4 = r41;
        r2 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:694:0x0f90, code lost:
        r39 = r19;
        r26 = r22;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:695:0x0f96, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:696:0x0f97, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:697:0x0fa6, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:698:0x0fa7, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:699:0x0fb6, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:700:0x0fb7, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:704:0x0feb, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-8, "Package " + r9 + " tried to change user " + r7.mSharedUserId);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:705:0x0fec, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:706:0x0fed, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:707:0x0ff6, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:708:0x0ff7, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:710:0x1015, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-115, "New package is incompatible");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:711:0x1016, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:712:0x1017, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:713:0x1023, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:714:0x1024, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:715:0x1032, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:716:0x1033, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:717:0x1043, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:718:0x1044, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:719:0x1055, code lost:
        monitor-exit(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:720:0x1056, code lost:
        throw r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:721:0x1057, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:722:0x1058, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:723:0x1065, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:724:0x1066, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:725:0x1068, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:726:0x1069, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:727:0x1078, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:728:0x1079, code lost:
        r33 = true;
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:729:0x108c, code lost:
        r33 = true;
        r39 = false;
        r16 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:731:?, code lost:
        r8 = r14.packageName;
        android.util.Flog.i(207, "installNewPackageLI: " + r14);
        r10 = r50.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:732:0x10bc, code lost:
        monitor-enter(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:734:?, code lost:
        r12 = r50.mSettings.getRenamedPackageLPr(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:735:0x10c3, code lost:
        if (r12 != null) goto L_0x1163;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:738:0x10cb, code lost:
        if (r50.mPackages.containsKey(r8) != false) goto L_0x112f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:739:0x10cd, code lost:
        monitor-exit(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:740:0x10ce, code lost:
        r45 = null;
        r26 = null;
        r42 = null;
        r34 = false;
        r37 = null;
        r40 = r28;
        r36 = r12;
        r4 = r4;
        r2 = r27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:746:?, code lost:
        r33 = new com.android.server.pm.PackageManagerService.PrepareResult(r51.installReason, r40, r15, r51.user, r34, r4, r2, r37, r14, r34, r39, r36, r32, r45, r42, r26, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:747:0x1113, code lost:
        if (0 == 0) goto L_0x1118;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:748:0x1115, code lost:
        r32.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:749:0x1118, code lost:
        return r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:750:0x1119, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:751:0x111a, code lost:
        r2 = r0;
        r33 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:752:0x111f, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:753:0x1120, code lost:
        r2 = r0;
        r33 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:757:0x1155, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-1, "Attempt to re-install " + r8 + " without first uninstalling.");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:758:0x1156, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:759:0x1157, code lost:
        r11 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:761:0x118c, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-1, "Attempt to re-install " + r8 + " without first uninstalling package running as " + r12);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:762:0x118d, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:763:0x118e, code lost:
        r11 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:764:0x119b, code lost:
        monitor-exit(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:766:?, code lost:
        throw r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:767:0x119d, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:768:0x119e, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:769:0x11a2, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:770:0x11a3, code lost:
        r11 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:771:0x11a5, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:772:0x11a6, code lost:
        r2 = r0;
        r33 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:773:0x11b3, code lost:
        if (r33 != false) goto L_0x11b5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:774:0x11b5, code lost:
        r32.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:775:0x11b8, code lost:
        throw r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:776:0x11b9, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:778:0x11e1, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure((int) android.hardware.biometrics.fingerprint.V2_1.RequestStatus.SYS_ETIMEDOUT, "Failed to set up verity: " + r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:780:0x11ec, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-4, "Failed rename");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:781:0x11ed, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:782:0x11ee, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:783:0x11fb, code lost:
        android.util.Slog.e(com.android.server.pm.PackageManagerService.TAG, "Error deriving application ABI", r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:784:0x120b, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure((int) android.hardware.biometrics.fingerprint.V2_1.RequestStatus.SYS_ETIMEDOUT, "Error deriving application ABI");
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:188:0x03ab A[Catch:{ all -> 0x04de }] */
    /* JADX WARNING: Removed duplicated region for block: B:224:0x0499 A[Catch:{ all -> 0x0400, all -> 0x04cb }] */
    /* JADX WARNING: Removed duplicated region for block: B:256:0x058a A[SYNTHETIC, Splitter:B:256:0x058a] */
    /* JADX WARNING: Removed duplicated region for block: B:274:0x05f5  */
    /* JADX WARNING: Removed duplicated region for block: B:307:0x0681 A[Catch:{ all -> 0x06be }] */
    /* JADX WARNING: Removed duplicated region for block: B:317:0x06a8 A[Catch:{ all -> 0x06be }] */
    /* JADX WARNING: Removed duplicated region for block: B:774:0x11b5  */
    @GuardedBy({"mInstallLock"})
    private PrepareResult preparePackageLI(InstallArgs args, PackageInstalledInfo res) throws PrepareFailure {
        Throwable th;
        Exception exc;
        String volumeUuid;
        int parseFlags;
        File tmpPackageFile;
        String installerPackageName;
        Exception exc2;
        PackageParser.Package pkg;
        PackageManagerException e;
        Throwable th2;
        boolean systemApp;
        String pkgName;
        boolean replace;
        boolean onExternal;
        boolean replace2;
        int installFlags;
        int N;
        String installerPackageName2;
        PackageSetting ps;
        boolean sigsOk;
        PackageSetting signatureCheckPs;
        KeySetManagerService ksms;
        PackageManagerException e2;
        PackageSetting signatureCheckPs2;
        boolean replace3;
        String pkgName2;
        Throwable th3;
        String volumeUuid2;
        int installFlags2 = args.installFlags;
        String installerPackageName3 = args.installerPackageName;
        String volumeUuid3 = args.volumeUuid;
        File tmpPackageFile2 = new File(args.getCodePath());
        boolean onExternal2 = args.volumeUuid != null;
        boolean instantApp = (installFlags2 & 2048) != 0;
        boolean fullApp = (installFlags2 & 16384) != 0;
        boolean virtualPreload = (65536 & installFlags2) != 0;
        int scanFlags = 6;
        if (args.move != null) {
            scanFlags = 6 | 512;
        }
        if ((installFlags2 & 4096) != 0) {
            scanFlags |= 2048;
        }
        if (instantApp) {
            scanFlags |= 16384;
        }
        if (fullApp) {
            scanFlags |= 32768;
        }
        if (virtualPreload) {
            scanFlags |= 65536;
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile2);
        }
        if (!instantApp || !onExternal2) {
            int parseFlags2 = (onExternal2 ? 8 : 0) | this.mDefParseFlags | Integer.MIN_VALUE | 64;
            PackageParser pp = new PackageParser();
            pp.setSeparateProcesses(this.mSeparateProcesses);
            pp.setDisplayMetrics(this.mMetrics);
            pp.setCallback(this.mPackageParserCallback);
            Trace.traceBegin(262144, "parsePackage");
            try {
                PackageParser.Package pkg2 = pp.parsePackage(tmpPackageFile2, parseFlags2);
                DexMetadataHelper.validatePackageDexMetadata(pkg2);
                if (pkg2 != null) {
                    try {
                        if (mHwPMSEx.isInMultiWinWhiteList(pkg2.packageName)) {
                            pkg2.forceResizeableAllActivity();
                        }
                    } catch (PackageParser.PackageParserException e3) {
                        exc = e3;
                        try {
                            throw new PrepareFailure("Failed parse during installPackageLI", exc);
                        } catch (Throwable th4) {
                            th = th4;
                            Trace.traceEnd(262144);
                            throw th;
                        }
                    } catch (Throwable th5) {
                        th = th5;
                        Trace.traceEnd(262144);
                        throw th;
                    }
                }
                Trace.traceEnd(262144);
                if (instantApp) {
                    if (pkg2.applicationInfo.targetSdkVersion < 26) {
                        Slog.w(TAG, "Instant app package " + pkg2.packageName + " does not target at least O");
                        throw new PrepareFailure(-116, "Instant app package must target at least O");
                    } else if (pkg2.mSharedUserId != null) {
                        Slog.w(TAG, "Instant app package " + pkg2.packageName + " may not declare sharedUserId.");
                        throw new PrepareFailure(-116, "Instant app package may not declare a sharedUserId");
                    }
                }
                if (pkg2.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(pkg2);
                    if (onExternal2) {
                        Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
                        throw new PrepareFailure(-19, "Packages declaring static-shared libs cannot be updated");
                    }
                }
                ArrayList<String> arrayList = this.mDelPackageList;
                if (arrayList == null || !arrayList.contains(pkg2.packageName)) {
                    if (pkg2.childPackages != null) {
                        synchronized (this.mPackages) {
                            try {
                                int childCount = pkg2.childPackages.size();
                                int i = 0;
                                while (i < childCount) {
                                    PackageParser.Package childPkg = (PackageParser.Package) pkg2.childPackages.get(i);
                                    PackageInstalledInfo childRes = new PackageInstalledInfo();
                                    try {
                                        childRes.setReturnCode(1);
                                        childRes.pkg = childPkg;
                                        childRes.name = childPkg.packageName;
                                        try {
                                            PackageSetting childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                                            if (childPs != null) {
                                                volumeUuid2 = volumeUuid3;
                                                childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                                            } else {
                                                volumeUuid2 = volumeUuid3;
                                            }
                                            if (this.mPackages.containsKey(childPkg.packageName)) {
                                                childRes.removedInfo = new PackageRemovedInfo(this);
                                                childRes.removedInfo.removedPackage = childPkg.packageName;
                                                childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                                            }
                                            if (res.addedChildPackages == null) {
                                                res.addedChildPackages = new ArrayMap<>();
                                            }
                                            res.addedChildPackages.put(childPkg.packageName, childRes);
                                            i++;
                                            childCount = childCount;
                                            tmpPackageFile2 = tmpPackageFile2;
                                            pp = pp;
                                            parseFlags2 = parseFlags2;
                                            volumeUuid3 = volumeUuid2;
                                        } catch (Throwable th6) {
                                            th3 = th6;
                                            throw th3;
                                        }
                                    } catch (Throwable th7) {
                                        th3 = th7;
                                        throw th3;
                                    }
                                }
                                parseFlags = parseFlags2;
                                tmpPackageFile = tmpPackageFile2;
                                volumeUuid = volumeUuid3;
                            } catch (Throwable th8) {
                                th3 = th8;
                                throw th3;
                            }
                        }
                    } else {
                        parseFlags = parseFlags2;
                        tmpPackageFile = tmpPackageFile2;
                        volumeUuid = volumeUuid3;
                    }
                    if (TextUtils.isEmpty(pkg2.cpuAbiOverride)) {
                        pkg2.cpuAbiOverride = args.abiOverride;
                    }
                    String pkgName3 = pkg2.packageName;
                    res.name = pkgName3;
                    if (!mHwPMSEx.isAppInstallAllowed(pkgName3)) {
                        installerPackageName = installerPackageName3;
                    } else if (args.origin != null && mHwPMSEx.isUnAppInstallAllowed(args.origin.resolvedPath)) {
                        installerPackageName = installerPackageName3;
                    } else if ((pkg2.applicationInfo.flags & 256) == 0 || (installFlags2 & 4) != 0) {
                        try {
                            if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
                                try {
                                    pkg2.setSigningDetails(args.signingDetails);
                                    pkg = pkg2;
                                } catch (PackageParser.PackageParserException e4) {
                                    exc2 = e4;
                                    throw new PrepareFailure("Failed collect during installPackageLI", exc2);
                                }
                            } else {
                                PackageParser.collectCertificates(pkg2, false);
                                pkg = pkg2;
                            }
                            if (instantApp && pkg.mSigningDetails.signatureSchemeVersion < 2) {
                                Slog.w(TAG, "Instant app package " + pkg.packageName + " is not signed with at least APK Signature Scheme v2");
                                throw new PrepareFailure(-116, "Instant app package must be signed with APK Signature Scheme v2 or greater");
                            } else if (mHwPMSEx.isInValidApkPatchPkg(pkg)) {
                                Slog.i(TAG, "this apk is invalid apk patch");
                                throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "PackageName is disallowd to be installed");
                            } else if (!mHwPMSEx.isMDMDisallowedInstallPackage(pkg, res)) {
                                try {
                                    if (mHwPMSEx.checkUninstalledSystemApp(pkg, args, res)) {
                                        try {
                                            Slog.i(TAG, "restore the uninstalled app and upgrad it");
                                            installFlags2 |= 2;
                                        } catch (PackageManagerException e5) {
                                            e = e5;
                                            Slog.w(TAG, "Failed checkUninstalledSystemApp: " + e.getMessage());
                                            throw new PrepareFailure("Failed checkUninstalledSystemApp during installPackageLI", e);
                                        }
                                    }
                                    boolean replace4 = false;
                                    synchronized (this.mPackages) {
                                        if ((installFlags2 & 2) != 0) {
                                            try {
                                                String oldName = this.mSettings.getRenamedPackageLPr(pkgName3);
                                                if (pkg.mOriginalPackages == null) {
                                                    systemApp = false;
                                                } else if (!pkg.mOriginalPackages.contains(oldName)) {
                                                    systemApp = false;
                                                } else if (this.mPackages.containsKey(oldName)) {
                                                    pkg.setPackageName(oldName);
                                                    pkgName3 = pkg.packageName;
                                                    replace4 = true;
                                                    replace4 = true;
                                                    if (DEBUG_INSTALL) {
                                                        StringBuilder sb = new StringBuilder();
                                                        systemApp = false;
                                                        try {
                                                            sb.append("Replacing existing renamed package: oldName=");
                                                            sb.append(oldName);
                                                            sb.append(" pkgName=");
                                                            sb.append(pkgName3);
                                                            Slog.d(TAG, sb.toString());
                                                        } catch (Throwable th9) {
                                                            th2 = th9;
                                                            while (true) {
                                                                try {
                                                                    break;
                                                                } catch (Throwable th10) {
                                                                    th2 = th10;
                                                                }
                                                            }
                                                            throw th2;
                                                        }
                                                    } else {
                                                        systemApp = false;
                                                    }
                                                    if (pkg.parentPackage != null) {
                                                        if (replace4) {
                                                            PackageParser.Package oldPackage = this.mPackages.get(pkgName3);
                                                            int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                                                            int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                                                            pkgName2 = pkgName3;
                                                            if (oldTargetSdk <= 22) {
                                                                replace3 = replace4;
                                                            } else if (newTargetSdk > 22) {
                                                                replace3 = replace4;
                                                            } else {
                                                                try {
                                                                    StringBuilder sb2 = new StringBuilder();
                                                                    sb2.append("Package ");
                                                                    sb2.append(pkg.packageName);
                                                                    sb2.append(" new target SDK ");
                                                                    sb2.append(newTargetSdk);
                                                                    sb2.append(" doesn't support runtime permissions but the old target SDK ");
                                                                    sb2.append(oldTargetSdk);
                                                                    sb2.append(" does.");
                                                                    throw new PrepareFailure(-26, sb2.toString());
                                                                } catch (Throwable th11) {
                                                                    th2 = th11;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            }
                                                            if ((oldPackage.applicationInfo.flags & 8) != 0 && (2097152 & installFlags2) == 0) {
                                                                if (!mHwPMSEx.isPersistentUpdatable(pkg)) {
                                                                    throw new PrepareFailure(-2, "Package " + oldPackage.packageName + " is a persistent app. Persistent apps are not updateable.");
                                                                }
                                                            }
                                                            if (oldPackage.parentPackage == null) {
                                                                String isAppUpdateAllowedMsg = HwPackageManagerServiceUtils.isAppUpdateAllowed(oldPackage, pkg, this);
                                                                if (!TextUtils.isEmpty(isAppUpdateAllowedMsg)) {
                                                                    throw new PrepareFailure(-2, isAppUpdateAllowedMsg);
                                                                }
                                                            } else {
                                                                throw new PrepareFailure(-106, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                            }
                                                        } else {
                                                            pkgName2 = pkgName3;
                                                            replace3 = replace4;
                                                        }
                                                        pkgName = pkgName2;
                                                        replace = replace3;
                                                    } else {
                                                        throw new PrepareFailure(-106, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                    }
                                                } else {
                                                    systemApp = false;
                                                }
                                                if (this.mPackages.containsKey(pkgName3)) {
                                                    replace4 = true;
                                                    replace4 = true;
                                                    if (DEBUG_INSTALL) {
                                                        Slog.d(TAG, "Replace existing pacakge: " + pkgName3);
                                                    }
                                                }
                                            } catch (Throwable th12) {
                                                th2 = th12;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                            try {
                                                if (pkg.parentPackage != null) {
                                                }
                                            } catch (Throwable th13) {
                                                th2 = th13;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                        } else {
                                            systemApp = false;
                                            pkgName = pkgName3;
                                            replace = false;
                                        }
                                        try {
                                            PackageSetting ps2 = this.mSettings.mPackages.get(pkgName);
                                            mHwPMSEx.checkHwCertification(pkg, true);
                                            mHwPMSEx.replaceSignatureIfNeeded(ps2, pkg, false, true);
                                            if (ps2 != null) {
                                                try {
                                                    if (DEBUG_INSTALL) {
                                                        try {
                                                            Slog.d(TAG, "Existing package: " + ps2);
                                                        } catch (Throwable th14) {
                                                            th2 = th14;
                                                        }
                                                    }
                                                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                                        SharedLibraryInfo libraryInfo = getLatestSharedLibraVersionLPr(pkg);
                                                        if (libraryInfo != null) {
                                                            signatureCheckPs = this.mSettings.getPackageLPr(libraryInfo.getPackageName());
                                                            ksms = this.mSettings.mKeySetManagerService;
                                                            if (!ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                                                                try {
                                                                    if (ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                                                                        installFlags = installFlags2;
                                                                        replace2 = replace;
                                                                        onExternal = onExternal2;
                                                                    } else {
                                                                        try {
                                                                            StringBuilder sb3 = new StringBuilder();
                                                                            try {
                                                                                sb3.append("Package ");
                                                                                sb3.append(pkg.packageName);
                                                                                sb3.append(" upgrade keys do not match the previously installed version");
                                                                                throw new PrepareFailure(-7, sb3.toString());
                                                                            } catch (Throwable th15) {
                                                                                th2 = th15;
                                                                                while (true) {
                                                                                    break;
                                                                                }
                                                                                throw th2;
                                                                            }
                                                                        } catch (Throwable th16) {
                                                                            th2 = th16;
                                                                            while (true) {
                                                                                break;
                                                                            }
                                                                            throw th2;
                                                                        }
                                                                    }
                                                                } catch (Throwable th17) {
                                                                    th2 = th17;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            } else {
                                                                installFlags = installFlags2;
                                                                replace2 = replace;
                                                                try {
                                                                    onExternal = onExternal2;
                                                                    try {
                                                                        if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, null, pkg.mSigningDetails, isCompatSignatureUpdateNeeded(pkg), isRecoverSignatureUpdateNeeded(pkg))) {
                                                                            synchronized (this.mPackages) {
                                                                                ksms.removeAppKeySetDataLPw(pkg.packageName);
                                                                            }
                                                                        }
                                                                    } catch (PackageManagerException e6) {
                                                                        e2 = e6;
                                                                        try {
                                                                            if (ps2.sharedUser == null) {
                                                                            }
                                                                            throw new PrepareFailure(e2.error, e2.getMessage());
                                                                        } catch (Throwable th18) {
                                                                            th2 = th18;
                                                                            while (true) {
                                                                                break;
                                                                            }
                                                                            throw th2;
                                                                        }
                                                                    }
                                                                } catch (PackageManagerException e7) {
                                                                    onExternal = onExternal2;
                                                                    e2 = e7;
                                                                    if (ps2.sharedUser == null || !mHwPMSEx.isSystemSignatureUpdated(signatureCheckPs.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures)) {
                                                                        throw new PrepareFailure(e2.error, e2.getMessage());
                                                                    }
                                                                    Slog.i(TAG, "CertCompat: " + pkg.packageName + " system signature updated. Update signatures.");
                                                                    ps2.signatures.mSigningDetails = pkg.mSigningDetails;
                                                                    if (HwPackageManagerServiceUtils.verifyValidVerifierInstall(installerPackageName3, pkgName, args.user.getIdentifier(), Binder.getCallingUid(), this)) {
                                                                    }
                                                                } catch (Throwable th19) {
                                                                    th2 = th19;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            }
                                                            if (HwPackageManagerServiceUtils.verifyValidVerifierInstall(installerPackageName3, pkgName, args.user.getIdentifier(), Binder.getCallingUid(), this)) {
                                                                if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null)) {
                                                                    systemApp = (ps2.pkg.applicationInfo.flags & 1) != 0;
                                                                }
                                                                res.origUsers = ps2.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                            } else {
                                                                throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "Invalid installer for verifyValidVerifierInstall failed!");
                                                            }
                                                        } else {
                                                            signatureCheckPs2 = ps2;
                                                        }
                                                    } else {
                                                        signatureCheckPs2 = ps2;
                                                    }
                                                    signatureCheckPs = signatureCheckPs2;
                                                    ksms = this.mSettings.mKeySetManagerService;
                                                    if (!ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                                                    }
                                                    if (HwPackageManagerServiceUtils.verifyValidVerifierInstall(installerPackageName3, pkgName, args.user.getIdentifier(), Binder.getCallingUid(), this)) {
                                                    }
                                                } catch (Throwable th20) {
                                                    th2 = th20;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw th2;
                                                }
                                            } else {
                                                installFlags = installFlags2;
                                                replace2 = replace;
                                                onExternal = onExternal2;
                                            }
                                            try {
                                                int N2 = pkg.permissions.size();
                                                int i2 = N2 - 1;
                                                while (i2 >= 0) {
                                                    try {
                                                        PackageParser.Permission perm = (PackageParser.Permission) pkg.permissions.get(i2);
                                                        BasePermission bp = this.mPermissionManager.getPermissionTEMP(perm.info.name);
                                                        if ((perm.info.protectionLevel & 4096) == 0 || systemApp) {
                                                            N = N2;
                                                        } else {
                                                            StringBuilder sb4 = new StringBuilder();
                                                            N = N2;
                                                            sb4.append("Non-System package ");
                                                            sb4.append(pkg.packageName);
                                                            sb4.append(" attempting to delcare ephemeral permission ");
                                                            sb4.append(perm.info.name);
                                                            sb4.append("; Removing ephemeral.");
                                                            Slog.w(TAG, sb4.toString());
                                                            perm.info.protectionLevel &= -4097;
                                                        }
                                                        if (bp != null) {
                                                            String sourcePackageName = bp.getSourcePackageName();
                                                            PackageSettingBase sourcePackageSetting = bp.getSourcePackageSetting();
                                                            KeySetManagerService ksms2 = this.mSettings.mKeySetManagerService;
                                                            ps = ps2;
                                                            if (!sourcePackageName.equals(pkg.packageName) || !ksms2.shouldCheckUpgradeKeySetLocked(sourcePackageSetting, scanFlags)) {
                                                                installerPackageName2 = installerPackageName3;
                                                                try {
                                                                    if (sourcePackageSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                                                                        sigsOk = true;
                                                                    } else if (pkg.mSigningDetails.checkCapability(sourcePackageSetting.signatures.mSigningDetails, 4)) {
                                                                        sourcePackageSetting.signatures.mSigningDetails = pkg.mSigningDetails;
                                                                        sigsOk = true;
                                                                    } else {
                                                                        sigsOk = false;
                                                                    }
                                                                } catch (Throwable th21) {
                                                                    th2 = th21;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            } else {
                                                                sigsOk = ksms2.checkUpgradeKeySetLocked(sourcePackageSetting, pkg);
                                                                installerPackageName2 = installerPackageName3;
                                                            }
                                                            if (!sigsOk) {
                                                                if (!sourcePackageName.equals(PLATFORM_PACKAGE_NAME)) {
                                                                    PackageSetting basePackageSetting = this.mSettings.mPackages.get(sourcePackageName);
                                                                    if (basePackageSetting != null ? basePackageSetting.isSystem() : false) {
                                                                        if (((bp.getProtectionLevel() | perm.info.protectionLevel) & 15) != 2) {
                                                                            Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName + "; ignoring new declaration");
                                                                            pkg.permissions.remove(i2);
                                                                        }
                                                                    }
                                                                    throw new PrepareFailure(-112, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName).conflictsWithExistingPermission(perm.info.name, sourcePackageName);
                                                                }
                                                                Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                                                                pkg.permissions.remove(i2);
                                                            } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName) && (perm.info.protectionLevel & 15) == 1 && !bp.isRuntime()) {
                                                                Slog.w(TAG, "Package " + pkg.packageName + " trying to change a non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                                                                perm.info.protectionLevel = bp.getProtectionLevel();
                                                            }
                                                        } else {
                                                            ps = ps2;
                                                            installerPackageName2 = installerPackageName3;
                                                        }
                                                        i2--;
                                                        N2 = N;
                                                        ps2 = ps;
                                                        installerPackageName3 = installerPackageName2;
                                                    } catch (Throwable th22) {
                                                        th2 = th22;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw th2;
                                                    }
                                                }
                                                try {
                                                } catch (Throwable th23) {
                                                    th2 = th23;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw th2;
                                                }
                                            } catch (Throwable th24) {
                                                th2 = th24;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                        } catch (Throwable th25) {
                                            th2 = th25;
                                            while (true) {
                                                break;
                                            }
                                            throw th2;
                                        }
                                    }
                                } catch (PackageManagerException e8) {
                                    e = e8;
                                    Slog.w(TAG, "Failed checkUninstalledSystemApp: " + e.getMessage());
                                    throw new PrepareFailure("Failed checkUninstalledSystemApp during installPackageLI", e);
                                }
                            } else {
                                throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "app disallow install by mdm control");
                            }
                        } catch (PackageParser.PackageParserException e9) {
                            exc2 = e9;
                            throw new PrepareFailure("Failed collect during installPackageLI", exc2);
                        }
                    } else {
                        throw new PrepareFailure(-15, "installPackageLI");
                    }
                    Slog.i(TAG, installerPackageName + " is disallowed to install new app " + pkgName3);
                    throw new PrepareFailure(-111, "Disallow install new apps");
                }
                throw new PrepareFailure(-111, "Package: " + pkg2.packageName + "in the delete_system_app file, no need to install");
            } catch (PackageParser.PackageParserException e10) {
                exc = e10;
                throw new PrepareFailure("Failed parse during installPackageLI", exc);
            } catch (Throwable th26) {
                th = th26;
                Trace.traceEnd(262144);
                throw th;
            }
        } else {
            Slog.i(TAG, "Incompatible ephemeral install; external=" + onExternal2);
            throw new PrepareFailure(-116);
        }
    }

    private void setUpFsVerityIfPossible(PackageParser.Package pkg) throws Installer.InstallerException, PrepareFailure, IOException, DigestException, NoSuchAlgorithmException {
        boolean standardMode = PackageManagerServiceUtils.isApkVerityEnabled();
        boolean legacyMode = PackageManagerServiceUtils.isLegacyApkVerityEnabled();
        if (standardMode || legacyMode) {
            ArrayMap<String, String> fsverityCandidates = new ArrayMap<>();
            int i = 0;
            if (legacyMode) {
                synchronized (this.mPackages) {
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null && ps.isPrivileged()) {
                        fsverityCandidates.put(pkg.baseCodePath, null);
                        if (pkg.splitCodePaths != null) {
                            String[] strArr = pkg.splitCodePaths;
                            int length = strArr.length;
                            while (i < length) {
                                fsverityCandidates.put(strArr[i], null);
                                i++;
                            }
                        }
                    }
                }
            } else {
                fsverityCandidates.put(pkg.baseCodePath, VerityUtils.getFsveritySignatureFilePath(pkg.baseCodePath));
                String dmPath = DexMetadataHelper.buildDexMetadataPathForApk(pkg.baseCodePath);
                if (new File(dmPath).exists()) {
                    fsverityCandidates.put(dmPath, VerityUtils.getFsveritySignatureFilePath(dmPath));
                }
                if (pkg.splitCodePaths != null) {
                    String[] strArr2 = pkg.splitCodePaths;
                    int length2 = strArr2.length;
                    while (i < length2) {
                        String path = strArr2[i];
                        fsverityCandidates.put(path, VerityUtils.getFsveritySignatureFilePath(path));
                        String splitDmPath = DexMetadataHelper.buildDexMetadataPathForApk(path);
                        if (new File(splitDmPath).exists()) {
                            fsverityCandidates.put(splitDmPath, VerityUtils.getFsveritySignatureFilePath(splitDmPath));
                        }
                        i++;
                    }
                }
            }
            for (Map.Entry<String, String> entry : fsverityCandidates.entrySet()) {
                String filePath = entry.getKey();
                String signaturePath = entry.getValue();
                if (legacyMode) {
                    VerityUtils.SetupResult result = VerityUtils.generateApkVeritySetupData(filePath);
                    if (result.isOk()) {
                        if (Build.IS_DEBUGGABLE) {
                            Slog.i(TAG, "Enabling verity to " + filePath);
                        }
                        FileDescriptor fd = result.getUnownedFileDescriptor();
                        try {
                            byte[] rootHash = VerityUtils.generateApkVerityRootHash(filePath);
                            try {
                                this.mInstaller.assertFsverityRootHashMatches(filePath, rootHash);
                            } catch (Installer.InstallerException e) {
                                this.mInstaller.installApkVerity(filePath, fd, result.getContentSize());
                                this.mInstaller.assertFsverityRootHashMatches(filePath, rootHash);
                            }
                        } finally {
                            IoUtils.closeQuietly(fd);
                        }
                    } else if (result.isFailed()) {
                        throw new PrepareFailure(-118, "Failed to generate verity");
                    }
                } else if (new File(signaturePath).exists() && !VerityUtils.hasFsverity(filePath)) {
                    try {
                        VerityUtils.setUpFsverity(filePath, signaturePath);
                    } catch (IOException | SecurityException | DigestException | NoSuchAlgorithmException e2) {
                        throw new PrepareFailure(-118, "Failed to enable fs-verity: " + e2);
                    }
                }
            }
        }
    }

    private void startIntentFilterVerifications(int userId, boolean replacing, PackageParser.Package pkg) {
        ComponentName componentName = this.mIntentFilterVerifierComponent;
        if (componentName == null) {
            Slog.w(TAG, "No IntentFilter verification will not be done as there is no IntentFilterVerifier available!");
            return;
        }
        int childCount = 0;
        int verifierUid = getPackageUid(componentName.getPackageName(), 268435456, userId == -1 ? 0 : userId);
        Message msg = this.mHandler.obtainMessage(17);
        msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
        this.mHandler.sendMessage(msg);
        if (pkg.childPackages != null) {
            childCount = pkg.childPackages.size();
        }
        for (int i = 0; i < childCount; i++) {
            Message msg2 = this.mHandler.obtainMessage(17);
            msg2.obj = new IFVerificationParams((PackageParser.Package) pkg.childPackages.get(i), replacing, userId, verifierUid);
            this.mHandler.sendMessage(msg2);
        }
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:118:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0163, code lost:
        if (r2 <= 0) goto L_0x019d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0167, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x0197;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x0169, code lost:
        r0 = new java.lang.StringBuilder();
        r0.append("Starting ");
        r0.append(r2);
        r0.append(" IntentFilter verification");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x017b, code lost:
        if (r2 <= 1) goto L_0x0181;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x017d, code lost:
        r3 = "s";
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x0181, code lost:
        r3 = "";
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0183, code lost:
        r0.append(r3);
        r0.append(" for userId:");
        r0.append(r25);
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, r0.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x0197, code lost:
        r24.mIntentFilterVerifier.startVerifications(r25);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x019d, code lost:
        if (r4 == false) goto L_0x01b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x019f, code lost:
        if (r18 == false) goto L_0x01b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x01a3, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x01ac;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x01a5, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "App changed web filters but no longer verifying - resetting policy");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x01ac, code lost:
        r3 = r24.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x01ae, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:?, code lost:
        clearIntentFilterVerificationsLPw(r12, r25);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01b2, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x01b9, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01bb, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "No web filters or no prior verify policy for " + r12);
     */
    public void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing, PackageParser.Package pkg) {
        PackageParser.Activity a;
        int size = pkg.activities.size();
        if (size == 0) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No activity, so no need to verify any IntentFilter!");
            }
        } else if (hasDomainURLs(pkg)) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "Checking for userId:" + userId + " if any IntentFilter from the " + size + " Activities needs verification ...");
            }
            int count = 0;
            String packageName = pkg.packageName;
            synchronized (this.mPackages) {
                try {
                    IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(packageName);
                    boolean alreadyVerified = ivi != null;
                    if (replacing || !alreadyVerified) {
                        Iterator it = pkg.activities.iterator();
                        boolean handlesWebUris = false;
                        boolean needToVerify = false;
                        while (it.hasNext()) {
                            try {
                                Iterator it2 = ((PackageParser.Activity) it.next()).intents.iterator();
                                while (true) {
                                    if (!it2.hasNext()) {
                                        break;
                                    }
                                    PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it2.next();
                                    if (filter.handlesWebUris(true)) {
                                        handlesWebUris = true;
                                    }
                                    if (filter.needsVerification() && needsNetworkVerificationLPr(filter)) {
                                        if (DEBUG_DOMAIN_VERIFICATION) {
                                            Slog.d(TAG, "Intent filter needs verification, so processing all filters");
                                        }
                                        needToVerify = true;
                                    }
                                }
                            } catch (Throwable th) {
                                ivi = th;
                                throw ivi;
                            }
                        }
                        if (needToVerify) {
                            int verificationId = this.mIntentFilterVerificationToken;
                            this.mIntentFilterVerificationToken = verificationId + 1;
                            Iterator it3 = pkg.activities.iterator();
                            while (it3.hasNext()) {
                                PackageParser.Activity a2 = (PackageParser.Activity) it3.next();
                                Iterator it4 = a2.intents.iterator();
                                int count2 = count;
                                while (it4.hasNext()) {
                                    try {
                                        PackageParser.ActivityIntentInfo filter2 = (PackageParser.ActivityIntentInfo) it4.next();
                                        if (!filter2.handlesWebUris(false) || !needsNetworkVerificationLPr(filter2)) {
                                            a = a2;
                                        } else {
                                            if (DEBUG_DOMAIN_VERIFICATION) {
                                                Slog.d(TAG, "Verification needed for IntentFilter:" + filter2.toString());
                                            }
                                            a = a2;
                                            this.mIntentFilterVerifier.addOneIntentFilterVerification(verifierUid, userId, verificationId, filter2, packageName);
                                            count2++;
                                        }
                                        a2 = a;
                                    } catch (Throwable th2) {
                                        ivi = th2;
                                        throw ivi;
                                    }
                                }
                                count = count2;
                            }
                        }
                    } else {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            Slog.i(TAG, "Package " + packageName + " already verified: status=" + ivi.getStatusString());
                        }
                    }
                } catch (Throwable th3) {
                    ivi = th3;
                    throw ivi;
                }
            }
        } else if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "No domain URLs, so no need to verify any IntentFilter!");
        }
    }

    @GuardedBy({"mPackages"})
    private boolean needsNetworkVerificationLPr(PackageParser.ActivityIntentInfo filter) {
        int status;
        IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(filter.activity.getComponentName().getPackageName());
        if (ivi == null || (status = ivi.getStatus()) == 0 || status == 1 || status == 2) {
            return true;
        }
        return false;
    }

    private static boolean isMultiArch(ApplicationInfo info) {
        return (info.flags & Integer.MIN_VALUE) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isExternal(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 262144) != 0;
    }

    private static boolean isExternal(PackageSetting ps) {
        return (ps.pkgFlags & 262144) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isSystemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 1) != 0;
    }

    private static boolean isPrivilegedApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 8) != 0;
    }

    private static boolean isOemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 131072) != 0;
    }

    private static boolean isVendorApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 262144) != 0;
    }

    private static boolean isProductApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 524288) != 0;
    }

    private static boolean isProductServicesApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 2097152) != 0;
    }

    private static boolean isOdmApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 1073741824) != 0;
    }

    private static boolean hasDomainURLs(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 16) != 0;
    }

    private static boolean isSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 1) != 0;
    }

    private static boolean isUpdatedSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 128) != 0;
    }

    private Settings.VersionInfo getSettingsVersionForPackage(PackageParser.Package pkg) {
        if (!isExternal(pkg)) {
            return this.mSettings.getInternalVersion();
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return this.mSettings.getExternalVersion();
        }
        return this.mSettings.findOrCreateVersion(pkg.volumeUuid);
    }

    private void deleteTempPackageFiles() {
        $$Lambda$PackageManagerService$InxwP9v95IsHM1AIPecZaxo1Q r0 = $$Lambda$PackageManagerService$InxwP9v95IsHM1AIPecZaxo1Q.INSTANCE;
    }

    static /* synthetic */ boolean lambda$deleteTempPackageFiles$16(File dir, String name) {
        return name.startsWith("vmdl") && name.endsWith(".tmp");
    }

    public void deletePackageAsUser(String packageName, int versionCode, IPackageDeleteObserver observer, int userId, int flags) {
        deletePackageVersioned(new VersionedPackage(packageName, versionCode), new PackageManager.LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:48:0x0130, code lost:
        r0 = th;
     */
    public void deletePackageVersioned(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        String internalPackageName;
        int callingUid = Binder.getCallingUid();
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        boolean canViewInstantApps = canViewInstantApps(callingUid, userId);
        Preconditions.checkNotNull(versionedPackage);
        Preconditions.checkNotNull(observer);
        Preconditions.checkArgumentInRange(versionedPackage.getLongVersionCode(), -1, (long) JobStatus.NO_LATEST_RUNTIME, "versionCode must be >= -1");
        String packageName = versionedPackage.getPackageName();
        long versionCode = versionedPackage.getLongVersionCode();
        synchronized (this.mPackages) {
            internalPackageName = resolveInternalPackageNameLPr(packageName, versionCode);
        }
        int uid = Binder.getCallingUid();
        if (isOrphaned(internalPackageName) || isCallerAllowedToSilentlyUninstall(uid, internalPackageName)) {
            boolean deleteAllUsers = (deleteFlags & 2) != 0;
            int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]{userId};
            if (UserHandle.getUserId(uid) != userId || (deleteAllUsers && users.length > 1)) {
                Context context = this.mContext;
                context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "deletePackage for user " + userId);
            }
            if (isUserRestricted(userId, "no_uninstall_apps")) {
                this.mHandler.post(new Runnable(observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$CS3aJUelGPn4PWtkx1QPsjrbNtc */
                    private final /* synthetic */ IPackageDeleteObserver2 f$0;
                    private final /* synthetic */ String f$1;

                    {
                        this.f$0 = r1;
                        this.f$1 = r2;
                    }

                    public final void run() {
                        PackageManagerService.lambda$deletePackageVersioned$18(this.f$0, this.f$1);
                    }
                });
                return;
            } else if (deleteAllUsers || !getBlockUninstallForUser(internalPackageName, userId)) {
                if (DEBUG_REMOVE) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("deletePackageAsUser: pkg=");
                    sb.append(internalPackageName);
                    sb.append(" user=");
                    sb.append(userId);
                    sb.append(" deleteAllUsers: ");
                    sb.append(deleteAllUsers);
                    sb.append(" version=");
                    sb.append(versionCode == -1 ? "VERSION_CODE_HIGHEST" : Long.valueOf(versionCode));
                    Slog.d(TAG, sb.toString());
                }
                this.mHandler.post(new Runnable(internalPackageName, callingUid, canViewInstantApps, deleteAllUsers, versionCode, userId, deleteFlags, users, observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$_6B9au9z1U04Ew3TKUI7EAfYytI */
                    private final /* synthetic */ String f$1;
                    private final /* synthetic */ String f$10;
                    private final /* synthetic */ int f$2;
                    private final /* synthetic */ boolean f$3;
                    private final /* synthetic */ boolean f$4;
                    private final /* synthetic */ long f$5;
                    private final /* synthetic */ int f$6;
                    private final /* synthetic */ int f$7;
                    private final /* synthetic */ int[] f$8;
                    private final /* synthetic */ IPackageDeleteObserver2 f$9;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                        this.f$4 = r5;
                        this.f$5 = r6;
                        this.f$6 = r8;
                        this.f$7 = r9;
                        this.f$8 = r10;
                        this.f$9 = r11;
                        this.f$10 = r12;
                    }

                    public final void run() {
                        PackageManagerService.this.lambda$deletePackageVersioned$20$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6, this.f$7, this.f$8, this.f$9, this.f$10);
                    }
                });
                return;
            } else {
                this.mHandler.post(new Runnable(observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$A9GGP3Sl3gE_C_zP7bNUbtlbRjI */
                    private final /* synthetic */ IPackageDeleteObserver2 f$0;
                    private final /* synthetic */ String f$1;

                    {
                        this.f$0 = r1;
                        this.f$1 = r2;
                    }

                    public final void run() {
                        PackageManagerService.lambda$deletePackageVersioned$19(this.f$0, this.f$1);
                    }
                });
                return;
            }
        } else {
            this.mHandler.post(new Runnable(packageName, observer) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$fswFUK6dCGUD9_CR_zyaZxmYAp0 */
                private final /* synthetic */ String f$0;
                private final /* synthetic */ IPackageDeleteObserver2 f$1;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                }

                public final void run() {
                    PackageManagerService.lambda$deletePackageVersioned$17(this.f$0, this.f$1);
                }
            });
            return;
        }
        while (true) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$17(String packageName, IPackageDeleteObserver2 observer) {
        try {
            Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
            intent.setData(Uri.fromParts("package", packageName, null));
            intent.putExtra("android.content.pm.extra.CALLBACK", observer.asBinder());
            observer.onUserActionRequired(intent);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$18(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -3, (String) null);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$19(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -4, (String) null);
        } catch (RemoteException e) {
        }
    }

    public /* synthetic */ void lambda$deletePackageVersioned$20$PackageManagerService(String internalPackageName, int callingUid, boolean canViewInstantApps, boolean deleteAllUsers, long versionCode, int userId, int deleteFlags, int[] users, IPackageDeleteObserver2 observer, String packageName) {
        boolean doDeletePackage;
        int returnCode;
        int returnCode2;
        int i;
        PackageSetting ps = this.mSettings.mPackages.get(internalPackageName);
        if (ps != null) {
            doDeletePackage = !ps.getInstantApp(UserHandle.getUserId(callingUid)) || canViewInstantApps;
        } else {
            doDeletePackage = true;
        }
        if (!doDeletePackage) {
            returnCode = -1;
        } else if (!deleteAllUsers) {
            returnCode = deletePackageX(internalPackageName, versionCode, userId, deleteFlags);
        } else {
            int[] blockUninstallUserIds = getBlockUninstallForUsers(internalPackageName, users);
            if (ArrayUtils.isEmpty(blockUninstallUserIds)) {
                returnCode2 = deletePackageX(internalPackageName, versionCode, userId, deleteFlags);
            } else {
                int userFlags = deleteFlags & -3;
                int length = users.length;
                int i2 = 0;
                while (i2 < length) {
                    int userId1 = users[i2];
                    if (!ArrayUtils.contains(blockUninstallUserIds, userId1)) {
                        i = i2;
                        int returnCode3 = deletePackageX(internalPackageName, versionCode, userId1, userFlags);
                        if (returnCode3 != 1) {
                            Slog.w(TAG, "Package delete failed for user " + userId1 + ", returnCode " + returnCode3);
                        }
                    } else {
                        i = i2;
                    }
                    i2 = i + 1;
                }
                returnCode2 = -4;
            }
            returnCode = returnCode2;
        }
        if (returnCode == 1) {
            reportDeleteEvent(callingUid);
        }
        try {
            observer.onPackageDeleted(packageName, returnCode, (String) null);
        } catch (RemoteException e) {
            Log.i(TAG, "Observer no longer exists.");
        }
    }

    private void reportDeleteEvent(final int callingUid) {
        Set<Long> deleteTimeSet;
        synchronized (this.mDeletePackageCallMap) {
            if (this.mDeletePackageCallMap.containsKey(Integer.valueOf(callingUid))) {
                deleteTimeSet = this.mDeletePackageCallMap.get(Integer.valueOf(callingUid));
            } else {
                deleteTimeSet = new HashSet<>();
            }
            deleteTimeSet.add(Long.valueOf(SystemClock.elapsedRealtime()));
            this.mDeletePackageCallMap.put(Integer.valueOf(callingUid), deleteTimeSet);
            if (!this.mDeleteCheckingSet.contains(Integer.valueOf(callingUid))) {
                this.mDeleteCheckingSet.add(Integer.valueOf(callingUid));
                new Handler().postDelayed(new Runnable() {
                    /* class com.android.server.pm.PackageManagerService.AnonymousClass4 */

                    public void run() {
                        synchronized (PackageManagerService.this.mDeletePackageCallMap) {
                            int deleteCount = ((Set) PackageManagerService.this.mDeletePackageCallMap.get(Integer.valueOf(callingUid))).size();
                            if (deleteCount >= 5) {
                                long elapsedRealtime = SystemClock.elapsedRealtime();
                                String callingName = PackageManagerService.this.getNameForUid(callingUid);
                                Slog.i(PackageManagerService.TAG, "Delete package occur frequently, delete " + deleteCount + " package, callingUid:" + callingUid + ", callingName:" + callingName + ", elapsedRealtime:" + elapsedRealtime);
                                HwPackageManagerServiceUtils.reportPmsDeleteDataApp(callingUid, callingName, deleteCount, elapsedRealtime);
                            }
                            PackageManagerService.this.mDeletePackageCallMap.remove(Integer.valueOf(callingUid));
                            PackageManagerService.this.mDeleteCheckingSet.remove(Integer.valueOf(callingUid));
                        }
                    }
                }, 60000);
            }
        }
    }

    private String resolveExternalPackageNameLPr(PackageParser.Package pkg) {
        if (pkg.staticSharedLibName != null) {
            return pkg.manifestPackageName;
        }
        return pkg.packageName;
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public String resolveInternalPackageNameLPr(String packageName, long versionCode) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        String packageName2 = normalizedPackageName != null ? normalizedPackageName : packageName;
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mStaticLibsByDeclaringPackage.get(packageName2);
        if (versionedLib == null || versionedLib.size() <= 0) {
            return packageName2;
        }
        LongSparseLongArray versionsCallerCanSee = null;
        int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
        if (!(callingAppId == 1000 || callingAppId == 2000 || callingAppId == 0)) {
            versionsCallerCanSee = new LongSparseLongArray();
            String libName = versionedLib.valueAt(0).getName();
            String[] uidPackages = getPackagesForUid(Binder.getCallingUid());
            if (uidPackages != null) {
                for (String uidPackage : uidPackages) {
                    PackageSetting ps = this.mSettings.getPackageLPr(uidPackage);
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0) {
                        long libVersion = ps.usesStaticLibrariesVersions[libIdx];
                        versionsCallerCanSee.append(libVersion, libVersion);
                    }
                }
            }
        }
        if (versionsCallerCanSee != null && versionsCallerCanSee.size() <= 0) {
            return packageName2;
        }
        SharedLibraryInfo highestVersion = null;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            SharedLibraryInfo libraryInfo = versionedLib.valueAt(i);
            if (versionsCallerCanSee == null || versionsCallerCanSee.indexOfKey(libraryInfo.getLongVersion()) >= 0) {
                long libVersionCode = libraryInfo.getDeclaringPackage().getLongVersionCode();
                if (versionCode != -1) {
                    if (libVersionCode == versionCode) {
                        return libraryInfo.getPackageName();
                    }
                } else if (highestVersion == null) {
                    highestVersion = libraryInfo;
                } else if (libVersionCode > highestVersion.getDeclaringPackage().getLongVersionCode()) {
                    highestVersion = libraryInfo;
                }
            }
        }
        if (highestVersion != null) {
            return highestVersion.getPackageName();
        }
        return packageName2;
    }

    /* access modifiers changed from: package-private */
    public boolean isCallerVerifier(int callingUid) {
        int callingUserId = UserHandle.getUserId(callingUid);
        String str = this.mRequiredVerifierPackage;
        if (str == null || callingUid != getPackageUid(str, 0, callingUserId)) {
            return false;
        }
        return true;
    }

    private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) {
        if (callingUid == 2000 || callingUid == 0 || UserHandle.getAppId(callingUid) == 1000) {
            return true;
        }
        int callingUserId = UserHandle.getUserId(callingUid);
        if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) {
            return true;
        }
        String str = this.mRequiredVerifierPackage;
        if (str != null && callingUid == getPackageUid(str, 0, callingUserId)) {
            return true;
        }
        String str2 = this.mRequiredUninstallerPackage;
        if (str2 != null && callingUid == getPackageUid(str2, 0, callingUserId)) {
            return true;
        }
        String str3 = this.mStorageManagerPackage;
        if ((str3 == null || callingUid != getPackageUid(str3, 0, callingUserId)) && checkUidPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callingUid) != 0) {
            return false;
        }
        return true;
    }

    private int[] getBlockUninstallForUsers(String packageName, int[] userIds) {
        int[] result = EMPTY_INT_ARRAY;
        for (int userId : userIds) {
            if (getBlockUninstallForUser(packageName, userId)) {
                result = ArrayUtils.appendInt(result, userId);
            }
        }
        return result;
    }

    public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (checkUidPermission("android.permission.MANAGE_USERS", callingUid) != 0) {
            EventLog.writeEvent(1397638484, "128599183", -1, "");
            throw new SecurityException("android.permission.MANAGE_USERS permission is required to call this API");
        } else if (getInstantAppPackageName(callingUid) == null || isCallerSameApp(packageName, callingUid)) {
            return isPackageDeviceAdmin(packageName, -1);
        } else {
            return false;
        }
    }

    private boolean isPackageDeviceAdmin(String packageName, int userId) {
        IDevicePolicyManager dpm;
        String deviceOwnerPackageName;
        int[] users;
        if (!(packageName == null || (dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"))) == null)) {
            try {
                ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(false);
                if (deviceOwnerComponentName == null) {
                    deviceOwnerPackageName = null;
                } else {
                    deviceOwnerPackageName = deviceOwnerComponentName.getPackageName();
                }
                if (packageName.equals(deviceOwnerPackageName)) {
                    return true;
                }
                for (int i : userId == -1 ? sUserManager.getUserIds() : new int[]{userId}) {
                    if (dpm.packageHasActiveAdmins(packageName, i)) {
                        return true;
                    }
                }
            } catch (RemoteException e) {
            }
        }
        return false;
    }

    private boolean shouldKeepUninstalledPackageLPr(String packageName) {
        List<String> list = this.mKeepUninstalledPackages;
        return list != null && list.contains(packageName);
    }

    private boolean isForbidModeShowDialog() {
        return Settings.Global.getInt(this.mContext.getContentResolver(), "gunstall_forbid_mode", 0) != 0;
    }

    private boolean isNoGMSScheme() {
        return TextUtils.isEmpty(SystemProperties.get("ro.com.google.gmsversion", ""));
    }

    /* JADX INFO: Multiple debug info for r12v4 'freezer'  com.android.server.pm.PackageManagerService$PackageFreezer: [D('freezeUser' int), D('freezer' com.android.server.pm.PackageManagerService$PackageFreezer)] */
    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:132:?, code lost:
        monitor-exit(r17);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x02d3, code lost:
        if (r1 == false) goto L_0x02fb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x02d7, code lost:
        if (r0.removedForAllUsers != false) goto L_0x02dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x02db, code lost:
        if (r0.isRemovedPackageSystemUpdate == false) goto L_0x02e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x02dd, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.updatePackageBlackListInfo(r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:139:0x02e2, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.sendIncompatibleNotificationIfNeeded(r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x02e9, code lost:
        if ((r6 & 8) != 0) goto L_0x02ee;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x02eb, code lost:
        r16 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x02ee, code lost:
        r16 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x02f0, code lost:
        r0.sendPackageRemovedBroadcasts(r16);
        r0.sendSystemPackageUpdatedBroadcasts();
        r0.sendSystemPackageAppearedBroadcasts();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x02fb, code lost:
        java.lang.Runtime.getRuntime().gc();
        r3 = r28.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x0304, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:148:0x0307, code lost:
        if (r0.args == null) goto L_0x0316;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:?, code lost:
        r0.args.doPostDeleteLI(true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x030f, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x0318, code lost:
        if (r21 != null) goto L_0x031b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:?, code lost:
        r2 = r21.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x031d, code lost:
        if (r2 == null) goto L_0x036a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x0321, code lost:
        if (r2.isStub == false) goto L_0x036a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x0323, code lost:
        r6 = r28.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:161:0x0325, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:?, code lost:
        r7 = r28.mSettings.mPackages.get(r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x0332, code lost:
        if (r7 == null) goto L_0x033c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x0336, code lost:
        r9 = r20;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:?, code lost:
        r7.setEnabled(r9, r32, com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x033c, code lost:
        r9 = r20;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x033e, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x033f, code lost:
        if (r9 == 0) goto L_0x0343;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x0341, code lost:
        if (r9 != 1) goto L_0x036c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x0345, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_COMPRESSION == false) goto L_0x035f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x0347, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Enabling system stub after removal; pkg: " + r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x035f, code lost:
        enableCompressedPackage(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x0363, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x0366, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x0367, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0368, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x036c, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x036d, code lost:
        if (r1 == false) goto L_0x0370;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x0373, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x0377, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x037c, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x037d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x037e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x0380, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:220:0x03cf, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:242:?, code lost:
        return -1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:243:?, code lost:
        return 1;
     */
    public int deletePackageX(String packageName, long versionCode, int userId, int deleteFlags) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        PackageSetting disabledSystemPs;
        int origEnabledState;
        int freezeUser;
        int deleteFlags2;
        Object obj;
        PackageFreezer freezer;
        Throwable th;
        PackageSetting disabledSystemPs2;
        int origEnabledState2;
        int currUserId;
        int currUserId2;
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        int i = -1;
        int removeUser = (deleteFlags & 2) != 0 ? -1 : userId;
        if (!mHwPMSEx.isAllowUninstallApp(packageName)) {
            Slog.w(TAG, "Not removing package " + packageName + ": limited by its own");
            return -1;
        }
        HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(2, 0, 0, packageName, (String) null);
        if (isPackageDeviceAdmin(packageName, removeUser)) {
            Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
            if (isNoGMSScheme() || !isForbidModeShowDialog() || TextUtils.isEmpty(packageName) || !packageName.equals("com.google.android.gms")) {
                return -2;
            }
            Slog.w(TAG, "gunstall need to");
        }
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx == null || !iHwPackageManagerServiceEx.isDisallowUninstallApk(packageName)) {
            ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
            synchronized (arrayMap2) {
                try {
                    PackageSetting uninstalledPs = this.mSettings.mPackages.get(packageName);
                    if (uninstalledPs == null) {
                        try {
                            Slog.w(TAG, "Not removing non-existent package " + packageName);
                            return -1;
                        } catch (Throwable th2) {
                            th = th2;
                            arrayMap = arrayMap2;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                            }
                            throw th;
                        }
                    } else if (versionCode == -1 || uninstalledPs.versionCode == versionCode) {
                        PackageSetting disabledSystemPs3 = this.mSettings.getDisabledSystemPkgLPr(packageName);
                        int origEnabledState3 = uninstalledPs.getEnabled(userId);
                        PackageParser.Package pkg = this.mPackages.get(packageName);
                        int[] allUsers = sUserManager.getUserIds();
                        if (pkg == null || pkg.staticSharedLibName == null) {
                            arrayMap = arrayMap2;
                            origEnabledState = origEnabledState3;
                            disabledSystemPs = disabledSystemPs3;
                        } else {
                            arrayMap = arrayMap2;
                            try {
                                SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
                                if (libraryInfo != null) {
                                    int length = allUsers.length;
                                    int i2 = 0;
                                    while (i2 < length) {
                                        int currUserId3 = allUsers[i2];
                                        if (removeUser != i) {
                                            currUserId2 = currUserId3;
                                            if (removeUser != currUserId2) {
                                                currUserId = length;
                                                origEnabledState2 = origEnabledState3;
                                                disabledSystemPs2 = disabledSystemPs3;
                                                i2++;
                                                length = currUserId;
                                                origEnabledState3 = origEnabledState2;
                                                disabledSystemPs3 = disabledSystemPs2;
                                                i = -1;
                                            }
                                        } else {
                                            currUserId2 = currUserId3;
                                        }
                                        currUserId = length;
                                        List<VersionedPackage> libClientPackages = getPackagesUsingSharedLibraryLPr(libraryInfo, 4202496, currUserId2);
                                        if (!ArrayUtils.isEmpty(libClientPackages)) {
                                            Slog.w(TAG, "Not removing package " + pkg.manifestPackageName + " hosting lib " + libraryInfo.getName() + " version " + libraryInfo.getLongVersion() + " used by " + libClientPackages + " for user " + currUserId2);
                                            return -6;
                                        }
                                        origEnabledState2 = origEnabledState3;
                                        disabledSystemPs2 = disabledSystemPs3;
                                        i2++;
                                        length = currUserId;
                                        origEnabledState3 = origEnabledState2;
                                        disabledSystemPs3 = disabledSystemPs2;
                                        i = -1;
                                    }
                                    origEnabledState = origEnabledState3;
                                    disabledSystemPs = disabledSystemPs3;
                                } else {
                                    origEnabledState = origEnabledState3;
                                    disabledSystemPs = disabledSystemPs3;
                                }
                            } catch (Throwable th4) {
                                th = th4;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        }
                        try {
                            info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
                            if (!isUpdatedSystemApp(uninstalledPs) || (deleteFlags & 4) != 0) {
                                freezeUser = removeUser;
                            } else {
                                freezeUser = -1;
                            }
                            if (!HwPackageManagerServiceUtils.isInAntiFillingWhiteList(packageName, hasSystemFeature("android.software.home_screen", 0)) || (uninstalledPs.pkgFlags & 1) == 0) {
                                deleteFlags2 = deleteFlags;
                            } else if (isUpdatedSystemApp(uninstalledPs)) {
                                deleteFlags2 = deleteFlags & -5;
                            } else {
                                Slog.w(TAG, "Not removing package " + packageName + ": limited by anti-filling");
                                return -1;
                            }
                            Object obj2 = this.mInstallLock;
                            synchronized (obj2) {
                                try {
                                    Slog.i(TAG, "deletePackageX: pkg = " + packageName + " user = " + userId);
                                    PackageFreezer freezer2 = freezePackageForDelete(packageName, freezeUser, deleteFlags2, "deletePackageX");
                                    try {
                                        obj = obj2;
                                        freezer = freezer2;
                                        try {
                                            boolean res = deletePackageLIF(packageName, UserHandle.of(removeUser), true, allUsers, deleteFlags2 | Integer.MIN_VALUE, info, true, null);
                                            PackageParser.Package stubPkg = null;
                                            if (freezer != null) {
                                                try {
                                                    $closeResource(null, freezer);
                                                } catch (Throwable th5) {
                                                    th = th5;
                                                }
                                            }
                                            try {
                                                synchronized (this.mPackages) {
                                                    if (res) {
                                                        if (pkg != null) {
                                                            try {
                                                                this.mInstantAppRegistry.onPackageUninstalledLPw(pkg, info.removedUsers);
                                                            } catch (Throwable th6) {
                                                                th = th6;
                                                            }
                                                        }
                                                        try {
                                                            try {
                                                                updateSequenceNumberLP(uninstalledPs, info.removedUsers);
                                                                updateInstantAppInstallerLocked(packageName);
                                                            } catch (Throwable th7) {
                                                                th = th7;
                                                            }
                                                        } catch (Throwable th8) {
                                                            th = th8;
                                                            while (true) {
                                                                try {
                                                                    break;
                                                                } catch (Throwable th9) {
                                                                    th = th9;
                                                                }
                                                            }
                                                            throw th;
                                                        }
                                                    }
                                                    try {
                                                    } catch (Throwable th10) {
                                                        th = th10;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw th;
                                                    }
                                                }
                                            } catch (Throwable th11) {
                                                th = th11;
                                                throw th;
                                            }
                                        } catch (Throwable th12) {
                                            th = th12;
                                            try {
                                                throw th;
                                            } catch (Throwable th13) {
                                                if (freezer != null) {
                                                    $closeResource(th, freezer);
                                                }
                                                throw th13;
                                            }
                                        }
                                    } catch (Throwable th14) {
                                        freezer = freezer2;
                                        th = th14;
                                        throw th;
                                    }
                                } catch (Throwable th15) {
                                    th = th15;
                                    obj = obj2;
                                    throw th;
                                }
                            }
                        } catch (Throwable th16) {
                            th = th16;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } else {
                        Slog.w(TAG, "Not removing package " + packageName + " with versionCode " + uninstalledPs.versionCode + " != " + versionCode);
                        return -1;
                    }
                } catch (Throwable th17) {
                    th = th17;
                    arrayMap = arrayMap2;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        } else {
            Flog.i(209, "Not removing package " + packageName + ": is disallowed!");
            return -4;
        }
    }

    static class PackageRemovedInfo {
        ArrayMap<String, PackageInstalledInfo> appearedChildPackages;
        InstallArgs args = null;
        int[] broadcastUsers = null;
        boolean dataRemoved;
        SparseArray<Integer> installReasons;
        String installerPackageName;
        int[] instantUserIds = null;
        boolean isRemovedPackageSystemUpdate = false;
        boolean isStaticSharedLib;
        boolean isUpdate;
        int[] origUsers;
        final PackageSender packageSender;
        int removedAppId = -1;
        ArrayMap<String, PackageRemovedInfo> removedChildPackages;
        boolean removedForAllUsers;
        String removedPackage;
        int[] removedUsers = null;
        int uid = -1;

        PackageRemovedInfo(PackageSender packageSender2) {
            this.packageSender = packageSender2;
        }

        /* access modifiers changed from: package-private */
        public void sendPackageRemovedBroadcasts(boolean killApp) {
            sendPackageRemovedBroadcastInternal(killApp);
            ArrayMap<String, PackageRemovedInfo> arrayMap = this.removedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.removedChildPackages.valueAt(i).sendPackageRemovedBroadcastInternal(killApp);
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageUpdatedBroadcasts() {
            if (this.isRemovedPackageSystemUpdate) {
                sendSystemPackageUpdatedBroadcastsInternal();
                ArrayMap<String, PackageRemovedInfo> arrayMap = this.removedChildPackages;
                int childCount = arrayMap != null ? arrayMap.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    PackageRemovedInfo childInfo = this.removedChildPackages.valueAt(i);
                    if (childInfo.isRemovedPackageSystemUpdate) {
                        childInfo.sendSystemPackageUpdatedBroadcastsInternal();
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageAppearedBroadcasts() {
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.appearedChildPackages;
            int packageCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < packageCount; i++) {
                PackageInstalledInfo installedInfo = this.appearedChildPackages.valueAt(i);
                this.packageSender.sendPackageAddedForNewUsers(installedInfo.name, true, false, UserHandle.getAppId(installedInfo.uid), installedInfo.newUsers, null);
            }
        }

        private void sendSystemPackageUpdatedBroadcastsInternal() {
            Bundle extras = new Bundle(2);
            int i = this.removedAppId;
            if (i < 0) {
                i = this.uid;
            }
            extras.putInt("android.intent.extra.UID", i);
            extras.putBoolean("android.intent.extra.REPLACING", true);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, this.removedPackage, null, null, null);
            String str = this.installerPackageName;
            if (str != null) {
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, str, null, null, null);
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, this.installerPackageName, null, null, null);
            }
        }

        private void sendPackageRemovedBroadcastInternal(boolean killApp) {
            if (!this.isStaticSharedLib) {
                Bundle extras = new Bundle(2);
                int removedUid = this.removedAppId;
                if (removedUid < 0) {
                    removedUid = this.uid;
                }
                extras.putInt("android.intent.extra.UID", removedUid);
                extras.putBoolean("android.intent.extra.DATA_REMOVED", this.dataRemoved);
                extras.putBoolean("android.intent.extra.DONT_KILL_APP", !killApp);
                if (this.isUpdate || this.isRemovedPackageSystemUpdate) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                extras.putBoolean("android.intent.extra.REMOVED_FOR_ALL_USERS", this.removedForAllUsers);
                String str = this.removedPackage;
                if (str != null) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", str, extras, 0, null, null, this.broadcastUsers, this.instantUserIds);
                    String str2 = this.installerPackageName;
                    if (str2 != null) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, str2, null, this.broadcastUsers, this.instantUserIds);
                    }
                    if (this.dataRemoved && !this.isRemovedPackageSystemUpdate) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_FULLY_REMOVED", this.removedPackage, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                        this.packageSender.notifyPackageRemoved(this.removedPackage, removedUid);
                    }
                }
                if (this.removedAppId >= 0) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.UID_REMOVED", null, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                }
                PackageSender packageSender2 = this.packageSender;
                if (packageSender2 instanceof PackageManagerService) {
                    ((PackageManagerService) packageSender2).deleteClonedProfileIfNeed(this.broadcastUsers);
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void populateUsers(int[] userIds, PackageSetting deletedPackageSetting) {
            this.removedUsers = userIds;
            if (this.removedUsers == null) {
                this.broadcastUsers = null;
                return;
            }
            this.broadcastUsers = PackageManagerService.EMPTY_INT_ARRAY;
            this.instantUserIds = PackageManagerService.EMPTY_INT_ARRAY;
            for (int i = userIds.length - 1; i >= 0; i--) {
                int userId = userIds[i];
                if (deletedPackageSetting.getInstantApp(userId)) {
                    this.instantUserIds = ArrayUtils.appendInt(this.instantUserIds, userId);
                } else {
                    this.broadcastUsers = ArrayUtils.appendInt(this.broadcastUsers, userId);
                }
            }
        }
    }

    private void removePackageDataLIF(PackageSetting deletedPs, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) {
        boolean installedStateChanged;
        PackageParser.Package resolvedPkg;
        String packageName = deletedPs.name;
        Slog.i(TAG, "removePackageDataLI: " + packageName);
        PackageParser.Package deletedPkg = deletedPs.pkg;
        if (outInfo != null) {
            outInfo.removedPackage = packageName;
            outInfo.installerPackageName = deletedPs.installerPackageName;
            outInfo.isStaticSharedLib = (deletedPkg == null || deletedPkg.staticSharedLibName == null) ? false : true;
            outInfo.populateUsers(deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true), deletedPs);
        }
        removePackageLI(deletedPs.name, (flags & Integer.MIN_VALUE) != 0);
        if ((flags & 1) == 0) {
            if (deletedPkg != null) {
                resolvedPkg = deletedPkg;
            } else {
                resolvedPkg = new PackageParser.Package(deletedPs.name);
                resolvedPkg.setVolumeUuid(deletedPs.volumeUuid);
            }
            long startTime = SystemClock.uptimeMillis();
            destroyAppDataLIF(resolvedPkg, -1, 7);
            Slog.i(TAG, "destroyAppDataLIF time cost : " + (SystemClock.uptimeMillis() - startTime) + " ms");
            destroyAppProfilesLIF(resolvedPkg);
            if (outInfo != null) {
                outInfo.dataRemoved = true;
            }
        }
        int removedAppId = -1;
        if ((flags & 1) == 0) {
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            synchronized (this.mPackages) {
                clearIntentFilterVerificationsLPw(deletedPs.name, -1);
                clearDefaultBrowserIfNeeded(packageName);
                this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName);
                removedAppId = this.mSettings.removePackageLPw(packageName);
                if (outInfo != null) {
                    outInfo.removedAppId = removedAppId;
                }
                this.mPermissionManager.updatePermissions(deletedPs.name, null, false, this.mPackages.values(), this.mPermissionCallback);
                if (deletedPs.sharedUser != null) {
                    int[] userIds = UserManagerService.getInstance().getUserIds();
                    int length = userIds.length;
                    int i = 0;
                    while (true) {
                        if (i >= length) {
                            break;
                        }
                        int userIdToKill = this.mSettings.updateSharedUserPermsLPw(deletedPs, userIds[i]);
                        if (userIdToKill == -1) {
                            break;
                        } else if (userIdToKill >= 0) {
                            break;
                        } else {
                            i++;
                        }
                    }
                    this.mHandler.post(new Runnable(deletedPs) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$gcU1RKL3rEcBWLR2OlkcyejcM9M */
                        private final /* synthetic */ PackageSetting f$1;

                        {
                            this.f$1 = r2;
                        }

                        public final void run() {
                            PackageManagerService.this.lambda$removePackageDataLIF$21$PackageManagerService(this.f$1);
                        }
                    });
                }
                if (!"com.huawei.android.launcher".equals(deletedPs.name)) {
                    clearPackagePreferredActivitiesLPw(deletedPs.name, changedUsers, -1);
                }
            }
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(-1);
            }
        }
        if (allUserHandles == null || outInfo == null || outInfo.origUsers == null) {
            installedStateChanged = false;
        } else {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Propagating install state across downgrade");
            }
            installedStateChanged = false;
            for (int userId : allUserHandles) {
                boolean installed = ArrayUtils.contains(outInfo.origUsers, userId);
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "    user " + userId + " => " + installed);
                }
                if (installed != deletedPs.getInstalled(userId)) {
                    installedStateChanged = true;
                }
                deletedPs.setInstalled(installed, userId);
            }
        }
        synchronized (this.mPackages) {
            if (writeSettings) {
                try {
                    this.mSettings.writeLPr();
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (installedStateChanged) {
                this.mSettings.writeKernelMappingLPr(deletedPs);
            }
            if ((deletedPs.pkg.applicationInfo.hwFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0) {
                HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName);
            }
        }
        if (removedAppId != -1) {
            removeKeystoreDataIfNeeded(-1, removedAppId);
        }
    }

    public /* synthetic */ void lambda$removePackageDataLIF$21$PackageManagerService(PackageSetting deletedPs) {
        killApplication(deletedPs.name, deletedPs.appId, KILL_APP_REASON_GIDS_CHANGED);
    }

    static boolean locationIsPrivileged(String path) {
        try {
            boolean isPrivilegedAppHw = mHwPMSEx.isPrivAppNonSystemPartitionDir(new File(path));
            if (isPrivilegedAppHw) {
                return isPrivilegedAppHw;
            }
            File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
            File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), "priv-app");
            File privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
            File privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
            File privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
            if (!path.startsWith(privilegedAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (!path.startsWith(privilegedVendorAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                    if (!path.startsWith(privilegedOdmAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                        if (!path.startsWith(privilegedProductAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                            if (path.startsWith(privilegedProductServicesAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                return true;
                            }
                            return false;
                        }
                    }
                }
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOem(String path) {
        try {
            return path.startsWith(Environment.getOemDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsVendor(String path) {
        try {
            if (!path.startsWith(Environment.getVendorDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (path.startsWith(Environment.getOdmDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER) || HwPackageManagerServiceUtils.hwlocationIsVendor(path)) {
                    return true;
                }
                return false;
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProduct(String path) {
        try {
            if (path.startsWith(Environment.getProductDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER) || HwPackageManagerServiceUtils.hwlocationIsProduct(path)) {
                return true;
            }
            return false;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProductServices(String path) {
        try {
            return path.startsWith(Environment.getProductServicesDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOdm(String path) {
        try {
            return path.startsWith(Environment.getOdmDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x01f7, code lost:
        r0.setEnabled(2, 0, com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x01fe, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x0200, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:?, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Failed to restore system package:" + r15.packageName + ": " + r0.getMessage());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x022a, code lost:
        throw new com.android.server.pm.PackageManagerService.SystemDeleteException(r0, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x023f, code lost:
        r1.setEnabled(2, 0, com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0245, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x006e, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isPreRemovableApp(r7.codePath.toString()) == false) goto L_0x007c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x007f, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_REMOVE == false) goto L_0x00b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0081, code lost:
        if (r1 == false) goto L_0x00b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x0083, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "Remembering install states:");
        r1 = r21.length;
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:0x008c, code lost:
        if (r2 >= r1) goto L_0x00b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:0x008e, code lost:
        r3 = r21[r2];
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "   u=" + r3 + " inst=" + com.android.internal.util.ArrayUtils.contains(r23.origUsers, r3));
        r2 = r2 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x00b7, code lost:
        if (r23 == null) goto L_0x00bb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x00b9, code lost:
        r23.isRemovedPackageSystemUpdate = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x00bb, code lost:
        if (r23 == null) goto L_0x00f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x00bf, code lost:
        if (r23.removedChildPackages == null) goto L_0x00f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x00c3, code lost:
        if (r20.childPackageNames == null) goto L_0x00cc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x00c5, code lost:
        r1 = r20.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x00cc, code lost:
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x00cd, code lost:
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00ce, code lost:
        if (r2 >= r1) goto L_0x00f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00d0, code lost:
        r3 = (java.lang.String) r20.childPackageNames.get(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00da, code lost:
        if (r7.childPackageNames == null) goto L_0x00f0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x00e2, code lost:
        if (r7.childPackageNames.contains(r3) == false) goto L_0x00f0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x00e4, code lost:
        r4 = r23.removedChildPackages.get(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x00ec, code lost:
        if (r4 == null) goto L_0x00f0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x00ee, code lost:
        r4.isRemovedPackageSystemUpdate = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x00f0, code lost:
        r2 = r2 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x00f9, code lost:
        if (r7.versionCode >= r20.versionCode) goto L_0x0100;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x00fb, code lost:
        r16 = r22 & -2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0106, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isDelapp(r7) != false) goto L_0x011e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x010e, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isDelappInData(r7) != false) goto L_0x011e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x011c, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isPreRemovableApp(r7.codePath.toString()) == false) goto L_0x012b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0124, code lost:
        if (r7.versionCode != r20.versionCode) goto L_0x012b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0126, code lost:
        r16 = r22 & -2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x012b, code lost:
        r16 = r22 | 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x012f, code lost:
        deleteInstalledPackageLIF(r20, true, r16, r21, r23, r24, r7.pkg);
        r2 = r18.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x0148, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:?, code lost:
        enableSystemPackageLPw(r7.pkg);
        removeNativeBinariesLI(r20);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x0151, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0154, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_REMOVE == false) goto L_0x016c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0156, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "Re-installing system package: " + r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:?, code lost:
        r1 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r18);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x017a, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isDelapp(r7) != false) goto L_0x01c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0182, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isDelappInData(r7) != false) goto L_0x01c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x0190, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isPreRemovableApp(r7.codePath.toString()) == false) goto L_0x0194;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x0192, code lost:
        r1 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x0194, code lost:
        r2 = r7.codePathString;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x0196, code lost:
        if (r23 != null) goto L_0x019a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x0198, code lost:
        r4 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x019a, code lost:
        r4 = r23.origUsers;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x019d, code lost:
        installPackageFromSystemLIF(r2, r21, r4, r20.getPermissionsState(), r24);
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "restore system package");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x01bd, code lost:
        if ("com.huawei.android.launcher".equals(r7.pkg.packageName) == false) goto L_0x01e3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x01bf, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.restoreHwLauncherMode(r21);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01c5, code lost:
        r1 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01c6, code lost:
        com.android.server.pm.PackageManagerService.mHwPMSEx.recordUninstalledDelapp(r15.packageName, r7.codePathString);
        r1.removedPackage = r15.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x01d3, code lost:
        if (r23 == null) goto L_0x01d8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x01d5, code lost:
        r23.isRemovedPackageSystemUpdate = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x01d8, code lost:
        r1.sendPackageRemovedBroadcasts(true);
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "it is a preRemovable app, stop to restore system package");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x01e7, code lost:
        if (r7.pkg.isStub == false) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01e9, code lost:
        r0 = r18.mSettings.mPackages.get(r15.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x01f5, code lost:
        if (r0 == null) goto L_?;
     */
    private void deleteSystemPackageLIF(DeletePackageAction action, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) throws SystemDeleteException {
        boolean applyUserRestrictions = (allUserHandles == null || outInfo == null || outInfo.origUsers == null) ? false : true;
        PackageParser.Package deletedPkg = deletedPs.pkg;
        PackageSetting disabledPs = action.disabledPs;
        if (disabledPs != null) {
            if (disabledPs.pkg != null) {
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "deleteSystemPackageLI: newPs=" + deletedPkg.packageName + " disabledPs=" + disabledPs);
                }
                Slog.d(TAG, "Deleting system pkg from data partition");
                synchronized (this.mPackages) {
                    try {
                        if (!mHwPMSEx.isDelapp(disabledPs)) {
                            try {
                                if (!mHwPMSEx.isDelappInData(disabledPs)) {
                                }
                            } catch (Throwable th) {
                                th = th;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th2) {
                                        th = th2;
                                    }
                                }
                                throw th;
                            }
                        }
                        this.mSettings.removeDisabledSystemPackageLPw(deletedPs.name);
                    } catch (Throwable th3) {
                        th = th3;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            }
        }
        Slog.w(TAG, "Attempt to delete unknown system package " + deletedPkg.packageName);
    }

    private PackageParser.Package installPackageFromSystemLIF(String codePathString, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
        int scanFlags;
        int i;
        boolean applyUserRestrictions;
        File codePath;
        boolean installed;
        boolean z = true;
        int parseFlags = this.mDefParseFlags | 1 | 16;
        int scanFlags2 = 131072;
        if (locationIsPrivileged(codePathString)) {
            scanFlags2 = 131072 | 262144;
        }
        if (locationIsOem(codePathString)) {
            scanFlags2 |= 524288;
        }
        if (locationIsVendor(codePathString)) {
            scanFlags2 |= 1048576;
        }
        if (locationIsProduct(codePathString)) {
            scanFlags2 |= 2097152;
        }
        if (locationIsProductServices(codePathString)) {
            scanFlags2 |= 4194304;
        }
        if (locationIsOdm(codePathString)) {
            scanFlags = scanFlags2 | 8388608;
        } else {
            scanFlags = scanFlags2;
        }
        File codePath2 = new File(codePathString);
        PackageParser.Package pkg = scanPackageTracedLI(codePath2, parseFlags, scanFlags | 8192, 0, (UserHandle) null);
        try {
            updateSharedLibrariesLocked(pkg, null, Collections.unmodifiableMap(this.mPackages));
        } catch (PackageManagerException e) {
            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
        }
        prepareAppDataAfterInstallLIF(pkg);
        synchronized (this.mPackages) {
            try {
                PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                if (origPermissionState != null) {
                    try {
                        ps.getPermissionsState().copyFrom(origPermissionState);
                    } catch (Throwable th) {
                        th = th;
                    }
                }
                this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                if (allUserHandles == null || origUserHandles == null) {
                    z = false;
                }
                boolean applyUserRestrictions2 = z;
                if (applyUserRestrictions2) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across reinstall");
                    }
                    boolean installedStateChanged = false;
                    int i2 = 0;
                    for (int length = allUserHandles.length; i2 < length; length = i) {
                        int userId = allUserHandles[i2];
                        boolean installed2 = ArrayUtils.contains(origUserHandles, userId);
                        if (DEBUG_REMOVE) {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            StringBuilder sb = new StringBuilder();
                            i = length;
                            sb.append("    user ");
                            sb.append(userId);
                            sb.append(" => ");
                            installed = installed2;
                            sb.append(installed);
                            Slog.d(TAG, sb.toString());
                        } else {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            i = length;
                            installed = installed2;
                        }
                        if (installed != ps.getInstalled(userId)) {
                            installedStateChanged = true;
                        }
                        ps.setInstalled(installed, userId);
                        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                        i2++;
                        codePath2 = codePath;
                        applyUserRestrictions2 = applyUserRestrictions;
                    }
                    this.mSettings.writeAllUsersPackageRestrictionsLPr();
                    if (installedStateChanged) {
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                }
                if (writeSettings) {
                    this.mSettings.writeLPr();
                }
                return pkg;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:26:0x0051, code lost:
        removePackageDataLIF(r14, r17, r18, r16, r19);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:27:0x0060, code lost:
        if (r14.childPackageNames == null) goto L_0x0068;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x0062, code lost:
        r0 = r14.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0068, code lost:
        r12 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x006b, code lost:
        if (r12 >= r0) goto L_0x00b7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x006d, code lost:
        r1 = r13.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x006f, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:?, code lost:
        r0 = r13.mSettings.getPackageLPr((java.lang.String) r14.childPackageNames.get(r12));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x007e, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x007f, code lost:
        if (r0 == null) goto L_0x00b1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x0081, code lost:
        if (r18 == null) goto L_0x0092;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x0085, code lost:
        if (r18.removedChildPackages == null) goto L_0x0092;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:40:0x0087, code lost:
        r1 = r18.removedChildPackages.get(r0.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x0092, code lost:
        r1 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x0096, code lost:
        if ((r16 & 1) == 0) goto L_0x00a6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x0098, code lost:
        if (r20 == null) goto L_0x00a6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00a0, code lost:
        if (r20.hasChildPackage(r0.name) != false) goto L_0x00a6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00a2, code lost:
        r5 = r16 & -2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x00a6, code lost:
        r5 = r16;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x00a8, code lost:
        removePackageDataLIF(r0, r17, r1, r5, r19);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x00b1, code lost:
        r12 = r12 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x00b9, code lost:
        if (r14.parentPackageName != null) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x00bb, code lost:
        if (r15 == false) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x00bd, code lost:
        if (r18 == null) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x00bf, code lost:
        r18.args = createInstallArgsForExisting(r14.codePathString, r14.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r14));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:?, code lost:
        return;
     */
    private void deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        synchronized (this.mPackages) {
            if (outInfo != null) {
                try {
                    outInfo.uid = ps.appId;
                } catch (Throwable th) {
                    throw th;
                }
            }
            int childCount = 0;
            if (!(outInfo == null || outInfo.removedChildPackages == null)) {
                int childCount2 = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
                int i = 0;
                while (i < childCount2) {
                    String childPackageName = (String) ps.childPackageNames.get(i);
                    PackageSetting childPs = this.mSettings.mPackages.get(childPackageName);
                    if (childPs != null) {
                        PackageRemovedInfo childInfo = outInfo.removedChildPackages.get(childPackageName);
                        if (childInfo != null) {
                            childInfo.uid = childPs.appId;
                        }
                        i++;
                    } else {
                        return;
                    }
                }
            }
        }
    }

    public boolean setBlockUninstallForUser(String packageName, boolean blockUninstall, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || pkg.staticSharedLibName == null) {
                this.mSettings.setBlockUninstallLPw(userId, packageName, blockUninstall);
                this.mSettings.writePackageRestrictionsLPr(userId);
                return true;
            }
            Slog.w(TAG, "Cannot block uninstall of package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
            return false;
        }
    }

    public boolean getBlockUninstallForUser(String packageName, int userId) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                    return this.mSettings.getBlockUninstallLPr(userId, packageName);
                }
            }
            return false;
        }
    }

    public boolean setRequiredForSystemUser(String packageName, boolean systemUserApp) {
        enforceSystemOrRoot("setRequiredForSystemUser can only be run by the system or root");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Log.w(TAG, "Package doesn't exist: " + packageName);
                return false;
            }
            if (systemUserApp) {
                ps.pkgPrivateFlags |= 512;
            } else {
                ps.pkgPrivateFlags &= -513;
            }
            this.mSettings.writeLPr();
            return true;
        }
    }

    private static class DeletePackageAction {
        public final PackageSetting deletingPs;
        public final PackageSetting disabledPs;
        public final int flags;
        public final PackageRemovedInfo outInfo;
        public final UserHandle user;

        private DeletePackageAction(PackageSetting deletingPs2, PackageSetting disabledPs2, PackageRemovedInfo outInfo2, int flags2, UserHandle user2) {
            this.deletingPs = deletingPs2;
            this.disabledPs = disabledPs2;
            this.outInfo = outInfo2;
            this.flags = flags2;
            this.user = user2;
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:39:0x0082  */
    /* JADX WARNING: Removed duplicated region for block: B:60:0x00d8  */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x00df  */
    /* JADX WARNING: Removed duplicated region for block: B:64:0x00e3  */
    /* JADX WARNING: Removed duplicated region for block: B:65:0x00e5  */
    /* JADX WARNING: Removed duplicated region for block: B:68:0x00e9 A[RETURN] */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x00ea A[ADDED_TO_REGION] */
    @GuardedBy({"mPackages"})
    private static DeletePackageAction mayDeletePackageLocked(PackageRemovedInfo outInfo, PackageSetting ps, PackageSetting disabledPs, PackageSetting[] children, int flags, UserHandle user) {
        int flags2;
        int parentReferenceCount;
        int childCount;
        if (ps == null) {
            return null;
        }
        if (ps.pkg == null) {
            Slog.w(TAG, "ps.pkg is null!");
            return null;
        } else if (ps.pkg.applicationInfo == null) {
            Slog.w(TAG, "ps.pkg.applicationInfo is null!");
            return null;
        } else {
            boolean deleteAllUsers = true;
            boolean isRemovableSysApp = isSystemApp(ps) && !((ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) == 0 && (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0);
            if (isRemovableSysApp && user != null && user.getIdentifier() != -1 && sUserManager.getUserIds().length > 1) {
                int[] installUser = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                if (!(installUser.length == 0 || (installUser.length == 1 && installUser[0] == user.getIdentifier()))) {
                    flags2 = flags | 4;
                    if (isSystemApp(ps)) {
                        if (ps.parentPackageName != null) {
                            Slog.w(TAG, "Attempt to delete child system package " + ps.pkg.packageName);
                            return null;
                        }
                        boolean deleteSystem = (flags2 & 4) != 0;
                        if (!(user == null || user.getIdentifier() == -1)) {
                            deleteAllUsers = false;
                        }
                        if ((!deleteSystem || deleteAllUsers) && disabledPs == null && !isRemovableSysApp) {
                            Slog.w(TAG, "Attempt to delete unknown system package " + ps.pkg.packageName);
                            return null;
                        }
                    }
                    parentReferenceCount = ps.childPackageNames == null ? ps.childPackageNames.size() : 0;
                    childCount = children == null ? children.length : 0;
                    if (childCount == parentReferenceCount) {
                        return null;
                    }
                    if (!(childCount == 0 || outInfo == null || outInfo.removedChildPackages == null)) {
                        for (PackageSetting child : children) {
                            if (child == null || !ps.childPackageNames.contains(child.name)) {
                                return null;
                            }
                        }
                    }
                    return new DeletePackageAction(ps, disabledPs, outInfo, flags2, user);
                }
            }
            flags2 = flags;
            if (isSystemApp(ps)) {
            }
            if (ps.childPackageNames == null) {
            }
            if (children == null) {
            }
            if (childCount == parentReferenceCount) {
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0091, code lost:
        r0 = th;
     */
    private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        DeletePackageAction action;
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            action = mayDeletePackageLocked(outInfo, ps, this.mSettings.getDisabledSystemPkgLPr(ps), this.mSettings.getChildSettingsLPr(ps), flags, user);
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deletePackageLI: " + packageName + " user " + user + " flags " + flags);
        }
        if (action == null) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "deletePackageLI: action was null");
            }
            return false;
        }
        try {
            executeDeletePackageLIF(action, packageName, deleteCodeAndResources, allUserHandles, writeSettings, replacingPackage);
            return true;
        } catch (SystemDeleteException e) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "deletePackageLI: system deletion failure", e);
            }
            return false;
        }
        while (true) {
        }
    }

    private static class SystemDeleteException extends Exception {
        public final PackageManagerException reason;

        private SystemDeleteException(PackageManagerException reason2) {
            this.reason = reason2;
        }
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r0v10 */
    /* JADX WARN: Type inference failed for: r0v43 */
    /* JADX WARN: Type inference failed for: r0v44 */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0156, code lost:
        r0 = th;
     */
    private void executeDeletePackageLIF(DeletePackageAction action, String packageName, boolean deleteCodeAndResources, int[] allUserHandles, boolean writeSettings, PackageParser.Package replacingPackage) throws SystemDeleteException {
        boolean systemApp;
        boolean z;
        boolean isRemovablePreinstalledApp;
        int childCount;
        boolean keepUninstalledPackage;
        PackageSetting disabledPs;
        PackageSetting ps = action.deletingPs;
        PackageRemovedInfo outInfo = action.outInfo;
        UserHandle user = action.user;
        int flags = action.flags;
        boolean systemApp2 = isSystemApp(ps);
        int removedUserId = -1;
        if (ps.parentPackageName == null || (systemApp2 && (flags & 4) == 0)) {
            if (DEBUG_REMOVE) {
                Flog.i(209, "executeDeletePackageLIF: pkg " + packageName + " isSysApp: " + systemApp2 + " hwflag: " + ps.pkg.applicationInfo.hwFlags + " for user " + user);
            }
            int userId = user == null ? -1 : user.getIdentifier();
            if (ps.getPermissionsState().hasPermission("android.permission.SUSPEND_APPS", userId)) {
                unsuspendForSuspendingPackage(packageName, userId);
            }
            if ((!systemApp2 || (flags & 4) != 0) && userId != -1) {
                synchronized (this.mPackages) {
                    markPackageUninstalledForUserLPw(ps, user);
                    if (!systemApp2) {
                        boolean keepUninstalledPackage2 = shouldKeepUninstalledPackageLPr(packageName);
                        if (!ps.isAnyInstalled(sUserManager.getUserIds())) {
                            if (!keepUninstalledPackage2) {
                                if (DEBUG_REMOVE) {
                                    Slog.d(TAG, "Not installed by other users, full delete");
                                }
                                ps.setInstalled(true, userId);
                                this.mSettings.writeKernelMappingLPr(ps);
                                keepUninstalledPackage = false;
                            }
                        }
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "Still installed by other users");
                        }
                        keepUninstalledPackage = true;
                    } else {
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "Deleting system app");
                        }
                        boolean isRemovablePreinstalledApp2 = (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) != 0;
                        boolean isUpdatedPreApp = (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) != 0;
                        if (isRemovablePreinstalledApp2) {
                            mHwPMSEx.recordUninstalledDelapp(ps.pkg.packageName, ps.pkg.codePath);
                        } else if (isUpdatedPreApp) {
                            synchronized (this.mPackages) {
                                disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps.pkg.packageName);
                            }
                            mHwPMSEx.recordUninstalledDelapp(ps.pkg.packageName, disabledPs.codePathString);
                        }
                        keepUninstalledPackage = true;
                    }
                }
                if (keepUninstalledPackage) {
                    clearPackageStateForUserLIF(ps, userId, outInfo, flags);
                    synchronized (this.mPackages) {
                        scheduleWritePackageRestrictionsLocked(user);
                    }
                    return;
                }
            }
            if (ps.childPackageNames != null && outInfo != null) {
                synchronized (this.mPackages) {
                    int childCount2 = ps.childPackageNames.size();
                    outInfo.removedChildPackages = new ArrayMap<>(childCount2);
                    int i = 0;
                    while (i < childCount2) {
                        String childPackageName = (String) ps.childPackageNames.get(i);
                        PackageRemovedInfo childInfo = new PackageRemovedInfo(this);
                        childInfo.removedPackage = childPackageName;
                        childInfo.installerPackageName = ps.installerPackageName;
                        outInfo.removedChildPackages.put(childPackageName, childInfo);
                        PackageSetting childPs = this.mSettings.getPackageLPr(childPackageName);
                        if (childPs != null) {
                            childCount = childCount2;
                            childInfo.origUsers = childPs.queryInstalledUsers(allUserHandles, true);
                        } else {
                            childCount = childCount2;
                        }
                        i++;
                        childCount2 = childCount;
                    }
                }
            }
            boolean isSystemAppGrantByMdm = isSystemAppGrantByMdmAndNonPreload(ps.name, ps.codePathString, ps.volumeUuid);
            if (!systemApp2 || (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) != 0 || isSystemAppGrantByMdm) {
                systemApp = systemApp2;
                z = false;
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Removing non-system package: " + ps.name);
                }
                if ((ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) != 0) {
                    isRemovablePreinstalledApp = true;
                } else {
                    isRemovablePreinstalledApp = false;
                }
                Slog.i(TAG, "Removing non-system or removable preinstalled package: " + ps.name + ", isRemovablePreinstalledApp = " + isRemovablePreinstalledApp);
                deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles, outInfo, writeSettings, replacingPackage);
                if (isRemovablePreinstalledApp) {
                    mHwPMSEx.recordUninstalledDelapp(ps.pkg.packageName, ps.pkg.codePath);
                }
                synchronized (this.mPackages) {
                    mHwPMSEx.updateCertCompatPackage(ps.pkg, null);
                }
            } else {
                Slog.i(TAG, "Removing system package: " + ps.name);
                z = false;
                systemApp = systemApp2;
                deleteSystemPackageLIF(action, ps, allUserHandles, flags, outInfo, writeSettings);
            }
            synchronized (this.mPackages) {
                mHwPMSEx.writeCertCompatPackages(z);
            }
            if (outInfo != null) {
                outInfo.removedForAllUsers = this.mPackages.get(ps.name) == null ? true : z;
                if (outInfo.removedChildPackages != null) {
                    synchronized (this.mPackages) {
                        int childCount3 = outInfo.removedChildPackages.size();
                        for (int i2 = 0; i2 < childCount3; i2++) {
                            PackageRemovedInfo childInfo2 = outInfo.removedChildPackages.valueAt(i2);
                            if (childInfo2 != null) {
                                childInfo2.removedForAllUsers = this.mPackages.get(childInfo2.removedPackage) == null ? true : z;
                            }
                        }
                    }
                }
                if (systemApp) {
                    synchronized (this.mPackages) {
                        PackageSetting updatedPs = this.mSettings.getPackageLPr(ps.name);
                        int childCount4 = z;
                        if (updatedPs != null) {
                            childCount4 = z;
                            if (updatedPs.childPackageNames != null) {
                                childCount4 = updatedPs.childPackageNames.size();
                            }
                        }
                        for (int i3 = 0; i3 < childCount4; i3++) {
                            String childPackageName2 = (String) updatedPs.childPackageNames.get(i3);
                            if (outInfo.removedChildPackages != null) {
                                if (outInfo.removedChildPackages.indexOfKey(childPackageName2) >= 0) {
                                }
                            }
                            PackageSetting childPs2 = this.mSettings.getPackageLPr(childPackageName2);
                            if (childPs2 != null) {
                                PackageInstalledInfo installRes = new PackageInstalledInfo();
                                installRes.name = childPackageName2;
                                installRes.newUsers = childPs2.queryInstalledUsers(allUserHandles, true);
                                installRes.pkg = this.mPackages.get(childPackageName2);
                                installRes.uid = childPs2.pkg.applicationInfo.uid;
                                if (outInfo.appearedChildPackages == null) {
                                    outInfo.appearedChildPackages = new ArrayMap<>();
                                }
                                outInfo.appearedChildPackages.put(childPackageName2, installRes);
                            }
                        }
                    }
                    return;
                }
                return;
            }
            return;
        }
        if (DEBUG_REMOVE) {
            StringBuilder sb = new StringBuilder();
            sb.append("Uninstalled child package:");
            sb.append(packageName);
            sb.append(" for user:");
            sb.append(user == null ? -1 : user);
            Slog.d(TAG, sb.toString());
        }
        if (user != null) {
            removedUserId = user.getIdentifier();
        }
        clearPackageStateForUserLIF(ps, removedUserId, outInfo, flags);
        synchronized (this.mPackages) {
            markPackageUninstalledForUserLPw(ps, user);
            scheduleWritePackageRestrictionsLocked(user);
        }
        return;
        while (true) {
        }
    }

    @GuardedBy({"mPackages"})
    private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) {
        PackageSetting packageSetting = ps;
        int i = 0;
        int[] userIds = (user == null || user.getIdentifier() == -1) ? sUserManager.getUserIds() : new int[]{user.getIdentifier()};
        int length = userIds.length;
        while (i < length) {
            int nextUserId = userIds[i];
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Marking package:" + packageSetting.name + " uninstalled for user:" + nextUserId);
            }
            ps.setUserState(nextUserId, 0, 0, false, true, true, false, 0, false, null, null, null, null, false, false, null, null, null, packageSetting.readUserState(nextUserId).domainVerificationStatus, 0, 0, null);
            i++;
            packageSetting = ps;
            length = length;
            userIds = userIds;
        }
        this.mSettings.writeKernelMappingLPr(ps);
    }

    private void clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo, int flags) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(ps.name);
        }
        destroyAppProfilesLIF(pkg);
        boolean z = false;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Updating package:" + ps.name + " install state for user:" + nextUserId);
            }
            destroyAppDataLIF(pkg, nextUserId, 7);
            clearDefaultBrowserIfNeededForUser(ps.name, nextUserId);
            removeKeystoreDataIfNeeded(nextUserId, ps.appId);
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            clearPackagePreferredActivitiesLPw(ps.name, changedUsers, nextUserId);
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(nextUserId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(nextUserId);
                }
            }
            synchronized (this.mPackages) {
                resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId);
            }
            if ((flags & 16) != 0) {
                try {
                    MediaStore.deleteContributedMedia(this.mContext, ps.name, UserHandle.of(nextUserId));
                } catch (IOException e) {
                    Slog.w(TAG, "Failed to delete contributed media for " + ps.name, e);
                }
            }
        }
        if (outInfo != null) {
            outInfo.removedPackage = ps.name;
            outInfo.installerPackageName = ps.installerPackageName;
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                z = true;
            }
            outInfo.isStaticSharedLib = z;
            outInfo.removedAppId = ps.appId;
            outInfo.removedUsers = userIds;
            outInfo.broadcastUsers = userIds;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:21:0x002b, code lost:
        r3 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x002c, code lost:
        if (r0 != null) goto L_0x002e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x002e, code lost:
        $closeResource(r2, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0031, code lost:
        throw r3;
     */
    public void clearApplicationProfileData(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("Only the system can clear all profile data");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        PackageFreezer freezer = freezePackage(packageName, "clearApplicationProfileData");
        synchronized (this.mInstallLock) {
            clearAppProfilesLIF(pkg, -1);
        }
        if (freezer != null) {
            $closeResource(null, freezer);
        }
    }

    public void clearApplicationUserData(final String packageName, final IPackageDataObserver observer, final int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_USER_DATA", null);
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "clear application data");
        PackageSetting ps = this.mSettings.getPackageLPr(packageName);
        final boolean filterApp = ps != null && filterAppAccessLPr(ps, callingUid, userId);
        if (filterApp || !this.mProtectedPackages.isPackageDataProtected(userId, packageName)) {
            this.mHandler.post(new Runnable() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass5 */

                /* JADX WARNING: Code restructure failed: missing block: B:33:0x00ba, code lost:
                    r2 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:34:0x00bb, code lost:
                    if (r0 != null) goto L_0x00bd;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:36:?, code lost:
                    r0.close();
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:37:0x00c1, code lost:
                    r3 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:38:0x00c2, code lost:
                    r1.addSuppressed(r3);
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:39:0x00c5, code lost:
                    throw r2;
                 */
                public void run() {
                    boolean succeeded;
                    PackageManagerService.this.mHandler.removeCallbacks(this);
                    if (!filterApp) {
                        PackageFreezer freezer = PackageManagerService.this.freezePackage(packageName, "clearApplicationUserData");
                        long start = HwPackageManagerServiceUtils.hwTimingsBeginWithTag(PackageManagerService.TAG, "clearData for " + packageName);
                        synchronized (PackageManagerService.this.mInstallLock) {
                            succeeded = PackageManagerService.this.clearApplicationUserDataLIF(packageName, userId);
                        }
                        HwPackageManagerServiceUtils.hwTimingsEnd(PackageManagerService.TAG, "clearData user for " + packageName, start);
                        long start2 = SystemClock.uptimeMillis();
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mInstantAppRegistry.deleteInstantApplicationMetadataLPw(packageName, userId);
                        }
                        HwPackageManagerServiceUtils.hwTimingsEnd(PackageManagerService.TAG, "clearData metadata for " + packageName, start2);
                        if (freezer != null) {
                            freezer.close();
                        }
                        if (succeeded) {
                            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
                            if (dsm != null) {
                                dsm.checkMemory();
                            }
                            if (PackageManagerService.this.checkPermission("android.permission.SUSPEND_APPS", packageName, userId) == 0) {
                                PackageManagerService.this.unsuspendForSuspendingPackage(packageName, userId);
                            }
                        }
                    } else {
                        succeeded = false;
                    }
                    IPackageDataObserver iPackageDataObserver = observer;
                    if (iPackageDataObserver != null) {
                        try {
                            iPackageDataObserver.onRemoveCompleted(packageName, succeeded);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                }
            });
            return;
        }
        throw new SecurityException("Cannot clear data for a protected package: " + packageName);
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x004e, code lost:
        clearAppDataLIF(r2, r8, 7);
        removeKeystoreDataIfNeeded(r8, android.os.UserHandle.getAppId(r2.applicationInfo.uid));
        r1 = getUserManagerInternal();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0065, code lost:
        if (r1.isUserUnlockingOrUnlocked(r8) == false) goto L_0x0069;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0067, code lost:
        r3 = 3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x006d, code lost:
        if (r1.isUserRunning(r8) == false) goto L_0x0071;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x006f, code lost:
        r3 = 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0071, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x0072, code lost:
        prepareAppDataContentsLIF(r2, r8, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x0076, code lost:
        return true;
     */
    public boolean clearApplicationUserDataLIF(String packageName, int userId) {
        PackageSetting ps;
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null && (ps = this.mSettings.mPackages.get(packageName)) != null) {
                pkg = ps.pkg;
            }
            if (pkg == null) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            }
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
        }
    }

    @GuardedBy({"mPackages"})
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) this.mPackages.valueAt(i).mExtras, userId);
        }
    }

    private void resetNetworkPolicies(int userId) {
        ((NetworkPolicyManagerInternal) LocalServices.getService(NetworkPolicyManagerInternal.class)).resetUserState(userId);
    }

    @GuardedBy({"mPackages"})
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(final PackageSetting ps, int userId) {
        int i;
        final int i2;
        String packageName;
        boolean[] permissionRemoved;
        ArraySet<Long> revokedPermissions;
        SparseBooleanArray updatedUsers;
        int permissionCount;
        int flags;
        int i3 = userId;
        if (ps.pkg != null) {
            String packageName2 = ps.pkg.packageName;
            final boolean[] permissionRemoved2 = new boolean[1];
            final ArraySet<Long> revokedPermissions2 = new ArraySet<>();
            final SparseBooleanArray updatedUsers2 = new SparseBooleanArray();
            PermissionManagerServiceInternal.PermissionCallback delayingPermCallback = new PermissionManagerServiceInternal.PermissionCallback() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass6 */

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onGidsChanged(int appId, int userId) {
                    PackageManagerService.this.mPermissionCallback.onGidsChanged(appId, userId);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionChanged() {
                    PackageManagerService.this.mPermissionCallback.onPermissionChanged();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionGranted(int uid, int userId) {
                    PackageManagerService.this.mPermissionCallback.onPermissionGranted(uid, userId);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionGranted() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionGranted();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionRevoked(int uid, int userId) {
                    revokedPermissions2.add(Long.valueOf(IntPair.of(uid, userId)));
                    updatedUsers2.put(userId, true);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionRevoked() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionRevoked();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
                    for (int userId : updatedUserIds) {
                        if (sync) {
                            updatedUsers2.put(userId, true);
                        } else if (!updatedUsers2.get(userId)) {
                            updatedUsers2.put(userId, false);
                        }
                    }
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionRemoved() {
                    permissionRemoved2[0] = true;
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionUpdated() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionUpdated();
                }
            };
            int permissionCount2 = ps.pkg.requestedPermissions.size();
            int i4 = 0;
            while (i4 < permissionCount2) {
                final String permName = (String) ps.pkg.requestedPermissions.get(i4);
                BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                if (bp == null) {
                    permissionCount = permissionCount2;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    permissionRemoved = permissionRemoved2;
                    packageName = packageName2;
                    i2 = i3;
                    i = i4;
                } else if (bp.isRemoved()) {
                    permissionCount = permissionCount2;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    permissionRemoved = permissionRemoved2;
                    packageName = packageName2;
                    i2 = i3;
                    i = i4;
                } else {
                    if (ps.sharedUser != null) {
                        boolean used = false;
                        int packageCount = ps.sharedUser.packages.size();
                        int j = 0;
                        while (true) {
                            if (j >= packageCount) {
                                break;
                            }
                            PackageSetting pkg = ps.sharedUser.packages.valueAt(j);
                            if (pkg.pkg != null && !pkg.pkg.packageName.equals(ps.pkg.packageName) && pkg.pkg.requestedPermissions.contains(permName)) {
                                used = true;
                                break;
                            }
                            j++;
                        }
                        if (used) {
                            permissionCount = permissionCount2;
                            updatedUsers = updatedUsers2;
                            revokedPermissions = revokedPermissions2;
                            permissionRemoved = permissionRemoved2;
                            packageName = packageName2;
                            i2 = i3;
                            i = i4;
                        }
                    }
                    int oldFlags = this.mPermissionManager.getPermissionFlags(permName, packageName2, 1000, i3);
                    if (ps.pkg.applicationInfo.targetSdkVersion >= DEFERRED_NO_KILL_POST_DELETE || !bp.isRuntime()) {
                        flags = 0;
                    } else {
                        flags = 0 | 72;
                    }
                    i = i4;
                    this.mPermissionManager.updatePermissionFlags(permName, packageName2, 75, flags, 1000, userId, false, delayingPermCallback);
                    if (!bp.isRuntime()) {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                    } else if ((oldFlags & 20) != 0) {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                    } else if ((oldFlags & 32) != 0) {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                        Runnable grantRuntimePerRunnable = new Runnable(permName, packageName2, userId, delayingPermCallback) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$2MT9JZxdKuyRtxDH_uqq9fjrmik */
                            private final /* synthetic */ String f$1;
                            private final /* synthetic */ String f$2;
                            private final /* synthetic */ int f$3;
                            private final /* synthetic */ PermissionManagerServiceInternal.PermissionCallback f$4;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                                this.f$3 = r4;
                                this.f$4 = r5;
                            }

                            public final void run() {
                                PackageManagerService.this.lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$22$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
                            }
                        };
                        if (this.mFrozenPackages.contains(packageName)) {
                            this.mHandler.post(grantRuntimePerRunnable);
                        } else {
                            grantRuntimePerRunnable.run();
                        }
                        this.mHandler.post(new Runnable() {
                            /* class com.android.server.pm.PackageManagerService.AnonymousClass7 */

                            public void run() {
                                String op = AppOpsManager.permissionToOp(permName);
                                if (op != null) {
                                    int uid = UserHandle.getUid(i2, UserHandle.getAppId(ps.pkg.applicationInfo.uid));
                                    if (PackageManagerService.this.mAppOpsManager == null) {
                                        PackageManagerService packageManagerService = PackageManagerService.this;
                                        AppOpsManager unused = packageManagerService.mAppOpsManager = (AppOpsManager) packageManagerService.mContext.getSystemService(AppOpsManager.class);
                                    }
                                    try {
                                        PackageManagerService.this.mAppOpsManager.setUidMode(op, uid, 0);
                                    } catch (IllegalArgumentException e) {
                                        Log.i(PackageManagerService.TAG, "op is not in sOpStrToOp, so skip this operation");
                                    }
                                }
                            }
                        });
                    } else {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                        if ((flags & 64) == 0) {
                            this.mPermissionManager.revokeRuntimePermission(permName, packageName, false, userId, delayingPermCallback);
                        }
                    }
                }
                i4 = i + 1;
                permissionCount2 = permissionCount;
                updatedUsers2 = updatedUsers;
                revokedPermissions2 = revokedPermissions;
                permissionRemoved2 = permissionRemoved;
                packageName2 = packageName;
                i3 = i2;
            }
            if (permissionRemoved2[0]) {
                this.mPermissionCallback.onPermissionRemoved();
            }
            if (!revokedPermissions2.isEmpty()) {
                int numRevokedPermissions = revokedPermissions2.size();
                for (int i5 = 0; i5 < numRevokedPermissions; i5++) {
                    int revocationUID = IntPair.first(revokedPermissions2.valueAt(i5).longValue());
                    int revocationUserId = IntPair.second(revokedPermissions2.valueAt(i5).longValue());
                    this.mOnPermissionChangeListeners.onPermissionsChanged(revocationUID);
                    this.mHandler.post(new Runnable(revocationUID, revocationUserId) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$aAkPAkjRsEBVehb4PRgJ6d2jA18 */
                        private final /* synthetic */ int f$1;
                        private final /* synthetic */ int f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        public final void run() {
                            PackageManagerService.this.lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$23$PackageManagerService(this.f$1, this.f$2);
                        }
                    });
                }
            }
            int numUpdatedUsers = updatedUsers2.size();
            for (int i6 = 0; i6 < numUpdatedUsers; i6++) {
                this.mSettings.writeRuntimePermissionsForUserLPr(updatedUsers2.keyAt(i6), updatedUsers2.valueAt(i6));
            }
        }
    }

    public /* synthetic */ void lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$22$PackageManagerService(String permName, String packageName, int userId, PermissionManagerServiceInternal.PermissionCallback delayingPermCallback) {
        this.mPermissionManager.grantRuntimePermission(permName, packageName, false, 1000, userId, delayingPermCallback);
    }

    public /* synthetic */ void lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$23$PackageManagerService(int revocationUID, int revocationUserId) {
        killUid(UserHandle.getAppId(revocationUID), revocationUserId, KILL_APP_REASON_PERMISSIONS_REVOKED);
    }

    private static void removeKeystoreDataIfNeeded(int userId, int appId) {
        if (appId >= 0) {
            KeyStore keyStore = KeyStore.getInstance();
            if (keyStore == null) {
                Slog.w(TAG, "Could not contact keystore to clear entries for app id " + appId);
            } else if (userId == -1) {
                for (int individual : sUserManager.getUserIds()) {
                    keyStore.clearUid(UserHandle.getUid(individual, appId));
                }
            } else {
                keyStore.clearUid(UserHandle.getUid(userId, appId));
            }
        }
    }

    public void deleteApplicationCacheFiles(String packageName, IPackageDataObserver observer) {
        if (packageName == null) {
            Slog.w(TAG, "Failed to delete cache files, for packageName is null!");
        } else {
            deleteApplicationCacheFilesAsUser(packageName, UserHandle.getCallingUserId(), observer);
        }
    }

    public void deleteApplicationCacheFilesAsUser(String packageName, int userId, IPackageDataObserver observer) {
        PackageParser.Package pkg;
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES") != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES") == 0) {
                Slog.w(TAG, "Calling uid " + callingUid + " does not have " + "android.permission.INTERNAL_DELETE_CACHE_FILES" + ", silently ignoring");
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES", null);
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "delete application cache files");
        int hasAccessInstantApps = this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        this.mHandler.post(new Runnable(pkg, callingUid, hasAccessInstantApps, userId, packageName, observer) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$qoqxPWm4S8q7gBAXdm5xGFhLdUk */
            private final /* synthetic */ PackageParser.Package f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ int f$4;
            private final /* synthetic */ String f$5;
            private final /* synthetic */ IPackageDataObserver f$6;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
                this.f$6 = r7;
            }

            public final void run() {
                PackageManagerService.this.lambda$deleteApplicationCacheFilesAsUser$24$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6);
            }
        });
    }

    public /* synthetic */ void lambda$deleteApplicationCacheFilesAsUser$24$PackageManagerService(PackageParser.Package pkg, int callingUid, int hasAccessInstantApps, int userId, String packageName, IPackageDataObserver observer) {
        PackageSetting ps = pkg == null ? null : (PackageSetting) pkg.mExtras;
        boolean doClearData = true;
        if (ps != null) {
            doClearData = !ps.getInstantApp(UserHandle.getUserId(callingUid)) || hasAccessInstantApps == 0;
        }
        if (doClearData) {
            synchronized (this.mInstallLock) {
                clearAppDataLIF(pkg, userId, DEFERRED_NO_KILL_POST_DELETE);
                clearAppDataLIF(pkg, userId, 39);
            }
            this.mContext.sendBroadcastAsUser(new Intent("com.huawei.intent.action.PACKAGE_CACHE_CLEARED", Uri.fromParts("package", packageName, null)).addFlags(DumpState.DUMP_SERVICE_PERMISSIONS).putExtra("android.intent.extra.PACKAGE_NAME", packageName).putExtra("android.intent.extra.UID", (pkg == null || pkg.applicationInfo == null) ? -1 : pkg.applicationInfo.uid), UserHandle.of(userId));
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted(packageName, true);
            } catch (RemoteException e) {
                Log.i(TAG, "Observer no longer exists.");
            }
        }
    }

    public void getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer) {
        throw new UnsupportedOperationException("Shame on you for calling the hidden API getPackageSizeInfo(). Shame!");
    }

    /* JADX WARNING: Code restructure failed: missing block: B:11:?, code lost:
        r12.mInstaller.getAppSize(r1.volumeUuid, new java.lang.String[]{r13}, r14, 0, r1.appId, new long[]{r1.getCeDataInode(r14)}, new java.lang.String[]{r1.codePathString}, r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x004c, code lost:
        if (isSystemApp(r1) == false) goto L_0x0063;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x0052, code lost:
        if (isUpdatedSystemApp(r1) != false) goto L_0x0063;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:16:0x005d, code lost:
        if ((r1.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_APEX) != 0) goto L_0x0063;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x005f, code lost:
        r15.codeSize = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0063, code lost:
        r15.dataSize -= r15.cacheSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x006b, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x006c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:21:0x006d, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, java.lang.String.valueOf(r0));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x0076, code lost:
        return false;
     */
    @GuardedBy({"mInstallLock"})
    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Slog.w(TAG, "Failed to find settings for " + packageName);
                return false;
            }
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public int getUidTargetSdkVersionLockedLPr(int uid) {
        int v;
        Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
        if (obj instanceof SharedUserSetting) {
            int vers = 10000;
            Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.pkg != null && (v = ps.pkg.applicationInfo.targetSdkVersion) < vers) {
                    vers = v;
                }
            }
            return vers;
        } else if (!(obj instanceof PackageSetting)) {
            return 10000;
        } else {
            PackageSetting ps2 = (PackageSetting) obj;
            if (ps2.pkg != null) {
                return ps2.pkg.applicationInfo.targetSdkVersion;
            }
            return 10000;
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public int getPackageTargetSdkVersionLockedLPr(String packageName) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            return p.applicationInfo.targetSdkVersion;
        }
        return 10000;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_ADDPREFERREDACTIVITY);
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Adding preferred");
    }

    private void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
        int callingUid = Binder.getCallingUid();
        if (activity != null) {
            Slog.d(TAG, opname + "add pref activity " + activity.flattenToShortString() + " from uid " + Binder.getCallingUid());
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "add preferred activity");
        if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        }
        if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else if (activity == null) {
            Slog.w(TAG, "Cannot set a preferred activity with activity is null");
        } else {
            if (filter.hasCategory("android.intent.category.HOME")) {
                if (!isAlreadyDefaultHomeActivity(activity, userId) && !mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
                    Slog.i(TAG, "NOT ALLOWED TO add preferred activity current time!");
                    return;
                } else if (HwDeviceManager.disallowOp(17)) {
                    Slog.i(TAG, "NOT ALLOWED add preferred activity when mdm already set default home");
                    return;
                }
            }
            if (DEBUG_PREFERRED) {
                Slog.i(TAG, opname + " activity " + activity.flattenToShortString() + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
            }
            boolean isMultiScreenEnabled = mHwPMSEx.isMultiScreenCollaborationEnabled(null);
            synchronized (this.mPackages) {
                if (isMultiScreenEnabled) {
                    mHwPMSEx.putPreferredActivityInPcMode(userId, filter, new PreferredActivity(filter, match, set, activity, always));
                }
                if (!"com.huawei.pcassistant".equals(activity.getPackageName())) {
                    this.mSettings.editPreferredActivitiesLPw(userId).addFilter(new PreferredActivity(filter, match, set, activity, always));
                }
                scheduleWritePackageRestrictionsLocked(userId);
            }
            if (!updateDefaultHomeNotLocked(userId)) {
                postPreferredActivityChangedBroadcast(userId);
            }
        }
    }

    private void postPreferredActivityChangedBroadcast(int userId) {
        this.mHandler.post(new Runnable(userId) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$0PosSKX4veyXp7ssRoqePJ6fuo */
            private final /* synthetic */ int f$0;

            {
                this.f$0 = r1;
            }

            public final void run() {
                PackageManagerService.lambda$postPreferredActivityChangedBroadcast$25(this.f$0);
            }
        });
    }

    static /* synthetic */ void lambda$postPreferredActivityChangedBroadcast$25(int userId) {
        IActivityManager am = ActivityManager.getService();
        if (am != null) {
            Intent intent = new Intent("android.intent.action.ACTION_PREFERRED_ACTIVITY_CHANGED");
            intent.putExtra("android.intent.extra.user_handle", userId);
            intent.addFlags(DumpState.DUMP_HANDLE);
            try {
                am.broadcastIntent((IApplicationThread) null, intent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, (String[]) null, -1, (Bundle) null, false, false, userId);
            } catch (RemoteException e) {
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:30:0x00b1, code lost:
        r15.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
     */
    public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        if (filter.countActions() == 1) {
            if (filter.countDataAuthorities() == 0) {
                if (filter.countDataPaths() == 0) {
                    if (filter.countDataSchemes() <= 1) {
                        if (filter.countDataTypes() == 0) {
                            if (!filter.hasCategory("android.intent.category.HOME") || activity == null || isAlreadyDefaultHomeActivity(activity, userId) || mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
                                int callingUid = Binder.getCallingUid();
                                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "replace preferred activity");
                                if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                                    synchronized (this.mPackages) {
                                        if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                                            Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                                            return;
                                        }
                                    }
                                }
                                synchronized (this.mPackages) {
                                    try {
                                        PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
                                        if (pir != null) {
                                            ArrayList<PreferredActivity> existing = pir.findFilters(filter);
                                            if (existing != null && existing.size() == 1) {
                                                PreferredActivity cur = existing.get(0);
                                                if (DEBUG_PREFERRED) {
                                                    Slog.i(TAG, "Checking replace of preferred:");
                                                    filter.dump(new LogPrinter(4, TAG), "  ");
                                                    if (!cur.mPref.mAlways) {
                                                        Slog.i(TAG, "  -- CUR; not mAlways!");
                                                    } else {
                                                        Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                                                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                                                        Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                                                        Slog.i(TAG, "  -- NEW: mMatch=" + (match & 268369920));
                                                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                                                        Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                                                    }
                                                }
                                                if (cur.mPref.mAlways && cur.mPref.mComponent.equals(activity) && cur.mPref.mMatch == (match & 268369920)) {
                                                    try {
                                                        if (cur.mPref.sameSet(set)) {
                                                            if (DEBUG_PREFERRED) {
                                                                Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + userId + ":");
                                                                filter.dump(new LogPrinter(4, TAG), "  ");
                                                            }
                                                            return;
                                                        }
                                                    } catch (Throwable th) {
                                                        th = th;
                                                        throw th;
                                                    }
                                                }
                                            }
                                            if (existing != null) {
                                                if (DEBUG_PREFERRED) {
                                                    Slog.i(TAG, existing.size() + " existing preferred matches for:");
                                                    filter.dump(new LogPrinter(4, TAG), "  ");
                                                }
                                                for (int i = existing.size() - 1; i >= 0; i--) {
                                                    PreferredActivity pa = existing.get(i);
                                                    if (DEBUG_PREFERRED) {
                                                        Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                                                        pa.dump(new LogPrinter(4, TAG), "  ");
                                                    }
                                                    pir.removeFilter(pa);
                                                }
                                            }
                                        }
                                        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Replacing preferred");
                                        return;
                                    } catch (Throwable th2) {
                                        th = th2;
                                        throw th;
                                    }
                                }
                            } else {
                                Slog.i(TAG, "NOT ALLOWED TO replace preferred activity current time!");
                                throw new IllegalArgumentException("Component " + activity + " not allowed to be default home on user " + userId);
                            }
                        }
                    }
                }
            }
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, paths, or types; and at most one scheme.");
        }
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
    }

    private boolean isAlreadyDefaultHomeActivity(ComponentName activity, int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "Default home provider has not been set");
            return false;
        }
        String currentPackageName = provider.getDefaultHome(userId);
        Slog.i(TAG, "currentPackageName: " + currentPackageName + ", packageName: " + activity.getPackageName());
        if (!TextUtils.equals(currentPackageName, activity.getPackageName())) {
            return false;
        }
        Slog.i(TAG, "packageName: " + currentPackageName + " is already default home");
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:25:0x006e, code lost:
        r2 = android.os.UserHandle.getCallingUserId();
        r1 = new android.util.SparseBooleanArray();
        r4 = r6.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x007a, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:?, code lost:
        clearPackagePreferredActivitiesLPw(r7, r1, r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x007e, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0083, code lost:
        if (r1.size() <= 0) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x0085, code lost:
        updateDefaultHomeNotLocked(r1);
        postPreferredActivityChangedBroadcast(r2);
        r1 = r6.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:0x008d, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:?, code lost:
        scheduleWritePackageRestrictionsLocked(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x0091, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:?, code lost:
        return;
     */
    public void clearPackagePreferredActivities(String packageName) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_CLEARPACKAGEPREFERREDACTIVITIES);
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                if ((this.mPackages.get(packageName) == null || !isCallerSameApp(packageName, callingUid)) && this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                        Slog.w(TAG, "Ignoring clearPackagePreferredActivities() from uid " + callingUid);
                        return;
                    }
                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                }
                PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                if (ps != null && filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void clearPackagePreferredActivitiesLPw(String packageName, SparseBooleanArray outUserChanged, int userId) {
        Slog.d(TAG, "clear pref activity " + packageName + " outUserChanged " + outUserChanged + " for user " + userId + "from uid " + Binder.getCallingUid());
        ArrayList<PreferredActivity> removed = null;
        for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
            int thisUserId = this.mSettings.mPreferredActivities.keyAt(i);
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i);
            if (userId == -1 || userId == thisUserId) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (removed == null) {
                            removed = new ArrayList<>();
                        }
                        removed.add(pa);
                    }
                }
                if (removed != null) {
                    for (int j = 0; j < removed.size(); j++) {
                        pir.removeFilter(removed.get(j));
                    }
                    outUserChanged.put(thisUserId, true);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void clearIntentFilterVerificationsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            clearIntentFilterVerificationsLPw(this.mPackages.valueAt(i).packageName, userId);
        }
    }

    /* access modifiers changed from: package-private */
    @GuardedBy({"mPackages"})
    public void clearIntentFilterVerificationsLPw(String packageName, int userId) {
        if (userId == -1) {
            if (this.mSettings.removeIntentFilterVerificationLPw(packageName, sUserManager.getUserIds())) {
                for (int oneUserId : sUserManager.getUserIds()) {
                    scheduleWritePackageRestrictionsLocked(oneUserId);
                }
            }
        } else if (this.mSettings.removeIntentFilterVerificationLPw(packageName, userId)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void clearDefaultBrowserIfNeeded(String packageName) {
        for (int oneUserId : sUserManager.getUserIds()) {
            clearDefaultBrowserIfNeededForUser(packageName, oneUserId);
        }
    }

    private void clearDefaultBrowserIfNeededForUser(String packageName, int userId) {
        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
        if (!TextUtils.isEmpty(defaultBrowserPackageName) && packageName.equals(defaultBrowserPackageName)) {
            setDefaultBrowserPackageName(null, userId);
        }
    }

    public void resetApplicationPreferences(int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        long identity = Binder.clearCallingIdentity();
        try {
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            clearPackagePreferredActivitiesLPw(null, changedUsers, userId);
            synchronized (this.mPackages) {
                this.mSettings.applyDefaultPreferredAppsLPw(userId);
                clearIntentFilterVerificationsLPw(userId);
                primeDomainVerificationsLPw(userId);
                resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
            }
            if (changedUsers.size() > 0) {
                postPreferredActivityChangedBroadcast(userId);
            }
            updateDefaultHomeNotLocked(userId);
            setDefaultBrowserPackageName(null, userId);
            resetNetworkPolicies(userId);
            synchronized (this.mPackages) {
                scheduleWritePackageRestrictionsLocked(userId);
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return 0;
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this.mPackages) {
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
            if (pir != null) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (outFilters != null) {
                            outFilters.add(new IntentFilter(pa));
                        }
                        if (outActivities != null) {
                            outActivities.add(pa.mPref.mComponent);
                        }
                    }
                }
            }
        }
        return 0;
    }

    public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
        } else if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else if (!filter.hasCategory("android.intent.category.HOME") || activity == null || isAlreadyDefaultHomeActivity(activity, userId) || mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
            if (DEBUG_PREFERRED) {
                Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
            }
            synchronized (this.mPackages) {
                this.mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
                scheduleWritePackageRestrictionsLocked(userId);
            }
            updateDefaultHomeNotLocked(userId);
            postPreferredActivityChangedBroadcast(userId);
        } else {
            Slog.i(TAG, "NOT ALLOWED TO add persistent preferred activity current time!");
        }
    }

    public void clearPackagePersistentPreferredActivities(String packageName, int userId) {
        if (Binder.getCallingUid() == 1000) {
            ArrayList<PersistentPreferredActivity> removed = null;
            boolean changed = false;
            synchronized (this.mPackages) {
                Slog.i(TAG, "clearPackagePersistentPreferredActivities with  " + packageName + " for user " + userId);
                for (int i = 0; i < this.mSettings.mPersistentPreferredActivities.size(); i++) {
                    int thisUserId = this.mSettings.mPersistentPreferredActivities.keyAt(i);
                    PersistentPreferredIntentResolver ppir = this.mSettings.mPersistentPreferredActivities.valueAt(i);
                    if (userId == thisUserId) {
                        Iterator<PersistentPreferredActivity> it = ppir.filterIterator();
                        while (it.hasNext()) {
                            PersistentPreferredActivity ppa = it.next();
                            if (ppa.mComponent.getPackageName().equals(packageName)) {
                                if (removed == null) {
                                    removed = new ArrayList<>();
                                }
                                removed.add(ppa);
                            }
                        }
                        if (removed != null) {
                            for (int j = 0; j < removed.size(); j++) {
                                ppir.removeFilter(removed.get(j));
                            }
                            changed = true;
                        }
                    }
                }
            }
            if (changed) {
                updateDefaultHomeNotLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(userId);
                }
                return;
            }
            return;
        }
        throw new SecurityException("clearPackagePersistentPreferredActivities can only be run by the system");
    }

    private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
        int type;
        do {
            type = parser.next();
            if (type == 2) {
                break;
            }
        } while (type != 1);
        if (type != 2) {
            if (DEBUG_BACKUP) {
                Slog.e(TAG, "Didn't find start tag during restore");
            }
        } else if (expectedStartTag.equals(parser.getName())) {
            do {
            } while (parser.next() == 4);
            functor.apply(parser, userId);
        } else if (DEBUG_BACKUP) {
            Slog.e(TAG, "Found unexpected tag " + parser.getName());
        }
    }

    public byte[] getPreferredActivityBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_PREFERRED_BACKUP);
                synchronized (this.mPackages) {
                    this.mSettings.writePreferredActivitiesLPr(serializer, userId, true);
                }
                serializer.endTag(null, TAG_PREFERRED_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write preferred activities for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getPreferredActivityBackup()");
        }
    }

    public void restorePreferredActivities(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PREFERRED_BACKUP, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$owzvespYnSG3k53wFgqA8dIrzCI */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restorePreferredActivities$26$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public /* synthetic */ void lambda$restorePreferredActivities$26$PackageManagerService(XmlPullParser readParser, int readUserId) throws IOException, XmlPullParserException {
        synchronized (this.mPackages) {
            this.mSettings.readPreferredActivitiesLPw(readParser, readUserId);
        }
        updateDefaultHomeNotLocked(readUserId);
    }

    public byte[] getDefaultAppsBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_DEFAULT_APPS);
                synchronized (this.mPackages) {
                    this.mSettings.writeDefaultAppsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_DEFAULT_APPS);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getDefaultAppsBackup()");
        }
    }

    public void restoreDefaultApps(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_DEFAULT_APPS, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$lzioMNzZkED1ivRsBfeRkwJEBW4 */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restoreDefaultApps$27$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring default apps: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restoreDefaultApps()");
        }
    }

    public /* synthetic */ void lambda$restoreDefaultApps$27$PackageManagerService(XmlPullParser parser1, int userId1) throws IOException, XmlPullParserException {
        String defaultBrowser;
        PackageManagerInternal.DefaultBrowserProvider provider;
        synchronized (this.mPackages) {
            this.mSettings.readDefaultAppsLPw(parser1, userId1);
            defaultBrowser = this.mSettings.removeDefaultBrowserPackageNameLPw(userId1);
        }
        if (defaultBrowser != null) {
            synchronized (this.mPackages) {
                provider = this.mDefaultBrowserProvider;
            }
            provider.setDefaultBrowser(defaultBrowser, userId1);
        }
    }

    public byte[] getIntentFilterVerificationBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_INTENT_FILTER_VERIFICATION);
                synchronized (this.mPackages) {
                    this.mSettings.writeAllDomainVerificationsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_INTENT_FILTER_VERIFICATION);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getIntentFilterVerificationBackup()");
        }
    }

    public void restoreIntentFilterVerification(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_INTENT_FILTER_VERIFICATION, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$wnVrM2Mr6uaXSge5Ff00wRy0JE */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restoreIntentFilterVerification$28$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public /* synthetic */ void lambda$restoreIntentFilterVerification$28$PackageManagerService(XmlPullParser parser1, int userId1) throws IOException, XmlPullParserException {
        synchronized (this.mPackages) {
            this.mSettings.readAllDomainVerificationsLPr(parser1, userId1);
            this.mSettings.writeLPr();
        }
    }

    public void addCrossProfileIntentFilter(IntentFilter intentFilter, String ownerPackage, int sourceUserId, int targetUserId, int flags) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a crossProfile intent filter with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            CrossProfileIntentFilter newFilter = new CrossProfileIntentFilter(intentFilter, ownerPackage, targetUserId, flags);
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            ArrayList<CrossProfileIntentFilter> existing = resolver.findFilters(intentFilter);
            if (existing != null) {
                int size = existing.size();
                int i = 0;
                while (i < size) {
                    if (!newFilter.equalsIgnoreFilter(existing.get(i))) {
                        i++;
                    } else {
                        return;
                    }
                }
            }
            resolver.addFilter(newFilter);
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    public void clearCrossProfileIntentFilters(int sourceUserId, String ownerPackage) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        synchronized (this.mPackages) {
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            Iterator<CrossProfileIntentFilter> it = new ArraySet<>(resolver.filterSet()).iterator();
            while (it.hasNext()) {
                CrossProfileIntentFilter filter = it.next();
                if (filter.getOwnerPackage().equals(ownerPackage)) {
                    resolver.removeFilter(filter);
                }
            }
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    private void enforceOwnerRights(String pkg, int callingUid) {
        if (UserHandle.getAppId(callingUid) != 1000) {
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageInfo pi = getPackageInfo(pkg, 0, callingUserId);
            if (pi == null) {
                throw new IllegalArgumentException("Unknown package " + pkg + " on user " + callingUserId);
            } else if (!UserHandle.isSameApp(pi.applicationInfo.uid, callingUid)) {
                throw new SecurityException("Calling uid " + callingUid + " does not own package " + pkg);
            }
        }
    }

    public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
    }

    public void sendSessionUpdatedBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        if (!TextUtils.isEmpty(sessionInfo.installerPackageName)) {
            this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_UPDATED").putExtra("android.content.pm.extra.SESSION", sessionInfo).setPackage(sessionInfo.installerPackageName), UserHandle.of(userId));
        }
    }

    public void sendSessionCommitBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        UserManagerService ums = UserManagerService.getInstance();
        if (ums != null) {
            UserInfo parent = ums.getProfileParent(userId);
            int launcherUid = parent != null ? parent.id : userId;
            ComponentName launcherComponent = getDefaultHomeActivity(launcherUid);
            if (launcherComponent != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(launcherComponent.getPackageName()), UserHandle.of(launcherUid));
            }
            if (this.mAppPredictionServicePackage != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(this.mAppPredictionServicePackage), UserHandle.of(launcherUid));
            }
        }
    }

    /* access modifiers changed from: private */
    public ComponentName getDefaultHomeActivity(int userId) {
        List<ResolveInfo> allHomeCandidates = new ArrayList<>();
        ComponentName cn = getHomeActivitiesAsUser(allHomeCandidates, userId);
        if (cn != null) {
            return cn;
        }
        int lastPriority = Integer.MIN_VALUE;
        ComponentName lastComponent = null;
        int size = allHomeCandidates.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo ri = allHomeCandidates.get(i);
            if (ri.priority > lastPriority) {
                lastComponent = ri.activityInfo.getComponentName();
                lastPriority = ri.priority;
            } else if (ri.priority == lastPriority) {
                lastComponent = null;
            }
        }
        return lastComponent;
    }

    private Intent getHomeIntent() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        intent.addCategory("android.intent.category.DEFAULT");
        return intent;
    }

    private IntentFilter getHomeFilter() {
        IntentFilter filter = new IntentFilter("android.intent.action.MAIN");
        filter.addCategory("android.intent.category.HOME");
        filter.addCategory("android.intent.category.DEFAULT");
        return filter;
    }

    /* access modifiers changed from: package-private */
    public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        ComponentName componentName;
        List<ResolveInfo> resolveInfos = queryIntentActivitiesInternal(getHomeIntent(), null, 128, userId);
        allHomeCandidates.clear();
        if (resolveInfos == null) {
            return null;
        }
        allHomeCandidates.addAll(resolveInfos);
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "mDefaultHomeProvider is null");
            return null;
        }
        String packageName = provider.getDefaultHome(userId);
        if (packageName == null) {
            return null;
        }
        if (HwDeviceManager.disallowOp(17) && (componentName = mHwPMSEx.getMdmDefaultLauncher(resolveInfos)) != null) {
            return componentName;
        }
        int resolveInfosSize = resolveInfos.size();
        for (int i = 0; i < resolveInfosSize; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            if (resolveInfo.activityInfo != null && TextUtils.equals(resolveInfo.activityInfo.packageName, packageName)) {
                return new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);
            }
        }
        return null;
    }

    private void updateDefaultHomeNotLocked(SparseBooleanArray userIds) {
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        for (int i = userIds.size() - 1; i >= 0; i--) {
            updateDefaultHomeNotLocked(userIds.keyAt(i));
        }
    }

    private boolean updateDefaultHomeNotLocked(int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        if (!this.mSystemReady) {
            return false;
        }
        Intent intent = getHomeIntent();
        String packageName = null;
        ResolveInfo preferredResolveInfo = findPreferredActivityNotLocked(intent, null, 0, queryIntentActivitiesInternal(intent, null, 786560, userId), 0, true, false, false, userId);
        if (!(preferredResolveInfo == null || preferredResolveInfo.activityInfo == null)) {
            packageName = preferredResolveInfo.activityInfo.packageName;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "Default home provider has not been set");
            return false;
        } else if (TextUtils.equals(provider.getDefaultHome(userId), packageName)) {
            return false;
        } else {
            String[] callingPackages = getPackagesForUid(Binder.getCallingUid());
            if (callingPackages != null && ArrayUtils.contains(callingPackages, this.mRequiredPermissionControllerPackage)) {
                return false;
            }
            provider.setDefaultHomeAsync(packageName, userId, new Consumer(userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$lHrGVlaTNwBrDeozHhhp2pppkk */
                private final /* synthetic */ int f$1;

                {
                    this.f$1 = r2;
                }

                @Override // java.util.function.Consumer
                public final void accept(Object obj) {
                    PackageManagerService.this.lambda$updateDefaultHomeNotLocked$29$PackageManagerService(this.f$1, (Boolean) obj);
                }
            });
            return true;
        }
    }

    public /* synthetic */ void lambda$updateDefaultHomeNotLocked$29$PackageManagerService(int userId, Boolean successful) {
        if (successful.booleanValue()) {
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    public void setHomeActivity(ComponentName comp, int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ArrayList<ResolveInfo> homeActivities = new ArrayList<>();
            getHomeActivitiesAsUser(homeActivities, userId);
            boolean found = false;
            int size = homeActivities.size();
            ComponentName[] set = new ComponentName[size];
            for (int i = 0; i < size; i++) {
                ActivityInfo info = homeActivities.get(i).activityInfo;
                ComponentName activityName = new ComponentName(info.packageName, info.name);
                set[i] = activityName;
                if (!found && activityName.equals(comp)) {
                    found = true;
                }
            }
            if (found) {
                replacePreferredActivity(getHomeFilter(), 1048576, set, comp, userId);
                return;
            }
            throw new IllegalArgumentException("Component " + comp + " cannot be home on user " + userId);
        }
    }

    private String getSetupWizardPackageName() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.SETUP_WIZARD");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one setup wizard; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getStorageManagerPackageName() {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.os.storage.action.MANAGE_STORAGE"), null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one storage manager; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    public String getSystemTextClassifierPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039831));
    }

    public String getAttentionServicePackageName() {
        ComponentName componentName;
        String flattenedComponentName = this.mContext.getString(17039817);
        if (flattenedComponentName == null || (componentName = ComponentName.unflattenFromString(flattenedComponentName)) == null || componentName.getPackageName() == null) {
            return null;
        }
        return ensureSystemPackageName(componentName.getPackageName());
    }

    private String getDocumenterPackageName() {
        Intent intent = new Intent("android.intent.action.OPEN_DOCUMENT");
        intent.addCategory("android.intent.category.OPENABLE");
        intent.setType("*/*");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one documenter; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getDeviceConfiguratorPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039835));
    }

    public String getWellbeingPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039833));
    }

    public String getAppPredictionServicePackageName() {
        ComponentName appPredictionServiceComponentName;
        String flattenedAppPredictionServiceComponentName = this.mContext.getString(17039815);
        if (flattenedAppPredictionServiceComponentName == null || (appPredictionServiceComponentName = ComponentName.unflattenFromString(flattenedAppPredictionServiceComponentName)) == null) {
            return null;
        }
        return ensureSystemPackageName(appPredictionServiceComponentName.getPackageName());
    }

    public String getSystemCaptionsServicePackageName() {
        ComponentName systemCaptionsServiceComponentName;
        String flattenedSystemCaptionsServiceComponentName = this.mContext.getString(17039830);
        if (!TextUtils.isEmpty(flattenedSystemCaptionsServiceComponentName) && (systemCaptionsServiceComponentName = ComponentName.unflattenFromString(flattenedSystemCaptionsServiceComponentName)) != null) {
            return ensureSystemPackageName(systemCaptionsServiceComponentName.getPackageName());
        }
        return null;
    }

    public String getIncidentReportApproverPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039863));
    }

    private String ensureSystemPackageName(String packageName) {
        if (packageName == null) {
            return null;
        }
        long token = Binder.clearCallingIdentity();
        try {
            if (getPackageInfo(packageName, 2097152, 0) == null) {
                PackageInfo packageInfo = getPackageInfo(packageName, 0, 0);
                if (packageInfo != null) {
                    EventLog.writeEvent(1397638484, "145981139", Integer.valueOf(packageInfo.applicationInfo.uid), "");
                }
                return null;
            }
            Binder.restoreCallingIdentity(token);
            return packageName;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_SETAPPLICATIONENABLEDSETTING);
        if (sUserManager.exists(userId)) {
            if (callingPackage == null) {
                callingPackage = Integer.toString(Binder.getCallingUid());
            }
            Log.v(TAG, "Setting application enabled setting: appPackageName=" + appPackageName + " newState=" + newState + " flags=" + flags + " userId=" + userId + " callingPackage=" + callingPackage);
            setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);
        }
    }

    public void setUpdateAvailable(String packageName, boolean updateAvailable) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                pkgSetting.setUpdateAvailable(updateAvailable);
            }
        }
    }

    public void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_SETCOMPONENTENABLEDSETTING, new Object[]{Integer.valueOf(newState)});
        if (sUserManager.exists(userId) && componentName != null) {
            setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);
        }
    }

    /* JADX INFO: finally extract failed */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x026c, code lost:
        if (android.content.pm.PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME.equals(r25) == false) goto L_0x0279;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x026e, code lost:
        if (r7 == false) goto L_0x0271;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0278, code lost:
        throw new java.lang.SecurityException("Cannot disable a system-generated component");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x0279, code lost:
        r8 = r23.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x027b, code lost:
        monitor-enter(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x027c, code lost:
        if (r11 != 2000) goto L_0x02c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x0282, code lost:
        if ((r15.pkgFlags & 256) != 0) goto L_0x02c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0284, code lost:
        r0 = r15.getEnabled(r28);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0288, code lost:
        if (r25 != null) goto L_0x0299;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x028a, code lost:
        if (r0 == 3) goto L_0x0291;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x028c, code lost:
        if (r0 == 0) goto L_0x0291;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x028f, code lost:
        if (r0 != 1) goto L_0x0299;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x0291, code lost:
        if (r26 == 3) goto L_0x0298;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x0293, code lost:
        if (r26 == 0) goto L_0x0298;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x0296, code lost:
        if (r26 != 1) goto L_0x0299;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x02bf, code lost:
        throw new java.lang.SecurityException("Shell cannot change component state for " + r24 + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r25 + " to " + r26);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x02c0, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:?, code lost:
        monitor-exit(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x02c6, code lost:
        if (r25 != null) goto L_0x030c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x02c8, code lost:
        r6 = r23.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x02ca, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x02cf, code lost:
        if (r15.getEnabled(r28) != r26) goto L_0x02d3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x02d1, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x02d2, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x02d3, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x02d4, code lost:
        r8 = r15.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x02d8, code lost:
        if (r8.isStub == false) goto L_0x02e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x02de, code lost:
        if (r8.isSystem() == false) goto L_0x02e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x02e0, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x02e2, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x02e4, code lost:
        if (r0 == false) goto L_0x02f2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x02e6, code lost:
        if (r26 == 0) goto L_0x02eb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x02e9, code lost:
        if (r26 != 1) goto L_0x02f2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x02ef, code lost:
        if (enableCompressedPackage(r8) != false) goto L_0x02f2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x02f1, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x02f2, code lost:
        if (r26 == 0) goto L_0x02fb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02f5, code lost:
        if (r26 != 1) goto L_0x02f8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x02f8, code lost:
        r14 = r29;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x02fb, code lost:
        r14 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x02fd, code lost:
        r6 = r23.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x02ff, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:?, code lost:
        r15.setEnabled(r26, r28, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x0303, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x030c, code lost:
        r6 = r23.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x030e, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:?, code lost:
        r0 = r15.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x0311, code lost:
        if (r0 == null) goto L_0x031f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x0317, code lost:
        if (r0.hasComponentClassName(r25) != false) goto L_0x0367;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x031a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x031f, code lost:
        if (r0 == null) goto L_0x0349;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x0327, code lost:
        if (r0.applicationInfo.targetSdkVersion >= 16) goto L_0x032a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x0348, code lost:
        throw new java.lang.IllegalArgumentException("Component class " + r25 + " does not exist in " + r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x0349, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Failed setComponentEnabledSetting: component class " + r25 + " does not exist in " + r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x0367, code lost:
        if (r26 == 0) goto L_0x0397;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x036a, code lost:
        if (r26 == 1) goto L_0x038f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x036d, code lost:
        if (r26 == 2) goto L_0x0387;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x036f, code lost:
        android.util.Slog.e(com.android.server.pm.PackageManagerService.TAG, "Invalid new component state: " + r26);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x0385, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x0386, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x038b, code lost:
        if (r15.disableComponentLPw(r25, r28) != false) goto L_0x039f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x038d, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x038e, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x0393, code lost:
        if (r15.enableComponentLPw(r25, r28) != false) goto L_0x039f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:200:0x0395, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x0396, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x039b, code lost:
        if (r15.restoreComponentLPw(r25, r28) != false) goto L_0x039f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x039d, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:205:0x039e, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x039f, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:208:0x03a2, code lost:
        r8 = r23.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:209:0x03a4, code lost:
        monitor-enter(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:211:?, code lost:
        scheduleWritePackageRestrictionsLocked(r28);
        updateSequenceNumberLP(r15, new int[]{r28});
        r17 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:213:?, code lost:
        updateInstantAppInstallerLocked(r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x03b8, code lost:
        android.os.Binder.restoreCallingIdentity(r17);
        r6 = r23.mPendingBroadcasts.get(r28, r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:215:0x03c2, code lost:
        if (r6 != null) goto L_0x03c6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x03c4, code lost:
        r9 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:217:0x03c6, code lost:
        r9 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:218:0x03c7, code lost:
        if (r9 == false) goto L_0x03d6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:221:0x03ce, code lost:
        r6 = new java.util.ArrayList<>();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:222:0x03d1, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:225:0x03da, code lost:
        if (r6.contains(r11) != false) goto L_0x03df;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:226:0x03dc, code lost:
        r6.add(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:228:0x03e1, code lost:
        if ((r27 & 1) != 0) goto L_0x03ee;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:229:0x03e3, code lost:
        r19 = true;
        r23.mPendingBroadcasts.remove(r28, r24);
        r7 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:230:0x03ee, code lost:
        if (r9 == false) goto L_0x03f5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:231:0x03f0, code lost:
        r23.mPendingBroadcasts.put(r28, r24, r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:233:0x03fc, code lost:
        if (r23.mHandler.hasMessages(1) != false) goto L_0x0417;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:235:0x0406, code lost:
        if (android.os.SystemClock.uptimeMillis() <= r23.mServiceStartWithDelay) goto L_0x040b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:236:0x0408, code lost:
        r3 = 1000;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:237:0x040b, code lost:
        r3 = com.android.server.job.controllers.JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:238:0x040d, code lost:
        r7 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:240:?, code lost:
        r23.mHandler.sendEmptyMessageDelayed(1, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:241:0x0417, code lost:
        r7 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:242:0x041a, code lost:
        monitor-exit(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:243:0x041b, code lost:
        r3 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:244:0x041f, code lost:
        if (r19 == false) goto L_0x0436;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:246:?, code lost:
        r0 = android.os.UserHandle.getUid(r28, r15.appId);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:247:0x0429, code lost:
        if ((r27 & 1) == 0) goto L_0x042c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:249:0x042c, code lost:
        r7 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x00cb, code lost:
        if (com.android.server.notification.NotificationShellCmd.NOTIFICATION_PACKAGE.equals(r29) != false) goto L_0x00d0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:250:0x042d, code lost:
        sendPackageChangedBroadcast(r24, r7, r6, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:251:0x0431, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:252:0x0432, code lost:
        android.os.Binder.restoreCallingIdentity(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:253:0x0435, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:254:0x0436, code lost:
        android.os.Binder.restoreCallingIdentity(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:255:0x043a, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:256:0x043b, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:257:0x043c, code lost:
        android.os.Binder.restoreCallingIdentity(r17);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:258:0x0442, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:259:0x0443, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:261:0x0446, code lost:
        monitor-exit(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:262:0x0447, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:263:0x0448, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:264:0x044a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:267:?, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:268:0x044e, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:269:0x044f, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:270:0x0451, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:273:?, code lost:
        monitor-exit(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:274:0x0455, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:275:0x0456, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x01e8, code lost:
        if (android.os.UserHandle.isSameApp(r11, r15.appId) != false) goto L_0x0266;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x01ea, code lost:
        if (r7 == false) goto L_0x0213;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x01f0, code lost:
        if (filterAppAccessLPr(r15, r11, r28) == false) goto L_0x01f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01f9, code lost:
        if (r23.mProtectedPackages.isPackageStateProtected(r28, r24) != false) goto L_0x01fc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x0212, code lost:
        throw new java.lang.SecurityException("Cannot disable a protected package: " + r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x0213, code lost:
        r6 = new java.lang.StringBuilder();
        r6.append("Attempt to change component state; pid=");
        r6.append(android.os.Binder.getCallingPid());
        r6.append(", uid=");
        r6.append(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x022e, code lost:
        if (r25 != null) goto L_0x0242;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x0230, code lost:
        r8 = ", package=" + r24;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x0242, code lost:
        r8 = ", component=" + r24 + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r25;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x025b, code lost:
        r6.append(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x0265, code lost:
        throw new java.lang.SecurityException(r6.toString());
     */
    private void setEnabledSetting(String packageName, String className, int newState, int flags, int userId, String callingPackage) {
        int permission;
        String str;
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx;
        if ((newState == 2 || newState == 3 || newState == 4) && (iHwPackageManagerServiceEx = mHwPMSEx) != null && iHwPackageManagerServiceEx.isNeedForbidShellFunc(packageName)) {
            Slog.i(TAG, "disablePackage NeedForbidShellFunc, " + packageName + " won't be disabled");
        } else if (newState == 0 || newState == 1 || newState == 2 || newState == 3 || newState == 4) {
            Flog.i(206, "setEnabledSetting pkg:" + packageName + ", className:" + className + ", newState:" + newState + ", flags:" + flags + ", userId:" + userId + ", CallingPid:" + Binder.getCallingPid() + ", CallingUid:" + Binder.getCallingUid());
            int callingUid = Binder.getCallingUid();
            if ("com.huawei.systemmanager".equals(packageName) && HwPackageManagerServiceUtils.isDisableStatus(newState)) {
                if (callingUid != 2000) {
                }
                Slog.i(TAG, "not allowed to disable systemmanager in adb shell");
                return;
            }
            if (callingUid == 1000) {
                permission = 0;
            } else {
                permission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE");
            }
            this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "set enabled");
            boolean allowedByPermission = permission == 0;
            boolean isApp = className == null;
            boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
            String componentName = isApp ? packageName : className;
            synchronized (this.mPackages) {
                try {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting != null) {
                        boolean sendNow = false;
                        try {
                        } catch (Throwable th) {
                            th = th;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } else if (isCallerInstantApp) {
                        try {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Attempt to change component state; pid=");
                            sb.append(Binder.getCallingPid());
                            sb.append(", uid=");
                            sb.append(callingUid);
                            if (className == null) {
                                StringBuilder sb2 = new StringBuilder();
                                try {
                                    sb2.append(", package=");
                                    sb2.append(packageName);
                                    str = sb2.toString();
                                } catch (Throwable th2) {
                                    th = th2;
                                    while (true) {
                                        break;
                                    }
                                    throw th;
                                }
                            } else {
                                str = ", component=" + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className;
                            }
                            sb.append(str);
                            throw new SecurityException(sb.toString());
                        } catch (Throwable th3) {
                            th = th3;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } else if (className == null) {
                        try {
                            StringBuilder sb3 = new StringBuilder();
                            sb3.append("Unknown package: ");
                            sb3.append(packageName);
                            throw new IllegalArgumentException(sb3.toString());
                        } catch (Throwable th4) {
                            th = th4;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } else {
                        throw new IllegalArgumentException("Unknown component: " + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className);
                    }
                } catch (Throwable th5) {
                    th = th5;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        } else {
            throw new IllegalArgumentException("Invalid new component state: " + newState);
        }
    }

    public void flushPackageRestrictionsAsUser(int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && sUserManager.exists(userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "flushPackageRestrictions");
            synchronized (this.mPackages) {
                this.mSettings.writePackageRestrictionsLPr(userId);
                this.mDirtyUsers.remove(Integer.valueOf(userId));
                if (this.mDirtyUsers.isEmpty()) {
                    this.mHandler.removeMessages(14);
                }
            }
        }
    }

    /* access modifiers changed from: protected */
    public void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
        }
        Bundle extras = new Bundle(4);
        extras.putString("android.intent.extra.changed_component_name", componentNames.get(0));
        String[] nameList = new String[componentNames.size()];
        componentNames.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        int flags = !componentNames.contains(packageName) ? 1073741824 : 0;
        int userId = UserHandle.getUserId(packageUid);
        boolean isInstantApp = isInstantApp(packageName, userId);
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", packageName, extras, flags, null, null, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
        if (sUserManager.exists(userId)) {
            int callingUid = Binder.getCallingUid();
            if (getInstantAppPackageName(callingUid) == null) {
                boolean allowedByPermission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE") == 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "stop package");
                synchronized (this.mPackages) {
                    try {
                        try {
                            if (!filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, userId)) {
                                if (this.mSettings.setPackageStoppedStateLPw(this, packageName, stopped, allowedByPermission, callingUid, userId)) {
                                    scheduleWritePackageRestrictionsLocked(userId);
                                }
                            }
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
            }
        }
    }

    public String getInstallerPackageName(String packageName) {
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                return null;
            }
            if (ps == null && this.mApexManager.isApexPackage(packageName)) {
                return null;
            }
            return this.mSettings.getInstallerPackageNameLPr(packageName);
        }
    }

    public boolean isOrphaned(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mPackages.containsKey(packageName)) {
                return false;
            }
            return this.mSettings.isOrphaned(packageName);
        }
    }

    public int getApplicationEnabledSetting(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get enabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(packageName), callingUid, userId)) {
                return 2;
            }
            return this.mSettings.getApplicationEnabledSettingLPr(packageName, userId);
        }
    }

    public int getComponentEnabledSetting(ComponentName component, int userId) {
        if (component == null) {
            return 0;
        }
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getComponentEnabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(component.getPackageName()), callingUid, component, 0, userId)) {
                return 2;
            }
            return this.mSettings.getComponentEnabledSettingLPr(component, userId);
        }
    }

    public void enterSafeMode() {
        enforceSystemOrRoot("Only the system can request entering safe mode");
        if (!this.mSystemReady) {
            this.mSafeMode = true;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:44:0x0160, code lost:
        com.android.server.pm.PackageManagerService.sUserManager.systemReady();
        android.hwtheme.HwThemeManager.applyDefaultHwTheme(true, r16.mContext, 0);
        r0 = r11.length;
        r6 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x016e, code lost:
        if (r6 >= r0) goto L_0x017a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x0170, code lost:
        r16.mDefaultPermissionPolicy.grantDefaultPermissions(r11[r6]);
        r6 = r6 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x017a, code lost:
        if (r5 == false) goto L_0x0186;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x017c, code lost:
        com.android.server.pm.Settings.resetPackageSettingsError();
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "booting after package manager settings file broken, systemReady now!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0188, code lost:
        if (r11 != com.android.server.pm.PackageManagerService.EMPTY_INT_ARRAY) goto L_0x018f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x018a, code lost:
        r16.mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x018f, code lost:
        r0 = com.android.server.pm.UserManagerService.getInstance().getUserIds();
        r6 = r0.length;
        r7 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x0199, code lost:
        if (r7 >= r6) goto L_0x01a5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x019b, code lost:
        r16.mDefaultPermissionPolicy.grantCustDefaultPermissions(r0[r7]);
        r7 = r7 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x01a5, code lost:
        r6 = r16.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x01a7, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:?, code lost:
        r16.mPermissionManager.updateAllPermissions(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, false, r16.mPackages.values(), r16.mPermissionCallback);
        ((com.android.server.policy.PermissionPolicyInternal) com.android.server.LocalServices.getService(com.android.server.policy.PermissionPolicyInternal.class)).setOnInitializedCallback(new com.android.server.pm.$$Lambda$PackageManagerService$7hPE7B8Ek5O5gGvlRSe3ejwgKE(r16));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x01c8, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x01c9, code lost:
        ((android.os.storage.StorageManager) r16.mContext.getSystemService(android.os.storage.StorageManager.class)).registerListener(r16.mStorageListener);
        r16.mInstallerService.systemReady();
        r16.mApexManager.systemReady();
        r16.mPackageDexOptimizer.systemReady();
        com.android.server.pm.PackageManagerService.mHwPMSEx.systemReady();
        getStorageManagerInternal().addExternalStoragePolicy(new com.android.server.pm.PackageManagerService.AnonymousClass9(r16));
        com.android.server.pm.PackageManagerService.sUserManager.reconcileUsers(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
        reconcileApps(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
        r16.mPermissionManager.systemReady();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x020b, code lost:
        if (r16.mInstantAppResolverConnection == null) goto L_0x021e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x020d, code lost:
        r16.mContext.registerReceiver(new com.android.server.pm.PackageManagerService.AnonymousClass10(r16), new android.content.IntentFilter("android.intent.action.BOOT_COMPLETED"));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x021e, code lost:
        r16.mModuleInfoProvider.systemReady();
        r16.mInstallerService.restoreAndApplyStagedSessionIfNeeded();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0228, code lost:
        return;
     */
    public void systemReady() {
        enforceSystemOrRoot("Only the system can claim the system is ready");
        this.mSystemReady = true;
        final ContentResolver resolver = this.mContext.getContentResolver();
        ContentObserver co = new ContentObserver(this.mHandler) {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass8 */

            public void onChange(boolean selfChange) {
                boolean ephemeralFeatureDisabled = Settings.Global.getInt(resolver, "enable_ephemeral_feature", 1) == 0;
                int[] userIds = UserManagerService.getInstance().getUserIds();
                for (int userId : userIds) {
                    PackageManagerService.this.mWebInstantAppsDisabled.put(userId, ephemeralFeatureDisabled || Settings.Secure.getIntForUser(resolver, "instant_apps_enabled", 1, userId) == 0);
                }
            }
        };
        boolean z = false;
        this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("enable_ephemeral_feature"), false, co, -1);
        this.mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor("instant_apps_enabled"), false, co, -1);
        co.onChange(true);
        CarrierAppUtils.disableCarrierAppsUntilPrivileged(this.mContext.getOpPackageName(), this, this.mContext.getContentResolver(), 0);
        disableSkuSpecificApps();
        boolean compatibilityModeEnabled = Settings.Global.getInt(this.mContext.getContentResolver(), "compatibility_mode", 1) == 1;
        PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
        if (DEBUG_SETTINGS) {
            Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
        }
        boolean isPackageSettingsError = this.mSettings.isPackageSettingsError();
        int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
        synchronized (this.mPackages) {
            try {
                ArrayList<PreferredActivity> removed = new ArrayList<>();
                for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i);
                    removed.clear();
                    for (PreferredActivity pa : pir.filterSet()) {
                        if (!this.mComponentResolver.isActivityDefined(pa.mPref.mComponent)) {
                            removed.add(pa);
                        }
                    }
                    if (removed.size() > 0) {
                        for (int r = 0; r < removed.size(); r++) {
                            PreferredActivity pa2 = removed.get(r);
                            Slog.w(TAG, "Removing dangling preferred activity: " + pa2.mPref.mComponent);
                            pir.removeFilter(pa2);
                        }
                        this.mSettings.writePackageRestrictionsLPr(this.mSettings.mPreferredActivities.keyAt(i));
                    }
                }
                int[] userIds = UserManagerService.getInstance().getUserIds();
                int length = userIds.length;
                int[] grantPermissionsUserIds2 = grantPermissionsUserIds;
                int i2 = 0;
                while (i2 < length) {
                    try {
                        int userId = userIds[i2];
                        boolean isNeedDefaultGrant = !this.mSettings.areDefaultRuntimePermissionsGrantedLPr(userId) ? true : z;
                        Slog.i(TAG, "TO DO, pms system ready grant default permission for user " + userId + ",default grant:" + isNeedDefaultGrant + ", catch settings error:" + isPackageSettingsError);
                        if (isPackageSettingsError || isNeedDefaultGrant || isUpgrade()) {
                            grantPermissionsUserIds2 = ArrayUtils.appendInt(grantPermissionsUserIds2, userId);
                        }
                        i2++;
                        z = false;
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                }
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    public /* synthetic */ void lambda$systemReady$30$PackageManagerService(int userId) {
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
        }
    }

    public void waitForAppDataPrepared() {
        Future<?> future = this.mPrepareAppDataFuture;
        if (future != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(future, "wait for prepareAppData");
            this.mPrepareAppDataFuture = null;
        }
    }

    public boolean isSafeMode() {
        return this.mSafeMode;
    }

    public boolean hasSystemUidErrors() {
        return this.mHasSystemUidErrors;
    }

    static String arrayToString(int[] array) {
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder.append('[');
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                if (i > 0) {
                    stringBuilder.append(", ");
                }
                stringBuilder.append(array[i]);
            }
        }
        stringBuilder.append(']');
        return stringBuilder.toString();
    }

    /* JADX DEBUG: Multi-variable search result rejected for r8v0, resolved type: com.android.server.pm.PackageManagerService */
    /* JADX WARN: Multi-variable type inference failed */
    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new PackageManagerShellCommand(this).exec(this, in, out, err, args, callback, resultReceiver);
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:510:0x0c34 */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r6v5 */
    /* JADX WARN: Type inference failed for: r5v26 */
    /* JADX WARN: Type inference failed for: r5v27, types: [int] */
    /* JADX WARN: Type inference failed for: r5v34 */
    /* JADX WARN: Type inference failed for: r5v35, types: [int] */
    /* JADX WARN: Type inference failed for: r2v53, types: [com.android.server.pm.Settings] */
    /* JADX WARN: Type inference failed for: r2v55, types: [com.android.server.pm.Settings] */
    /* JADX WARN: Type inference failed for: r6v32 */
    /* JADX WARN: Type inference failed for: r2v68, types: [com.android.server.pm.Settings] */
    /* JADX WARN: Type inference failed for: r4v34, types: [com.android.internal.util.FastXmlSerializer, org.xmlpull.v1.XmlSerializer] */
    /* JADX WARN: Type inference failed for: r6v57, types: [java.lang.Boolean] */
    /* JADX WARN: Type inference failed for: r5v82, types: [com.android.server.pm.Settings] */
    /* JADX WARN: Type inference failed for: r6v83 */
    /* JADX WARN: Type inference failed for: r6v84 */
    /* JADX WARN: Type inference failed for: r6v85 */
    /* JADX WARN: Type inference failed for: r6v86 */
    /* JADX WARN: Type inference failed for: r6v87 */
    /* JADX WARN: Type inference failed for: r6v88 */
    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:422:0x09be  */
    /* JADX WARNING: Removed duplicated region for block: B:459:0x0a71  */
    /* JADX WARNING: Removed duplicated region for block: B:507:0x0c2e  */
    /* JADX WARNING: Removed duplicated region for block: B:509:0x0c32  */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0c7b A[SYNTHETIC, Splitter:B:534:0x0c7b] */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0c9a  */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0ca8  */
    /* JADX WARNING: Removed duplicated region for block: B:551:0x0cbd  */
    /* JADX WARNING: Removed duplicated region for block: B:566:0x0d49  */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0dae A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:592:0x0dcb A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:593:0x0dd1 A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:609:0x0e33 A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:612:0x0e41 A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0e7a A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:622:0x0e82 A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:629:0x0ea7 A[Catch:{ all -> 0x0f79 }] */
    /* JADX WARNING: Removed duplicated region for block: B:642:0x0ef0  */
    /* JADX WARNING: Removed duplicated region for block: B:654:0x0f20  */
    /* JADX WARNING: Unknown variable types count: 6 */
    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        String packageName;
        boolean fullPreferred;
        ArraySet<String> permissionNames;
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        boolean fullPreferred2;
        ArraySet<String> permissionNames2;
        char c;
        boolean fullPreferred3;
        ArraySet<String> permissionNames3;
        char c2;
        String packageName2;
        boolean z;
        String packageName3;
        String str;
        String packageName4;
        ArraySet<String> permissionNames4;
        boolean z2;
        ArraySet<String> permissionNames5;
        String packageName5;
        String packageName6;
        int i;
        Collection<PackageSetting> allPackageSettings;
        Iterator<PackageSetting> it;
        String prefix;
        IllegalArgumentException e;
        IllegalStateException e2;
        IOException e3;
        String str2;
        ArrayMap<String, PackageParser.Package> arrayMap3;
        int versionCount;
        boolean fullPreferred4;
        ArraySet<String> permissionNames6;
        boolean fullPreferred5;
        int i2;
        int user;
        String opt;
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, pw)) {
            int callingPid = Binder.getCallingPid();
            int ppid = Process.getParentPid(callingPid);
            int callingUid = Binder.getCallingUid();
            Log.i(TAG, "Start dump, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
            DumpState dumpState = new DumpState();
            int opti = 0;
            boolean checkin = false;
            while (opti < args.length && (opt = args[opti]) != null && opt.length() > 0 && opt.charAt(0) == '-') {
                opti++;
                if (!"-a".equals(opt)) {
                    if ("-h".equals(opt)) {
                        pw.println("Package manager dump options:");
                        pw.println("  [-h] [-f] [--checkin] [--all-components] [cmd] ...");
                        pw.println("    --checkin: dump for a checkin");
                        pw.println("    -f: print details of intent filters");
                        pw.println("    -h: print this help");
                        pw.println("    --all-components: include all component names in package dump");
                        pw.println("  cmd may be one of:");
                        pw.println("    apex: list active APEXes and APEX session state");
                        pw.println("    l[ibraries]: list known shared libraries");
                        pw.println("    f[eatures]: list device features");
                        pw.println("    k[eysets]: print known keysets");
                        pw.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
                        pw.println("    perm[issions]: dump permissions");
                        pw.println("    permission [name ...]: dump declaration and use of given permission");
                        pw.println("    pref[erred]: print preferred package settings");
                        pw.println("    preferred-xml [--full]: print preferred package settings as xml");
                        pw.println("    prov[iders]: dump content providers");
                        pw.println("    p[ackages]: dump installed packages");
                        pw.println("    s[hared-users]: dump shared user IDs");
                        pw.println("    m[essages]: print collected runtime messages");
                        pw.println("    h[andle]: dump message list");
                        pw.println("    v[erifiers]: print package verifier info");
                        pw.println("    d[omain-preferred-apps]: print domains preferred apps");
                        pw.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
                        pw.println("    version: print database version info");
                        pw.println("    write: write current settings now");
                        pw.println("    maple: print disabled maple apps");
                        pw.println("    installs: details about install sessions");
                        pw.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
                        pw.println("    dexopt: dump dexopt state");
                        pw.println("    compiler-stats: dump compiler statistics");
                        pw.println("    service-permissions: dump permissions required by services");
                        pw.println("    <package.name>: info about given package");
                        return;
                    } else if ("--checkin".equals(opt)) {
                        checkin = true;
                    } else if ("--all-components".equals(opt)) {
                        dumpState.setOptionEnabled(2);
                    } else if ("-f".equals(opt)) {
                        dumpState.setOptionEnabled(1);
                    } else if (PriorityDump.PROTO_ARG.equals(opt)) {
                        dumpProto(fd);
                        return;
                    } else {
                        pw.println("Unknown argument: " + opt + "; use -h for help");
                    }
                }
            }
            if (opti < args.length) {
                String cmd = args[opti];
                int opti2 = opti + 1;
                if (PLATFORM_PACKAGE_NAME.equals(cmd)) {
                    fullPreferred5 = false;
                    permissionNames6 = null;
                    i2 = 1;
                } else if (cmd.contains(".")) {
                    fullPreferred5 = false;
                    permissionNames6 = null;
                    i2 = 1;
                } else if (!"check-permission".equals(cmd)) {
                    if (!"l".equals(cmd)) {
                        if (!"libraries".equals(cmd)) {
                            if (!"f".equals(cmd)) {
                                if (!"features".equals(cmd)) {
                                    if (!"r".equals(cmd)) {
                                        if (!"resolvers".equals(cmd)) {
                                            if (!TAG_PERMISSION.equals(cmd)) {
                                                if (!"permissions".equals(cmd)) {
                                                    if (!"permission".equals(cmd)) {
                                                        if (!"pref".equals(cmd)) {
                                                            if (!"preferred".equals(cmd)) {
                                                                if ("preferred-xml".equals(cmd)) {
                                                                    dumpState.setDump(8192);
                                                                    if (opti2 < args.length && "--full".equals(args[opti2])) {
                                                                        int opti3 = opti2 + 1;
                                                                        fullPreferred = true;
                                                                        packageName = null;
                                                                        permissionNames = null;
                                                                    }
                                                                } else {
                                                                    if (!"d".equals(cmd)) {
                                                                        if (!"domain-preferred-apps".equals(cmd)) {
                                                                            if (!"p".equals(cmd)) {
                                                                                if (!"packages".equals(cmd)) {
                                                                                    if (!"s".equals(cmd)) {
                                                                                        if (!"shared-users".equals(cmd)) {
                                                                                            if (!"prov".equals(cmd)) {
                                                                                                if (!"providers".equals(cmd)) {
                                                                                                    if ("m".equals(cmd) || "messages".equals(cmd)) {
                                                                                                        dumpState.setDump(512);
                                                                                                    } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
                                                                                                        dumpState.setDump(2048);
                                                                                                    } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
                                                                                                        dumpState.setDump(131072);
                                                                                                    } else if ("version".equals(cmd)) {
                                                                                                        dumpState.setDump(32768);
                                                                                                    } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
                                                                                                        dumpState.setDump(16384);
                                                                                                    } else if ("installs".equals(cmd)) {
                                                                                                        dumpState.setDump(65536);
                                                                                                    } else if ("frozen".equals(cmd)) {
                                                                                                        dumpState.setDump(524288);
                                                                                                    } else if ("volumes".equals(cmd)) {
                                                                                                        dumpState.setDump(8388608);
                                                                                                    } else if ("dexopt".equals(cmd)) {
                                                                                                        dumpState.setDump(1048576);
                                                                                                    } else if ("compiler-stats".equals(cmd)) {
                                                                                                        dumpState.setDump(2097152);
                                                                                                    } else if ("changes".equals(cmd)) {
                                                                                                        dumpState.setDump(4194304);
                                                                                                    } else if ("service-permissions".equals(cmd)) {
                                                                                                        dumpState.setDump(DumpState.DUMP_SERVICE_PERMISSIONS);
                                                                                                    } else if ("h".equals(cmd) || "handle".equals(cmd)) {
                                                                                                        dumpState.setDump(DumpState.DUMP_HANDLE);
                                                                                                    } else if ("write".equals(cmd)) {
                                                                                                        synchronized (this.mPackages) {
                                                                                                            this.mSettings.writeLPr();
                                                                                                            pw.println("Settings written.");
                                                                                                        }
                                                                                                        return;
                                                                                                    } else if ("maple".equals(cmd)) {
                                                                                                        if (ZygoteInit.sIsMygote) {
                                                                                                            HwMaplePMServiceUtils.dumpDisabledMaplePkgs(pw);
                                                                                                            return;
                                                                                                        } else {
                                                                                                            pw.println("The system not run in maple.");
                                                                                                            return;
                                                                                                        }
                                                                                                    } else if (DEBUG_INSTALL) {
                                                                                                        Slog.d(TAG, "cmd not equals anything.");
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            dumpState.setDump(1024);
                                                                                        }
                                                                                    }
                                                                                    dumpState.setDump(256);
                                                                                    if (opti2 < args.length && "noperm".equals(args[opti2])) {
                                                                                        dumpState.setOptionEnabled(4);
                                                                                    }
                                                                                }
                                                                            }
                                                                            dumpState.setDump(128);
                                                                        }
                                                                    }
                                                                    dumpState.setDump(262144);
                                                                }
                                                                fullPreferred = false;
                                                                packageName = null;
                                                                permissionNames = null;
                                                            }
                                                        }
                                                        dumpState.setDump(4096);
                                                        fullPreferred = false;
                                                        packageName = null;
                                                        permissionNames = null;
                                                    } else if (opti2 >= args.length) {
                                                        pw.println("Error: permission requires permission name");
                                                        return;
                                                    } else {
                                                        ArraySet<String> permissionNames7 = new ArraySet<>();
                                                        while (opti2 < args.length) {
                                                            permissionNames7.add(args[opti2]);
                                                            opti2++;
                                                        }
                                                        dumpState.setDump(448);
                                                        permissionNames = permissionNames7;
                                                        fullPreferred = false;
                                                        packageName = null;
                                                    }
                                                }
                                            }
                                            dumpState.setDump(64);
                                            fullPreferred = false;
                                            packageName = null;
                                            permissionNames = null;
                                        }
                                    }
                                    if (opti2 >= args.length) {
                                        dumpState.setDump(60);
                                        fullPreferred = false;
                                        packageName = null;
                                        permissionNames = null;
                                    } else {
                                        while (opti2 < args.length) {
                                            String name = args[opti2];
                                            if ("a".equals(name) || "activity".equals(name)) {
                                                dumpState.setDump(4);
                                            } else if ("s".equals(name) || "service".equals(name)) {
                                                dumpState.setDump(8);
                                            } else if ("r".equals(name) || HwBroadcastRadarUtil.KEY_RECEIVER.equals(name)) {
                                                dumpState.setDump(16);
                                            } else if ("c".equals(name) || "content".equals(name)) {
                                                dumpState.setDump(32);
                                            } else {
                                                pw.println("Error: unknown resolver table type: " + name);
                                                return;
                                            }
                                            opti2++;
                                        }
                                        fullPreferred = false;
                                        packageName = null;
                                        permissionNames = null;
                                    }
                                }
                            }
                            dumpState.setDump(2);
                            fullPreferred = false;
                            packageName = null;
                            permissionNames = null;
                        }
                    }
                    dumpState.setDump(1);
                    fullPreferred = false;
                    packageName = null;
                    permissionNames = null;
                } else if (opti2 >= args.length) {
                    pw.println("Error: check-permission missing permission argument");
                    return;
                } else {
                    String perm = args[opti2];
                    int opti4 = opti2 + 1;
                    if (opti4 >= args.length) {
                        pw.println("Error: check-permission missing package argument");
                        return;
                    }
                    String pkg = args[opti4];
                    int opti5 = opti4 + 1;
                    int user2 = UserHandle.getUserId(Binder.getCallingUid());
                    if (opti5 < args.length) {
                        try {
                            user = Integer.parseInt(args[opti5]);
                        } catch (NumberFormatException e4) {
                            pw.println("Error: check-permission user argument is not a number: " + args[opti5]);
                            return;
                        }
                    } else {
                        user = user2;
                    }
                    pw.println(checkPermission(perm, resolveInternalPackageNameLPr(pkg, -1), user));
                    return;
                }
                dumpState.setOptionEnabled(i2);
                permissionNames = permissionNames6;
                packageName = cmd;
                fullPreferred = fullPreferred5;
            } else {
                fullPreferred = false;
                packageName = null;
                permissionNames = null;
            }
            if (checkin) {
                pw.println("vers,1");
            }
            Log.i(TAG, "Start dump with packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
            ArrayMap<String, PackageParser.Package> arrayMap4 = this.mPackages;
            synchronized (arrayMap4) {
                try {
                    if (dumpState.isDumping(32768) && packageName == null && !checkin) {
                        try {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Database versions:");
                            this.mSettings.dumpVersionLPr(new IndentingPrintWriter(pw, "  "));
                        } catch (Throwable th2) {
                            th = th2;
                            arrayMap = arrayMap4;
                            throw th;
                        }
                    }
                    if (dumpState.isDumping(2048) && packageName == null) {
                        if (!checkin) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Verifiers:");
                            pw.print("  Required: ");
                            pw.print(this.mRequiredVerifierPackage);
                            pw.print(" (uid=");
                            pw.print(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                            pw.println(")");
                        } else if (this.mRequiredVerifierPackage != null) {
                            pw.print("vrfy,");
                            pw.print(this.mRequiredVerifierPackage);
                            pw.print(",");
                            pw.println(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                        }
                    }
                    if (dumpState.isDumping(131072) && packageName == null) {
                        if (this.mIntentFilterVerifierComponent != null) {
                            String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                            if (!checkin) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                pw.println("Intent Filter Verifier:");
                                pw.print("  Using: ");
                                pw.print(verifierPackageName);
                                pw.print(" (uid=");
                                pw.print(getPackageUid(verifierPackageName, 268435456, 0));
                                pw.println(")");
                            } else if (verifierPackageName != null) {
                                pw.print("ifv,");
                                pw.print(verifierPackageName);
                                pw.print(",");
                                pw.println(getPackageUid(verifierPackageName, 268435456, 0));
                            }
                        } else {
                            pw.println();
                            pw.println("No Intent Filter Verifier available!");
                        }
                    }
                    if (!dumpState.isDumping(1) || packageName != null) {
                        permissionNames2 = permissionNames;
                        fullPreferred2 = fullPreferred;
                        arrayMap2 = arrayMap4;
                    } else {
                        boolean printedHeader = false;
                        try {
                            for (String libName : this.mSharedLibraries.keySet()) {
                                boolean printedHeader2 = printedHeader;
                                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(libName);
                                if (versionedLib == null) {
                                    printedHeader = printedHeader2;
                                } else {
                                    int versionCount2 = versionedLib.size();
                                    int i3 = 0;
                                    while (i3 < versionCount2) {
                                        try {
                                            SharedLibraryInfo libraryInfo = versionedLib.valueAt(i3);
                                            if (!checkin) {
                                                if (!printedHeader2) {
                                                    try {
                                                        if (dumpState.onTitlePrinted()) {
                                                            pw.println();
                                                        }
                                                        versionCount = versionCount2;
                                                        pw.println("Libraries:");
                                                        printedHeader2 = true;
                                                    } catch (Throwable th3) {
                                                        th = th3;
                                                        arrayMap = arrayMap4;
                                                        throw th;
                                                    }
                                                } else {
                                                    versionCount = versionCount2;
                                                }
                                                pw.print("  ");
                                            } else {
                                                versionCount = versionCount2;
                                                pw.print("lib,");
                                            }
                                            pw.print(libraryInfo.getName());
                                            if (libraryInfo.isStatic()) {
                                                StringBuilder sb = new StringBuilder();
                                                fullPreferred4 = fullPreferred;
                                                try {
                                                    sb.append(" version=");
                                                    arrayMap3 = arrayMap4;
                                                    sb.append(libraryInfo.getLongVersion());
                                                    pw.print(sb.toString());
                                                } catch (Throwable th4) {
                                                    th = th4;
                                                    arrayMap = arrayMap3;
                                                    throw th;
                                                }
                                            } else {
                                                fullPreferred4 = fullPreferred;
                                                arrayMap3 = arrayMap4;
                                            }
                                            if (!checkin) {
                                                pw.print(" -> ");
                                            }
                                            if (libraryInfo.getPath() != null) {
                                                pw.print(" (jar) ");
                                                pw.print(libraryInfo.getPath());
                                            } else {
                                                pw.print(" (apk) ");
                                                pw.print(libraryInfo.getPackageName());
                                            }
                                            pw.println();
                                            i3++;
                                            permissionNames = permissionNames;
                                            versionCount2 = versionCount;
                                            fullPreferred = fullPreferred4;
                                            arrayMap4 = arrayMap3;
                                        } catch (Throwable th5) {
                                            th = th5;
                                            arrayMap = arrayMap4;
                                            throw th;
                                        }
                                    }
                                    arrayMap3 = arrayMap4;
                                    permissionNames = permissionNames;
                                    printedHeader = printedHeader2;
                                }
                            }
                            permissionNames2 = permissionNames;
                            fullPreferred2 = fullPreferred;
                            arrayMap2 = arrayMap4;
                        } catch (Throwable th6) {
                            th = th6;
                            arrayMap = arrayMap4;
                            throw th;
                        }
                    }
                    try {
                        if (dumpState.isDumping(2) && packageName == null) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            if (!checkin) {
                                pw.println("Features:");
                            }
                            synchronized (this.mAvailableFeatures) {
                                for (FeatureInfo feat : this.mAvailableFeatures.values()) {
                                    if (checkin) {
                                        pw.print("feat,");
                                        pw.print(feat.name);
                                        pw.print(",");
                                        pw.println(feat.version);
                                    } else {
                                        pw.print("  ");
                                        pw.print(feat.name);
                                        if (feat.version > 0) {
                                            pw.print(" version=");
                                            pw.print(feat.version);
                                        }
                                        pw.println();
                                    }
                                }
                            }
                        }
                        if (!checkin && dumpState.isDumping(4)) {
                            this.mComponentResolver.dumpActivityResolvers(pw, dumpState, packageName);
                        }
                        if (!checkin && dumpState.isDumping(16)) {
                            this.mComponentResolver.dumpReceiverResolvers(pw, dumpState, packageName);
                        }
                        if (!checkin && dumpState.isDumping(8)) {
                            this.mComponentResolver.dumpServiceResolvers(pw, dumpState, packageName);
                        }
                        if (!checkin) {
                            c = ' ';
                            c = ' ';
                            if (dumpState.isDumping(32)) {
                                this.mComponentResolver.dumpProviderResolvers(pw, dumpState, packageName);
                            }
                        } else {
                            c = ' ';
                        }
                        if (!checkin) {
                            try {
                                if (dumpState.isDumping(4096)) {
                                    int i4 = 0;
                                    String packageName7 = packageName;
                                    while (i4 < this.mSettings.mPreferredActivities.size()) {
                                        PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i4);
                                        int user3 = this.mSettings.mPreferredActivities.keyAt(i4);
                                        if (dumpState.getTitlePrinted()) {
                                            str2 = "\nPreferred Activities User " + user3 + ":";
                                        } else {
                                            str2 = "Preferred Activities User " + user3 + ":";
                                        }
                                        arrayMap = arrayMap2;
                                        try {
                                            if (pir.dump(pw, str2, "  ", packageName7, true, false)) {
                                                dumpState.setTitlePrinted(true);
                                            }
                                            i4++;
                                            packageName7 = packageName7;
                                            c = ' ';
                                            arrayMap2 = arrayMap;
                                            permissionNames2 = permissionNames2;
                                            fullPreferred2 = fullPreferred2;
                                        } catch (Throwable th7) {
                                            th = th7;
                                            throw th;
                                        }
                                    }
                                    packageName2 = packageName7;
                                    c2 = c;
                                    permissionNames3 = permissionNames2;
                                    fullPreferred3 = fullPreferred2;
                                    arrayMap = arrayMap2;
                                    z = true;
                                    packageName3 = packageName7;
                                    if (!checkin) {
                                        try {
                                            if (dumpState.isDumping(8192)) {
                                                pw.flush();
                                                try {
                                                    BufferedOutputStream str3 = new BufferedOutputStream(new FileOutputStream(fd));
                                                    ?? fastXmlSerializer = new FastXmlSerializer();
                                                    try {
                                                        fastXmlSerializer.setOutput(str3, StandardCharsets.UTF_8.name());
                                                        ?? valueOf = Boolean.valueOf(z);
                                                        fastXmlSerializer.startDocument(null, valueOf);
                                                        fastXmlSerializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", z);
                                                        try {
                                                            this.mSettings.writePreferredActivitiesLPr(fastXmlSerializer, 0, fullPreferred3);
                                                            fastXmlSerializer.endDocument();
                                                            fastXmlSerializer.flush();
                                                            str = valueOf;
                                                        } catch (IllegalArgumentException e5) {
                                                            e = e5;
                                                        } catch (IllegalStateException e6) {
                                                            e2 = e6;
                                                            String str4 = "Failed writing: " + e2;
                                                            pw.println(str4);
                                                            str = str4;
                                                            if (checkin) {
                                                            }
                                                            if (!checkin) {
                                                            }
                                                            permissionNames4 = permissionNames3;
                                                            this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                            this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                            if (dumpState.isDumping(128)) {
                                                            }
                                                            if (dumpState.isDumping(256)) {
                                                            }
                                                            if (dumpState.isDumping(4194304)) {
                                                            }
                                                            if (!checkin) {
                                                            }
                                                            packageName6 = packageName5;
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ", 120);
                                                            ipw.println();
                                                            ipw.println("Loaded volumes:");
                                                            ipw.increaseIndent();
                                                            if (this.mLoadedVolumes.size() == 0) {
                                                            }
                                                            ipw.decreaseIndent();
                                                            this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                            Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                            }
                                                            Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            dumpCompilerStatsLPr(pw, packageName6);
                                                            if (!checkin) {
                                                            }
                                                            PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                            Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                            this.mApexManager.dump(pw, packageName6);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                            Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        } catch (IOException e7) {
                                                            e3 = e7;
                                                            String str5 = "Failed writing: " + e3;
                                                            pw.println(str5);
                                                            str = str5;
                                                            if (checkin) {
                                                            }
                                                            if (!checkin) {
                                                            }
                                                            permissionNames4 = permissionNames3;
                                                            this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                            this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                            if (dumpState.isDumping(128)) {
                                                            }
                                                            if (dumpState.isDumping(256)) {
                                                            }
                                                            if (dumpState.isDumping(4194304)) {
                                                            }
                                                            if (!checkin) {
                                                            }
                                                            packageName6 = packageName5;
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            IndentingPrintWriter ipw2 = new IndentingPrintWriter(pw, "  ", 120);
                                                            ipw2.println();
                                                            ipw2.println("Loaded volumes:");
                                                            ipw2.increaseIndent();
                                                            if (this.mLoadedVolumes.size() == 0) {
                                                            }
                                                            ipw2.decreaseIndent();
                                                            this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                            Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                            }
                                                            Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            dumpCompilerStatsLPr(pw, packageName6);
                                                            if (!checkin) {
                                                            }
                                                            PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                            Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                            this.mApexManager.dump(pw, packageName6);
                                                            if (dumpState.onTitlePrinted()) {
                                                            }
                                                            this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                            Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        }
                                                    } catch (IllegalArgumentException e8) {
                                                        e = e8;
                                                        String str6 = "Failed writing: " + e;
                                                        pw.println(str6);
                                                        str = str6;
                                                        if (checkin) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames4 = permissionNames3;
                                                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(4194304)) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        packageName6 = packageName5;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw22 = new IndentingPrintWriter(pw, "  ", 120);
                                                        ipw22.println();
                                                        ipw22.println("Loaded volumes:");
                                                        ipw22.increaseIndent();
                                                        if (this.mLoadedVolumes.size() == 0) {
                                                        }
                                                        ipw22.decreaseIndent();
                                                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                        }
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(pw, packageName6);
                                                        if (!checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                        this.mApexManager.dump(pw, packageName6);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    } catch (IllegalStateException e9) {
                                                        e2 = e9;
                                                        String str42 = "Failed writing: " + e2;
                                                        pw.println(str42);
                                                        str = str42;
                                                        if (checkin) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames4 = permissionNames3;
                                                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(4194304)) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        packageName6 = packageName5;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw222 = new IndentingPrintWriter(pw, "  ", 120);
                                                        ipw222.println();
                                                        ipw222.println("Loaded volumes:");
                                                        ipw222.increaseIndent();
                                                        if (this.mLoadedVolumes.size() == 0) {
                                                        }
                                                        ipw222.decreaseIndent();
                                                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                        }
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(pw, packageName6);
                                                        if (!checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                        this.mApexManager.dump(pw, packageName6);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    } catch (IOException e10) {
                                                        e3 = e10;
                                                        String str52 = "Failed writing: " + e3;
                                                        pw.println(str52);
                                                        str = str52;
                                                        if (checkin) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames4 = permissionNames3;
                                                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(4194304)) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        packageName6 = packageName5;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw2222 = new IndentingPrintWriter(pw, "  ", 120);
                                                        ipw2222.println();
                                                        ipw2222.println("Loaded volumes:");
                                                        ipw2222.increaseIndent();
                                                        if (this.mLoadedVolumes.size() == 0) {
                                                        }
                                                        ipw2222.decreaseIndent();
                                                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                        }
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(pw, packageName6);
                                                        if (!checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                        this.mApexManager.dump(pw, packageName6);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    } catch (Throwable th8) {
                                                        th = th8;
                                                        throw th;
                                                    }
                                                    if (checkin) {
                                                        try {
                                                            if (dumpState.isDumping(262144)) {
                                                                packageName4 = packageName2;
                                                                permissionNames4 = str;
                                                                if (packageName4 == null) {
                                                                    try {
                                                                        pw.println();
                                                                        if (this.mSettings.mPackages.size() == 0) {
                                                                            pw.println("No applications!");
                                                                            pw.println();
                                                                            permissionNames4 = str;
                                                                        } else {
                                                                            String prefix2 = "  ";
                                                                            Collection<PackageSetting> allPackageSettings2 = this.mSettings.mPackages.values();
                                                                            if (allPackageSettings2.size() == 0) {
                                                                                pw.println("No domain preferred apps!");
                                                                                pw.println();
                                                                                permissionNames4 = str;
                                                                            } else {
                                                                                pw.println("App verification status:");
                                                                                pw.println();
                                                                                int count = 0;
                                                                                Iterator<PackageSetting> it2 = allPackageSettings2.iterator();
                                                                                while (it2.hasNext()) {
                                                                                    IntentFilterVerificationInfo ivi = it2.next().getIntentFilterVerificationInfo();
                                                                                    if (ivi == null) {
                                                                                        prefix = prefix2;
                                                                                        it = it2;
                                                                                    } else if (ivi.getPackageName() == null) {
                                                                                        prefix = prefix2;
                                                                                        it = it2;
                                                                                    } else {
                                                                                        pw.println("  Package: " + ivi.getPackageName());
                                                                                        pw.println("  Domains: " + ivi.getDomainsString());
                                                                                        pw.println("  Status:  " + ivi.getStatusString());
                                                                                        pw.println();
                                                                                        count++;
                                                                                        prefix2 = prefix2;
                                                                                        it2 = it2;
                                                                                    }
                                                                                    prefix2 = prefix;
                                                                                    it2 = it;
                                                                                }
                                                                                if (count == 0) {
                                                                                    pw.println("  No app verification established.");
                                                                                    pw.println();
                                                                                }
                                                                                int[] userIds = sUserManager.getUserIds();
                                                                                int length = userIds.length;
                                                                                int count2 = count;
                                                                                int count3 = 0;
                                                                                while (count3 < length) {
                                                                                    int userId = userIds[count3];
                                                                                    StringBuilder sb2 = new StringBuilder();
                                                                                    sb2.append("App linkages for user ");
                                                                                    int userId2 = userId;
                                                                                    sb2.append(userId2);
                                                                                    sb2.append(":");
                                                                                    pw.println(sb2.toString());
                                                                                    pw.println();
                                                                                    int count4 = 0;
                                                                                    Iterator<PackageSetting> it3 = allPackageSettings.iterator();
                                                                                    while (it3.hasNext()) {
                                                                                        PackageSetting ps = it3.next();
                                                                                        long status = ps.getDomainVerificationStatusForUser(userId2);
                                                                                        if ((status >> c2) != 0 || DEBUG_DOMAIN_VERIFICATION) {
                                                                                            pw.println("  Package: " + ps.name);
                                                                                            pw.println("  Domains: " + dumpDomainString(ps.name));
                                                                                            pw.println("  Status:  " + IntentFilterVerificationInfo.getStatusStringFromValue(status));
                                                                                            pw.println();
                                                                                            count4++;
                                                                                            it3 = it3;
                                                                                            userId2 = userId2;
                                                                                            allPackageSettings = allPackageSettings;
                                                                                        } else {
                                                                                            allPackageSettings = allPackageSettings;
                                                                                        }
                                                                                    }
                                                                                    if (count4 == 0) {
                                                                                        pw.println("  No configured app linkages.");
                                                                                        pw.println();
                                                                                    }
                                                                                    count3++;
                                                                                    count2 = count4;
                                                                                    userIds = userIds;
                                                                                    length = length;
                                                                                    allPackageSettings2 = allPackageSettings;
                                                                                }
                                                                                permissionNames4 = count2;
                                                                            }
                                                                        }
                                                                    } catch (Throwable th9) {
                                                                        th = th9;
                                                                        throw th;
                                                                    }
                                                                }
                                                            } else {
                                                                packageName4 = packageName2;
                                                                permissionNames4 = str;
                                                            }
                                                        } catch (Throwable th10) {
                                                            th = th10;
                                                            throw th;
                                                        }
                                                    } else {
                                                        packageName4 = packageName2;
                                                        permissionNames4 = str;
                                                    }
                                                    if (!checkin) {
                                                        try {
                                                            if (dumpState.isDumping(64)) {
                                                                permissionNames4 = permissionNames3;
                                                                this.mSettings.dumpPermissionsLPr(pw, packageName4, permissionNames4, dumpState);
                                                                if (!checkin && dumpState.isDumping(1024)) {
                                                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                                }
                                                                if (!checkin && dumpState.isDumping(16384)) {
                                                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                                }
                                                                if (dumpState.isDumping(128)) {
                                                                    try {
                                                                        permissionNames5 = permissionNames4;
                                                                        packageName5 = packageName4;
                                                                        z2 = false;
                                                                        try {
                                                                            this.mSettings.dumpPackagesLPr(pw, packageName4, permissionNames4, dumpState, checkin);
                                                                        } catch (Throwable th11) {
                                                                            th = th11;
                                                                        }
                                                                    } catch (Throwable th12) {
                                                                        th = th12;
                                                                        throw th;
                                                                    }
                                                                } else {
                                                                    permissionNames5 = permissionNames4;
                                                                    packageName5 = packageName4;
                                                                    z2 = false;
                                                                }
                                                                if (dumpState.isDumping(256)) {
                                                                    this.mSettings.dumpSharedUsersLPr(pw, packageName5, permissionNames5, dumpState, checkin);
                                                                }
                                                                if (dumpState.isDumping(4194304)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    pw.println("Package Changes:");
                                                                    pw.print("  Sequence number=");
                                                                    pw.println(this.mChangedPackagesSequenceNumber);
                                                                    int K = this.mChangedPackages.size();
                                                                    int i5 = 0;
                                                                    while (i5 < K) {
                                                                        SparseArray<String> changes = this.mChangedPackages.valueAt(i5);
                                                                        pw.print("  User ");
                                                                        pw.print(this.mChangedPackages.keyAt(i5));
                                                                        pw.println(":");
                                                                        int N = changes.size();
                                                                        if (N == 0) {
                                                                            pw.print("    ");
                                                                            pw.println("No packages changed");
                                                                        } else {
                                                                            int j = 0;
                                                                            while (j < N) {
                                                                                int sequenceNumber = changes.keyAt(j);
                                                                                pw.print("    ");
                                                                                pw.print("seq=");
                                                                                pw.print(sequenceNumber);
                                                                                pw.print(", package=");
                                                                                pw.println(changes.valueAt(j));
                                                                                j++;
                                                                                K = K;
                                                                            }
                                                                        }
                                                                        i5++;
                                                                        K = K;
                                                                    }
                                                                }
                                                                if (!checkin || !dumpState.isDumping(524288)) {
                                                                    packageName6 = packageName5;
                                                                } else {
                                                                    packageName6 = packageName5;
                                                                    if (packageName6 == null) {
                                                                        try {
                                                                            if (dumpState.onTitlePrinted()) {
                                                                                pw.println();
                                                                            }
                                                                            IndentingPrintWriter ipw3 = new IndentingPrintWriter(pw, "  ", 120);
                                                                            ipw3.println();
                                                                            ipw3.println("Frozen packages:");
                                                                            ipw3.increaseIndent();
                                                                            if (this.mFrozenPackages.size() == 0) {
                                                                                ipw3.println("(none)");
                                                                            } else {
                                                                                for (int i6 = z2; i6 < this.mFrozenPackages.size(); i6++) {
                                                                                    ipw3.println(this.mFrozenPackages.valueAt(i6));
                                                                                }
                                                                            }
                                                                            ipw3.decreaseIndent();
                                                                        } catch (Throwable th13) {
                                                                            th = th13;
                                                                            throw th;
                                                                        }
                                                                    }
                                                                }
                                                                if (!checkin && dumpState.isDumping(8388608) && packageName6 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    IndentingPrintWriter ipw22222 = new IndentingPrintWriter(pw, "  ", 120);
                                                                    ipw22222.println();
                                                                    ipw22222.println("Loaded volumes:");
                                                                    ipw22222.increaseIndent();
                                                                    if (this.mLoadedVolumes.size() == 0) {
                                                                        ipw22222.println("(none)");
                                                                    } else {
                                                                        for (int i7 = z2; i7 < this.mLoadedVolumes.size(); i7++) {
                                                                            ipw22222.println(this.mLoadedVolumes.valueAt(i7));
                                                                        }
                                                                    }
                                                                    ipw22222.decreaseIndent();
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_SERVICE_PERMISSIONS) && packageName6 == null) {
                                                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                                }
                                                                Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                                if (!checkin && dumpState.isDumping(1048576)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                                        dumpDexoptStateLPr(pw, packageName6);
                                                                    }
                                                                }
                                                                Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                                if (!checkin && dumpState.isDumping(2097152)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    dumpCompilerStatsLPr(pw, packageName6);
                                                                }
                                                                if (!checkin) {
                                                                    i = 512;
                                                                    i = 512;
                                                                    i = 512;
                                                                    if (dumpState.isDumping(512) && packageName6 == null) {
                                                                        if (dumpState.onTitlePrinted()) {
                                                                            pw.println();
                                                                        }
                                                                        this.mSettings.dumpReadMessagesLPr(pw, dumpState);
                                                                        pw.println();
                                                                        pw.println("Package warning messages:");
                                                                        PackageManagerServiceUtils.dumpCriticalInfo(pw, null);
                                                                    }
                                                                } else {
                                                                    i = 512;
                                                                }
                                                                if (checkin && dumpState.isDumping(i)) {
                                                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                                }
                                                                Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                                if (!checkin && dumpState.isDumping(65536) && packageName6 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_APEX)) {
                                                                    this.mApexManager.dump(pw, packageName6);
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_HANDLE) && packageName6 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                                }
                                                                Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            }
                                                        } catch (Throwable th14) {
                                                            th = th14;
                                                            throw th;
                                                        }
                                                    }
                                                    permissionNames4 = permissionNames3;
                                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(4194304)) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    packageName6 = packageName5;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw222222 = new IndentingPrintWriter(pw, "  ", 120);
                                                    ipw222222.println();
                                                    ipw222222.println("Loaded volumes:");
                                                    ipw222222.increaseIndent();
                                                    if (this.mLoadedVolumes.size() == 0) {
                                                    }
                                                    ipw222222.decreaseIndent();
                                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                                    }
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(pw, packageName6);
                                                    if (!checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                    this.mApexManager.dump(pw, packageName6);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                } catch (Throwable th15) {
                                                    th = th15;
                                                    th = th;
                                                    throw th;
                                                }
                                            }
                                        } catch (Throwable th16) {
                                            th = th16;
                                            th = th;
                                            throw th;
                                        }
                                    }
                                    str = packageName3;
                                    if (checkin) {
                                    }
                                    if (!checkin) {
                                    }
                                    permissionNames4 = permissionNames3;
                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                                    if (dumpState.isDumping(128)) {
                                    }
                                    if (dumpState.isDumping(256)) {
                                    }
                                    if (dumpState.isDumping(4194304)) {
                                    }
                                    if (!checkin) {
                                    }
                                    packageName6 = packageName5;
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    IndentingPrintWriter ipw2222222 = new IndentingPrintWriter(pw, "  ", 120);
                                    ipw2222222.println();
                                    ipw2222222.println("Loaded volumes:");
                                    ipw2222222.increaseIndent();
                                    if (this.mLoadedVolumes.size() == 0) {
                                    }
                                    ipw2222222.decreaseIndent();
                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                                    }
                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    dumpCompilerStatsLPr(pw, packageName6);
                                    if (!checkin) {
                                    }
                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                    this.mApexManager.dump(pw, packageName6);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                }
                            } catch (Throwable th17) {
                                arrayMap = arrayMap2;
                                th = th17;
                                throw th;
                            }
                        }
                        packageName2 = packageName;
                        c2 = c;
                        permissionNames3 = permissionNames2;
                        fullPreferred3 = fullPreferred2;
                        arrayMap = arrayMap2;
                        z = true;
                        packageName3 = packageName;
                        if (!checkin) {
                        }
                        str = packageName3;
                        if (checkin) {
                        }
                        if (!checkin) {
                        }
                        permissionNames4 = permissionNames3;
                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName4);
                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName4, dumpState);
                    } catch (Throwable th18) {
                        arrayMap = arrayMap2;
                        th = th18;
                        throw th;
                    }
                    try {
                        if (dumpState.isDumping(128)) {
                        }
                    } catch (Throwable th19) {
                        th = th19;
                        throw th;
                    }
                    try {
                        if (dumpState.isDumping(256)) {
                        }
                        if (dumpState.isDumping(4194304)) {
                        }
                        if (!checkin) {
                        }
                        packageName6 = packageName5;
                        if (dumpState.onTitlePrinted()) {
                        }
                        IndentingPrintWriter ipw22222222 = new IndentingPrintWriter(pw, "  ", 120);
                        ipw22222222.println();
                        ipw22222222.println("Loaded volumes:");
                        ipw22222222.increaseIndent();
                        if (this.mLoadedVolumes.size() == 0) {
                        }
                        ipw22222222.decreaseIndent();
                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName6);
                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        if (SystemProperties.getBoolean("persist.sys.dumpdex", z2)) {
                        }
                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        dumpCompilerStatsLPr(pw, packageName6);
                        if (!checkin) {
                        }
                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                        this.mApexManager.dump(pw, packageName6);
                        if (dumpState.onTitlePrinted()) {
                        }
                        this.mHandler.dump(new PrintWriterPrinter(pw), HwLog.PREFIX);
                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                    } catch (Throwable th20) {
                        th = th20;
                        throw th;
                    }
                } catch (Throwable th21) {
                    arrayMap = arrayMap4;
                    th = th21;
                    throw th;
                }
            }
        }
    }

    private void disableSkuSpecificApps() {
        String[] apkList = this.mContext.getResources().getStringArray(17236009);
        String[] skuArray = this.mContext.getResources().getStringArray(17236008);
        if (!ArrayUtils.isEmpty(apkList)) {
            String sku = SystemProperties.get("ro.boot.hardware.sku");
            if (TextUtils.isEmpty(sku) || !ArrayUtils.contains(skuArray, sku)) {
                for (String packageName : apkList) {
                    setSystemAppHiddenUntilInstalled(packageName, true);
                    for (UserInfo user : sUserManager.getUsers(false)) {
                        setSystemAppInstallState(packageName, false, user.id);
                    }
                }
            }
        }
    }

    private void dumpProto(FileDescriptor fd) {
        ProtoOutputStream proto = new ProtoOutputStream(fd);
        synchronized (this.mPackages) {
            long requiredVerifierPackageToken = proto.start(1146756268033L);
            proto.write(1138166333441L, this.mRequiredVerifierPackage);
            proto.write(1120986464258L, getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
            proto.end(requiredVerifierPackageToken);
            if (this.mIntentFilterVerifierComponent != null) {
                String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                long verifierPackageToken = proto.start(1146756268034L);
                proto.write(1138166333441L, verifierPackageName);
                proto.write(1120986464258L, getPackageUid(verifierPackageName, 268435456, 0));
                proto.end(verifierPackageToken);
            }
            dumpSharedLibrariesProto(proto);
            dumpFeaturesProto(proto);
            this.mSettings.dumpPackagesProto(proto);
            this.mSettings.dumpSharedUsersProto(proto);
            PackageManagerServiceUtils.dumpCriticalInfo(proto);
        }
        proto.flush();
    }

    private void dumpFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableFeatures) {
            int count = this.mAvailableFeatures.size();
            for (int i = 0; i < count; i++) {
                this.mAvailableFeatures.valueAt(i).writeToProto(proto, 2246267895812L);
            }
        }
    }

    private void dumpSharedLibrariesProto(ProtoOutputStream proto) {
        int count = this.mSharedLibraries.size();
        for (int i = 0; i < count; i++) {
            LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(this.mSharedLibraries.keyAt(i));
            if (versionedLib != null) {
                int versionCount = versionedLib.size();
                for (int j = 0; j < versionCount; j++) {
                    SharedLibraryInfo libraryInfo = versionedLib.valueAt(j);
                    long sharedLibraryToken = proto.start(2246267895811L);
                    proto.write(1138166333441L, libraryInfo.getName());
                    boolean isJar = libraryInfo.getPath() != null;
                    proto.write(1133871366146L, isJar);
                    if (isJar) {
                        proto.write(1138166333443L, libraryInfo.getPath());
                    } else {
                        proto.write(1138166333444L, libraryInfo.getPackageName());
                    }
                    proto.end(sharedLibraryToken);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void dumpDexoptStateLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Dexopt state:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        if (ZygoteInit.sIsMygote) {
            MplDexOptAdaptor.getInstance().dumpPkgListDexoptState(ipw, packages, this.mDexManager);
            return;
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            this.mPackageDexOptimizer.dumpDexoptState(ipw, pkg, this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName));
            ipw.decreaseIndent();
        }
    }

    @GuardedBy({"mPackages"})
    private void dumpCompilerStatsLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Compiler stats:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            CompilerStats.PackageStats stats = getCompilerPackageStats(pkg.packageName);
            if (stats == null) {
                ipw.println("(No recorded stats)");
            } else {
                stats.dump(ipw);
            }
            ipw.decreaseIndent();
        }
    }

    private String dumpDomainString(String packageName) {
        List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
        List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
        ArraySet<String> result = new ArraySet<>();
        if (iviList.size() > 0) {
            for (IntentFilterVerificationInfo ivi : iviList) {
                result.addAll(ivi.getDomains());
            }
        }
        if (filters != null && filters.size() > 0) {
            for (IntentFilter filter : filters) {
                if (filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"))) {
                    result.addAll(filter.getHostsList());
                }
            }
        }
        StringBuilder sb = new StringBuilder(result.size() * 16);
        Iterator<String> it = result.iterator();
        while (it.hasNext()) {
            String domain = it.next();
            if (sb.length() > 0) {
                sb.append(HwLog.PREFIX);
            }
            sb.append(domain);
        }
        return sb.toString();
    }

    static String getEncryptKey() {
        try {
            String sdEncKey = SystemKeyStore.getInstance().retrieveKeyHexString(SD_ENCRYPTION_KEYSTORE_NAME);
            if (sdEncKey != null || (sdEncKey = SystemKeyStore.getInstance().generateNewKeyHexString(128, SD_ENCRYPTION_ALGORITHM, SD_ENCRYPTION_KEYSTORE_NAME)) != null) {
                return sdEncKey;
            }
            Slog.e(TAG, "Failed to create encryption keys");
            return null;
        } catch (NoSuchAlgorithmException nsae) {
            Slog.e(TAG, "Failed to create encryption keys with exception: " + nsae);
            return null;
        } catch (IOException ioe) {
            Slog.e(TAG, "Failed to retrieve encryption keys with exception: " + ioe);
            return null;
        }
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        int size = infos.size();
        String[] packageNames = new String[size];
        int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            ApplicationInfo info = infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<String> pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        sendResourcesChangedBroadcast(mediaStatus, replacing, (String[]) pkgList.toArray(new String[pkgList.size()]), uidArr, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        String action;
        if (pkgList.length > 0) {
            Bundle extras = new Bundle();
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (uidArr != null) {
                extras.putIntArray("android.intent.extra.changed_uid_list", uidArr);
            }
            if (replacing) {
                extras.putBoolean("android.intent.extra.REPLACING", replacing);
            }
            if (mediaStatus) {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
            } else {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
            }
            sendPackageBroadcast(action, null, extras, 0, null, finishedReceiver, null, null);
        }
    }

    /* access modifiers changed from: private */
    public void loadPrivatePackages(VolumeInfo vol) {
        this.mHandler.post(new Runnable(vol) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$mpkbs_Jog4_xGZga4KEB1RY5PQ */
            private final /* synthetic */ VolumeInfo f$1;

            {
                this.f$1 = r2;
            }

            public final void run() {
                PackageManagerService.this.lambda$loadPrivatePackages$31$PackageManagerService(this.f$1);
            }
        });
    }

    /* access modifiers changed from: private */
    /* renamed from: loadPrivatePackagesInner */
    public void lambda$loadPrivatePackages$31$PackageManagerService(VolumeInfo vol) {
        Settings.VersionInfo ver;
        List<PackageSetting> packages;
        int flags;
        Object obj;
        PackageSetting ps;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<PackageFreezer> freezers = new ArrayList<>();
        ArrayList<ApplicationInfo> loaded = new ArrayList<>();
        int parseFlags = this.mDefParseFlags | 8;
        synchronized (this.mPackages) {
            ver = this.mSettings.findOrCreateVersion(volumeUuid);
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        for (PackageSetting ps2 : packages) {
            freezers.add(freezePackage(ps2.name, "loadPrivatePackagesInner"));
            Object obj2 = this.mInstallLock;
            synchronized (obj2) {
                try {
                    obj = obj2;
                    ps = ps2;
                    try {
                        loaded.add(scanPackageTracedLI(ps2.codePath, parseFlags, 512, 0, (UserHandle) null).applicationInfo);
                    } catch (PackageManagerException e) {
                        e = e;
                    }
                } catch (PackageManagerException e2) {
                    e = e2;
                    obj = obj2;
                    ps = ps2;
                    try {
                        Slog.w(TAG, "Failed to scan " + ps.codePath + ": " + e.getMessage());
                        clearAppDataLIF(ps.pkg, -1, 39);
                    } catch (Throwable th) {
                        pkg = th;
                        throw pkg;
                    }
                } catch (Throwable th2) {
                    pkg = th2;
                    obj = obj2;
                    throw pkg;
                }
                if (!Build.FINGERPRINT.equals(ver.fingerprint) || !Build.FINGERPRINTEX.equals(ver.fingerprintEx)) {
                    clearAppDataLIF(ps.pkg, -1, 39);
                }
            }
        }
        StorageManager sm = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : ((UserManager) this.mContext.getSystemService(UserManager.class)).getUsers()) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            } else {
                continue;
            }
            try {
                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags);
                synchronized (this.mInstallLock) {
                    reconcileAppsDataLI(volumeUuid, user.id, flags, true);
                }
            } catch (IllegalStateException e3) {
                Slog.w(TAG, "Failed to prepare storage: " + e3);
            }
        }
        synchronized (this.mPackages) {
            boolean sdkUpdated = ver.sdkVersion != this.mSdkVersion;
            if (sdkUpdated) {
                PackageManagerServiceUtils.logCriticalInfo(4, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for " + volumeUuid);
            }
            this.mPermissionManager.updateAllPermissions(volumeUuid, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        Iterator<PackageFreezer> it = freezers.iterator();
        while (it.hasNext()) {
            it.next().close();
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Loaded packages " + loaded);
        }
        sendResourcesChangedBroadcast(true, false, loaded, null);
        this.mLoadedVolumes.add(vol.getId());
    }

    /* access modifiers changed from: private */
    public void unloadPrivatePackages(VolumeInfo vol) {
        this.mHandler.post(new Runnable(vol) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Qich5gXCtipYFdxGgEjenBAXyTU */
            private final /* synthetic */ VolumeInfo f$1;

            {
                this.f$1 = r2;
            }

            public final void run() {
                PackageManagerService.this.lambda$unloadPrivatePackages$32$PackageManagerService(this.f$1);
            }
        });
    }

    /* access modifiers changed from: private */
    /* renamed from: unloadPrivatePackagesInner */
    public void lambda$unloadPrivatePackages$32$PackageManagerService(VolumeInfo vol) {
        Throwable th;
        PackageFreezer freezer;
        PackageSetting ps;
        StringBuilder sb;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<ApplicationInfo> unloaded = new ArrayList<>();
        synchronized (this.mInstallLock) {
            synchronized (this.mPackages) {
                Iterator<PackageSetting> it = this.mSettings.getVolumePackagesLPr(volumeUuid).iterator();
                while (it.hasNext()) {
                    PackageSetting ps2 = it.next();
                    if (ps2.pkg != null) {
                        ApplicationInfo info = ps2.pkg.applicationInfo;
                        PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
                        PackageFreezer freezer2 = freezePackageForDelete(ps2.name, 1, "unloadPrivatePackagesInner");
                        try {
                            try {
                                if (deletePackageLIF(ps2.name, null, false, null, 1, outInfo, false, null)) {
                                    try {
                                        unloaded.add(info);
                                        ps = ps2;
                                    } catch (Throwable th2) {
                                        th = th2;
                                        freezer = freezer2;
                                        try {
                                            throw th;
                                        } catch (Throwable th3) {
                                            if (freezer != null) {
                                                $closeResource(th, freezer);
                                            }
                                            throw th3;
                                        }
                                    }
                                } else {
                                    try {
                                        sb = new StringBuilder();
                                        sb.append("Failed to unload ");
                                        ps = ps2;
                                    } catch (Throwable th4) {
                                        freezer = freezer2;
                                        th = th4;
                                        throw th;
                                    }
                                    try {
                                        sb.append(ps.codePath);
                                        Slog.w(TAG, sb.toString());
                                    } catch (Throwable th5) {
                                        freezer = freezer2;
                                        th = th5;
                                        throw th;
                                    }
                                }
                                if (freezer2 != null) {
                                    $closeResource(null, freezer2);
                                }
                                AttributeCache.instance().removePackage(ps.name);
                                it = it;
                            } catch (Throwable th6) {
                                freezer = freezer2;
                                th = th6;
                                throw th;
                            }
                        } catch (Throwable th7) {
                            freezer = freezer2;
                            th = th7;
                            throw th;
                        }
                    }
                }
                this.mSettings.writeLPr();
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Unloaded packages " + unloaded);
        }
        sendResourcesChangedBroadcast(false, false, unloaded, null);
        this.mLoadedVolumes.remove(vol.getId());
        ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
        for (int i = 0; i < 3; i++) {
            System.gc();
            System.runFinalization();
        }
    }

    private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException {
        synchronized (this.mPackages) {
            String packageName2 = normalizePackageNameLPr(packageName);
            PackageSetting ps = this.mSettings.mPackages.get(packageName2);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName2 + " is unknown");
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                throw new PackageManagerException("Package " + packageName2 + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            } else if (!ps.getInstalled(userId)) {
                throw new PackageManagerException("Package " + packageName2 + " not installed for user " + userId);
            }
        }
    }

    private List<String> collectAbsoluteCodePaths() {
        List<String> codePaths;
        synchronized (this.mPackages) {
            codePaths = new ArrayList<>();
            int packageCount = this.mSettings.mPackages.size();
            for (int i = 0; i < packageCount; i++) {
                codePaths.add(this.mSettings.mPackages.valueAt(i).codePath.getAbsolutePath());
            }
        }
        return codePaths;
    }

    /* access modifiers changed from: private */
    public void reconcileApps(String volumeUuid) {
        List<String> absoluteCodePaths = collectAbsoluteCodePaths();
        File[] files = FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
        List<File> filesToDelete = null;
        for (File file : files) {
            if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                String absolutePath = file.getAbsolutePath();
                boolean pathValid = false;
                int absoluteCodePathCount = absoluteCodePaths.size();
                int i = 0;
                while (true) {
                    if (i >= absoluteCodePathCount) {
                        break;
                    } else if (absolutePath.startsWith(absoluteCodePaths.get(i))) {
                        pathValid = true;
                        break;
                    } else {
                        i++;
                    }
                }
                if (!pathValid) {
                    if (filesToDelete == null) {
                        filesToDelete = new ArrayList<>();
                    }
                    filesToDelete.add(file);
                }
            }
        }
        if (filesToDelete != null) {
            int fileToDeleteCount = filesToDelete.size();
            reportVolumeApkScanError(volumeUuid, fileToDeleteCount);
            for (int i2 = 0; i2 < fileToDeleteCount; i2++) {
                File fileToDelete = filesToDelete.get(i2);
                PackageManagerServiceUtils.logCriticalInfo(5, "Destroying orphaned" + fileToDelete);
                synchronized (this.mInstallLock) {
                    removeCodePathLI(fileToDelete);
                }
            }
        }
    }

    private void reportVolumeApkScanError(String volumeUuid, int fileToDeleteCount) {
        long elapsedRealtime = SystemClock.elapsedRealtime();
        Slog.i(TAG, "Scan volume file in volumeUuid :" + volumeUuid + ", delete orphaned apk files:" + fileToDeleteCount + ", elapsedRealtime:" + elapsedRealtime + ", effective apps:" + this.mPackages.size());
        HwPackageManagerServiceUtils.reportPmsDeleteDataApp(this.mPackages.size(), fileToDeleteCount, elapsedRealtime);
    }

    /* access modifiers changed from: package-private */
    public void reconcileAppsData(int userId, int flags, boolean migrateAppsData) {
        for (VolumeInfo vol : ((StorageManager) this.mContext.getSystemService(StorageManager.class)).getWritablePrivateVolumes()) {
            String volumeUuid = vol.getFsUuid();
            synchronized (this.mInstallLock) {
                reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppsData);
            }
        }
    }

    @GuardedBy({"mInstallLock"})
    private void reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData) {
        reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppData, false);
    }

    @GuardedBy({"mInstallLock"})
    private List<String> reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData, boolean onlyCoreApps) {
        int i;
        List<PackageSetting> packages;
        int i2;
        File[] files;
        int i3;
        File[] files2;
        int i4;
        int i5;
        File ceDir;
        int i6;
        Slog.v(TAG, "reconcileAppsData for " + volumeUuid + " u" + userId + " 0x" + Integer.toHexString(flags) + " migrateAppData=" + migrateAppData);
        List<String> result = onlyCoreApps ? new ArrayList<>() : null;
        File ceDir2 = Environment.getDataUserCeDirectory(volumeUuid, userId);
        File deDir = Environment.getDataUserDeDirectory(volumeUuid, userId);
        int i7 = 5;
        if ((flags & 2) == 0) {
            i = 5;
        } else if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
            File[] files3 = FileUtils.listFilesOrEmpty(ceDir2);
            int length = files3.length;
            int i8 = 0;
            while (i8 < length) {
                File file = files3[i8];
                String packageName = file.getName();
                try {
                    assertPackageKnownAndInstalled(volumeUuid, packageName, userId);
                    i5 = i8;
                    i4 = length;
                    files2 = files3;
                    ceDir = ceDir2;
                    i6 = i7;
                } catch (PackageManagerException e) {
                    PackageManagerServiceUtils.logCriticalInfo(i7, "Destroying " + file + " due to: " + e);
                    if (!HwMaplePMServiceUtils.getMapleEnableFlag(packageName)) {
                        HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName);
                    }
                    try {
                        i5 = i8;
                        i4 = length;
                        files2 = files3;
                        ceDir = ceDir2;
                        i6 = i7;
                        try {
                            this.mInstaller.destroyAppData(volumeUuid, packageName, userId, 2, 0);
                        } catch (Installer.InstallerException e2) {
                            e2 = e2;
                        }
                    } catch (Installer.InstallerException e3) {
                        e2 = e3;
                        i5 = i8;
                        i4 = length;
                        files2 = files3;
                        ceDir = ceDir2;
                        i6 = i7;
                        PackageManagerServiceUtils.logCriticalInfo(i6, "Failed to destroy: " + e2);
                        i8 = i5 + 1;
                        i7 = i6;
                        ceDir2 = ceDir;
                        length = i4;
                        files3 = files2;
                    }
                }
                i8 = i5 + 1;
                i7 = i6;
                ceDir2 = ceDir;
                length = i4;
                files3 = files2;
            }
            i = i7;
        } else {
            throw new RuntimeException("Yikes, someone asked us to reconcile CE storage while " + userId + " was still locked; this would have caused massive data loss!");
        }
        if ((flags & 1) != 0) {
            File[] files4 = FileUtils.listFilesOrEmpty(deDir);
            int length2 = files4.length;
            int i9 = 0;
            while (i9 < length2) {
                File file2 = files4[i9];
                String packageName2 = file2.getName();
                try {
                    assertPackageKnownAndInstalled(volumeUuid, packageName2, userId);
                    i3 = i9;
                    files = files4;
                    i2 = length2;
                } catch (PackageManagerException e4) {
                    PackageManagerServiceUtils.logCriticalInfo(i, "Destroying " + file2 + " due to: " + e4);
                    if (!HwMaplePMServiceUtils.getMapleEnableFlag(packageName2)) {
                        HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName2);
                    }
                    try {
                        i3 = i9;
                        files = files4;
                        i2 = length2;
                        try {
                            this.mInstaller.destroyAppData(volumeUuid, packageName2, userId, 1, 0);
                        } catch (Installer.InstallerException e5) {
                            e2 = e5;
                        }
                    } catch (Installer.InstallerException e6) {
                        e2 = e6;
                        i3 = i9;
                        files = files4;
                        i2 = length2;
                        PackageManagerServiceUtils.logCriticalInfo(i, "Failed to destroy: " + e2);
                        i9 = i3 + 1;
                        files4 = files;
                        length2 = i2;
                    }
                }
                i9 = i3 + 1;
                files4 = files;
                length2 = i2;
            }
        }
        synchronized (this.mPackages) {
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        if ((flags & 2) != 0) {
            try {
                UniPerf.getInstance().uniPerfEvent(4099, "", new int[0]);
            } catch (RuntimeException e7) {
                Slog.v(TAG, "raise cpu error!");
            }
        }
        int preparedCount = 0;
        for (PackageSetting ps : packages) {
            String packageName3 = ps.name;
            if (ps.pkg == null) {
                Slog.w(TAG, "Odd, missing scanned package " + packageName3);
            } else if (onlyCoreApps && !ps.pkg.coreApp) {
                result.add(packageName3);
            } else if (ps.getInstalled(userId)) {
                prepareAppDataAndMigrateLIF(ps.pkg, userId, flags, migrateAppData);
                preparedCount++;
            }
        }
        Slog.v(TAG, "reconcileAppsData finished " + preparedCount + " packages");
        return result;
    }

    /* access modifiers changed from: protected */
    public void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) {
        PackageSetting ps;
        int flags;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
            this.mSettings.writeKernelMappingLPr(ps);
        }
        UserManagerService um = sUserManager;
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers(false)) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            if (ps != null && ps.getInstalled(user.id)) {
                prepareAppDataLIF(pkg, user.id, flags);
            }
        }
    }

    private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataAndMigrateLIF(PackageParser.Package pkg, int userId, int flags, boolean maybeMigrateAppData) {
        prepareAppDataLIF(pkg, userId, flags);
        if (maybeMigrateAppData && maybeMigrateAppDataLIF(pkg, userId)) {
            prepareAppDataLIF(pkg, userId, flags);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:48:0x0116  */
    private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        ApplicationInfo app;
        ApplicationInfo app2;
        boolean z;
        long ceDataInode;
        if (DEBUG_APP_DATA) {
            Slog.v(TAG, "prepareAppData for " + pkg.packageName + " u" + userId + " 0x" + Integer.toHexString(flags));
        }
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        if (ps == null) {
            app = pkg.applicationInfo;
        } else {
            app = PackageParser.generateApplicationInfo(pkg, 0, ps.readUserState(userId), userId);
        }
        if (app == null) {
            app2 = pkg.applicationInfo;
        } else {
            app2 = app;
        }
        int appId = UserHandle.getAppId(app2.uid);
        Preconditions.checkNotNull(app2.seInfo);
        if (!isUpgradeAndEmuiVersionUpgrade() || mHwPMSEx.migrateDataForRenamedPackageLocked(pkg, userId, flags)) {
            StringBuilder sb = new StringBuilder();
            sb.append(app2.seInfo);
            sb.append(app2.seInfoUser != null ? app2.seInfoUser : "");
            try {
                z = false;
                try {
                    ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, sb.toString(), app2.targetSdkVersion);
                } catch (Installer.InstallerException e) {
                    e = e;
                    Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
                    ceDataInode = -1;
                    this.mArtManagerService.prepareAppProfiles(pkg, userId, z);
                    synchronized (this.mPackages) {
                    }
                }
            } catch (Installer.InstallerException e2) {
                e = e2;
                z = false;
                Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
                ceDataInode = -1;
                this.mArtManagerService.prepareAppProfiles(pkg, userId, z);
                synchronized (this.mPackages) {
                }
            }
            if (this.mIsUpgrade || this.mFirstBoot || userId != 0) {
                this.mArtManagerService.prepareAppProfiles(pkg, userId, z);
            }
            if (!((flags & 2) == 0 || ceDataInode == -1)) {
                synchronized (this.mPackages) {
                    if (ps != null) {
                        ps.setCeDataInode(ceDataInode, userId);
                    }
                }
            }
            prepareAppDataContentsLeafLIF(pkg, userId, flags);
            return;
        }
        Slog.i(TAG, "PACKAGE_NAME_CHANGE renamed package :" + pkg.packageName + ", no need to prepare the data directory");
    }

    private void prepareAppDataContentsLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataContentsLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataContentsLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        if ((flags & 2) != 0 && app.primaryCpuAbi != null && !VMRuntime.is64BitAbi(app.primaryCpuAbi)) {
            try {
                this.mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, app.nativeLibraryDir, userId);
            } catch (Installer.InstallerException e) {
                Slog.e(TAG, "Failed to link native for " + packageName + ": " + e);
            }
        }
    }

    private boolean maybeMigrateAppDataLIF(PackageParser.Package pkg, int userId) {
        if (!pkg.isSystem() || StorageManager.isFileEncryptedNativeOrEmulated()) {
            return false;
        }
        try {
            this.mInstaller.migrateAppData(pkg.volumeUuid, pkg.packageName, userId, pkg.applicationInfo.isDefaultToDeviceProtectedStorage() ? 1 : 2);
        } catch (Installer.InstallerException e) {
            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to migrate " + pkg.packageName + ": " + e.getMessage());
        }
        return true;
    }

    public PackageFreezer freezePackage(String packageName, String killReason) {
        return freezePackage(packageName, -1, killReason);
    }

    public PackageFreezer freezePackage(String packageName, int userId, String killReason) {
        return new PackageFreezer(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) {
        return freezePackageForInstall(packageName, -1, installFlags, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) {
        if ((installFlags & 4096) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int deleteFlags, String killReason) {
        return freezePackageForDelete(packageName, -1, deleteFlags, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int userId, int deleteFlags, String killReason) {
        if ((deleteFlags & 8) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    private class PackageFreezer implements AutoCloseable {
        private final PackageFreezer[] mChildren;
        private final CloseGuard mCloseGuard;
        private final AtomicBoolean mClosed;
        private final String mPackageName;
        private final boolean mWeFroze;

        public PackageFreezer() {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            this.mPackageName = null;
            this.mChildren = null;
            this.mWeFroze = false;
            this.mCloseGuard.open("close");
        }

        public PackageFreezer(String packageName, int userId, String killReason) {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            synchronized (PackageManagerService.this.mPackages) {
                this.mPackageName = packageName;
                this.mWeFroze = PackageManagerService.this.mFrozenPackages.add(this.mPackageName);
                Slog.d(PackageManagerService.TAG, "mFrozenPackages add package:" + this.mPackageName);
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(this.mPackageName);
                if (ps != null) {
                    PackageManagerService.this.killApplication(ps.name, ps.appId, userId, killReason);
                }
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null || p.childPackages == null) {
                    this.mChildren = null;
                } else {
                    int N = p.childPackages.size();
                    this.mChildren = new PackageFreezer[N];
                    for (int i = 0; i < N; i++) {
                        this.mChildren[i] = new PackageFreezer(((PackageParser.Package) p.childPackages.get(i)).packageName, userId, killReason);
                    }
                }
            }
            this.mCloseGuard.open("close");
        }

        /* access modifiers changed from: protected */
        @Override // java.lang.Object
        public void finalize() throws Throwable {
            try {
                this.mCloseGuard.warnIfOpen();
                close();
            } finally {
                super.finalize();
            }
        }

        @Override // java.lang.AutoCloseable
        public void close() {
            this.mCloseGuard.close();
            if (this.mClosed.compareAndSet(false, true)) {
                synchronized (PackageManagerService.this.mPackages) {
                    if (this.mWeFroze) {
                        PackageManagerService.this.mFrozenPackages.remove(this.mPackageName);
                        Slog.d(PackageManagerService.TAG, "mFrozenPackages remove package:" + this.mPackageName);
                    }
                    if (this.mChildren != null) {
                        for (PackageFreezer freezer : this.mChildren) {
                            freezer.close();
                        }
                    }
                }
            }
        }
    }

    private void checkPackageFrozen(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mFrozenPackages.contains(packageName)) {
                Slog.wtf(TAG, "Expected " + packageName + " to be frozen!", new Throwable());
            }
        }
    }

    public int movePackage(String packageName, String volumeUuid) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        int callingUid = Binder.getCallingUid();
        UserHandle user = new UserHandle(UserHandle.getUserId(callingUid));
        int moveId = this.mNextMoveId.getAndIncrement();
        this.mHandler.post(new Runnable(packageName, volumeUuid, moveId, callingUid, user) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sWj4jY4N93WvkqHJP5B7yuqFD80 */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ String f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ int f$4;
            private final /* synthetic */ UserHandle f$5;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$movePackage$33$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
            }
        });
        return moveId;
    }

    public /* synthetic */ void lambda$movePackage$33$PackageManagerService(String packageName, String volumeUuid, int moveId, int callingUid, UserHandle user) {
        try {
            movePackageInternal(packageName, volumeUuid, moveId, callingUid, user);
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to move " + packageName, e);
            this.mMoveCallbacks.notifyStatusChanged(moveId, e.error);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x0327, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Not enough free space to move");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x0328, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x033a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x034c, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x034d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0368, code lost:
        r4.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0373, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Move location not mounted private volume");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x010e, code lost:
        r2 = new android.os.Bundle();
        r2.putString("android.intent.extra.PACKAGE_NAME", r57);
        r2.putString("android.intent.extra.TITLE", r3);
        com.android.server.pm.PackageManagerService.MoveCallbacks.access$5400(r56.mMoveCallbacks, r59, r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x012b, code lost:
        if (java.util.Objects.equals(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, r58) == false) goto L_0x0135;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x012d, code lost:
        r1 = android.os.Environment.getDataAppDirectory(r58);
        r44 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x013c, code lost:
        if (java.util.Objects.equals("primary_physical", r58) == false) goto L_0x014a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x013e, code lost:
        r1 = r12.getPrimaryPhysicalVolume().getPath();
        r44 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x014a, code lost:
        r0 = r12.findVolumeByUuid(r58);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x014e, code lost:
        if (r0 == null) goto L_0x035c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x0154, code lost:
        if (r0.getType() != 1) goto L_0x035c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x015a, code lost:
        if (r0.isMountedWritable() == false) goto L_0x034f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x015c, code lost:
        r44 = true;
        r1 = android.os.Environment.getDataAppDirectory(r58);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0164, code lost:
        if (r44 == false) goto L_0x01b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0166, code lost:
        r0 = r0.length;
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0168, code lost:
        if (r5 >= r0) goto L_0x01ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x016a, code lost:
        r0 = r0[r5];
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0172, code lost:
        if (android.os.storage.StorageManager.isFileEncryptedNativeOrEmulated() == false) goto L_0x01a5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x0178, code lost:
        if (android.os.storage.StorageManager.isUserKeyUnlocked(r0) == false) goto L_0x017f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x01a0, code lost:
        throw new com.android.server.pm.PackageManagerException(-10, "User " + r0 + " must be unlocked");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x01a5, code lost:
        r5 = r5 + 1;
        r0 = r0;
        r2 = r2;
        r3 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x01ae, code lost:
        r19 = r2;
        r22 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x01b3, code lost:
        r19 = r2;
        r22 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x01b7, code lost:
        r0 = new android.content.pm.PackageStats(null, -1);
        r2 = r56.mInstaller;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x01c1, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:?, code lost:
        r0 = r0.length;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x01c3, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x01c4, code lost:
        if (r3 >= r0) goto L_0x020f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x01d2, code lost:
        if (getPackageSizeInfoLI(r57, r0[r3], r0) == false) goto L_0x01d9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x01d4, code lost:
        r3 = r3 + 1;
        r0 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x01d9, code lost:
        r4.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x01e8, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Failed to measure package size");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x01e9, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x01fc, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x0214, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0238;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x0216, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "Measured code size " + r0.codeSize + ", data size " + r0.dataSize);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x0238, code lost:
        r45 = r1.getUsableSpace();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x023c, code lost:
        if (r44 == false) goto L_0x0248;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x023e, code lost:
        r24 = r4;
        r47 = r0.codeSize + r0.dataSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x0248, code lost:
        r24 = r4;
        r47 = r0.codeSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x0254, code lost:
        if (r47 > r12.getStorageBytesUntilLow(r1)) goto L_0x031a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x0256, code lost:
        com.android.server.pm.PackageManagerService.MoveCallbacks.access$5500(r56.mMoveCallbacks, r59, 10);
        r3 = new java.util.concurrent.CountDownLatch(1);
        r21 = new com.android.server.pm.PackageManagerService.AnonymousClass11(r56);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x027a, code lost:
        if (r44 == false) goto L_0x02b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x027c, code lost:
        r2 = r56;
        new java.lang.Thread(new com.android.server.pm.$$Lambda$PackageManagerService$ud8P2Ejwc4ZWnYTni6qR7UaYB08(r56, r3, r45, r1, r47, r59)).start();
        r0 = new com.android.server.pm.PackageManagerService.MoveInfo(r59, r24, r58, r57, r3.getName(), r40, r3, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x02b4, code lost:
        r2 = r56;
        r0 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x02bd, code lost:
        r8 = r2.mHandler.obtainMessage(5);
        r10 = new com.android.server.pm.PackageManagerService.InstallParams(r56, com.android.server.pm.PackageManagerService.OriginInfo.fromExistingFile(r3), r0, r21, 16 | 2, r3, r58, null, r61, r3, null, null, android.content.pm.PackageParser.SigningDetails.UNKNOWN, 0, -1);
        r10.setTraceMethod("movePackage").setTraceCookie(java.lang.System.identityHashCode(r10));
        r8.obj = r10;
        android.os.Trace.asyncTraceBegin(262144, "movePackage", java.lang.System.identityHashCode(r8.obj));
        android.os.Trace.asyncTraceBegin(262144, "queueInstall", java.lang.System.identityHashCode(r8.obj));
        r2.mHandler.sendMessage(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x0319, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x031a, code lost:
        r4.close();
     */
    private void movePackageInternal(final String packageName, String volumeUuid, final int moveId, int callingUid, UserHandle user) throws PackageManagerException {
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        PackageManager pm = this.mContext.getPackageManager();
        synchronized (this.mPackages) {
            try {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (pkg != null && ps != null) {
                    if (!filterAppAccessLPr(ps, callingUid, user.getIdentifier())) {
                        if (!pkg.applicationInfo.isSystemApp()) {
                            boolean isInternalStorage = "private".equals(volumeUuid);
                            boolean allow3rdPartyOnInternal = this.mContext.getResources().getBoolean(17891339);
                            if (!isInternalStorage || allow3rdPartyOnInternal) {
                                String currentVolumeUuid = ps.volumeUuid;
                                File probe = new File(pkg.codePath);
                                File probeOat = new File(probe, "oat");
                                if (!probe.isDirectory() || !probeOat.isDirectory()) {
                                    throw new PackageManagerException(-6, "Move only supported for modern cluster style installs");
                                } else if (!Objects.equals(currentVolumeUuid, volumeUuid)) {
                                    if (pkg.applicationInfo.isInternal()) {
                                        if (isPackageDeviceAdminOnAnyUser(packageName)) {
                                            throw new PackageManagerException(-8, "Device admin cannot be moved");
                                        }
                                    }
                                    if (!this.mFrozenPackages.contains(packageName)) {
                                        final boolean isCurrentLocationExternal = isExternal(pkg);
                                        File codeFile = new File(pkg.codePath);
                                        String installerPackageName = ps.installerPackageName;
                                        String packageAbiOverride = ps.cpuAbiOverrideString;
                                        int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                                        String seinfo = pkg.applicationInfo.seInfo;
                                        String label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
                                        int targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
                                        final PackageFreezer freezer = freezePackage(packageName, "movePackageInternal");
                                        int[] installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                    } else {
                                        throw new PackageManagerException(-7, "Failed to move already frozen package");
                                    }
                                } else {
                                    throw new PackageManagerException(-6, "Package already moved to " + volumeUuid);
                                }
                            } else {
                                try {
                                    throw new PackageManagerException(-9, "3rd party apps are not allowed on internal storage");
                                } catch (Throwable th) {
                                    pkg = th;
                                    throw pkg;
                                }
                            }
                        } else {
                            throw new PackageManagerException(-3, "Cannot move system application");
                        }
                    }
                }
                throw new PackageManagerException(-2, "Missing package");
            } catch (Throwable th2) {
                pkg = th2;
                throw pkg;
            }
        }
    }

    public /* synthetic */ void lambda$movePackageInternal$34$PackageManagerService(CountDownLatch installedLatch, long startFreeBytes, File measurePath, long sizeBytes, int moveId) {
        while (!installedLatch.await(1, TimeUnit.SECONDS)) {
            this.mMoveCallbacks.notifyStatusChanged(moveId, ((int) MathUtils.constrain((80 * (startFreeBytes - measurePath.getUsableSpace())) / sizeBytes, 0, 80)) + 10);
        }
    }

    /* access modifiers changed from: private */
    public void logAppMovedStorage(String packageName, boolean isPreviousLocationExternal) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        if (pkg != null) {
            int packageExternalStorageType = getPackageExternalStorageType(((StorageManager) this.mContext.getSystemService(StorageManager.class)).findVolumeByUuid(pkg.applicationInfo.storageUuid.toString()), isExternal(pkg));
            if (!isPreviousLocationExternal && isExternal(pkg)) {
                StatsLog.write(183, packageExternalStorageType, 1, packageName);
            } else if (isPreviousLocationExternal && !isExternal(pkg)) {
                StatsLog.write(183, packageExternalStorageType, 2, packageName);
            }
        }
    }

    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int realMoveId = this.mNextMoveId.getAndIncrement();
        Bundle extras = new Bundle();
        extras.putString("android.os.storage.extra.FS_UUID", volumeUuid);
        this.mMoveCallbacks.notifyCreated(realMoveId, extras);
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).setPrimaryStorageUuid(volumeUuid, new IPackageMoveObserver.Stub() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass12 */

            public void onCreated(int moveId, Bundle extras) {
            }

            public void onStatusChanged(int moveId, int status, long estMillis) {
                PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        });
        return realMoveId;
    }

    public int getMoveStatus(int moveId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        return this.mMoveCallbacks.mLastStatus.get(moveId);
    }

    public void registerMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.register(callback);
    }

    public void unregisterMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.unregister(callback);
    }

    public boolean setInstallLocation(int loc) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS", null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc != 0 && loc != 1 && loc != 2) {
            return false;
        }
        Settings.Global.putInt(this.mContext.getContentResolver(), "default_install_location", loc);
        return true;
    }

    public int getInstallLocation() {
        return Settings.Global.getInt(this.mContext.getContentResolver(), "default_install_location", 0);
    }

    /* access modifiers changed from: package-private */
    public void cleanUpUser(UserManagerService userManager, int userHandle) {
        synchronized (this.mPackages) {
            this.mDirtyUsers.remove(Integer.valueOf(userHandle));
            this.mUserNeedsBadging.delete(userHandle);
            this.mSettings.removeUserLPw(userHandle);
            this.mPendingBroadcasts.remove(userHandle);
            this.mInstantAppRegistry.onUserRemovedLPw(userHandle);
            removeUnusedPackagesLPw(userManager, userHandle);
        }
        mHwPMSEx.onUserRemoved(userHandle);
    }

    @GuardedBy({"mPackages"})
    private void removeUnusedPackagesLPw(UserManagerService userManager, int userHandle) {
        int[] users = userManager.getUserIds();
        for (PackageSetting ps : this.mSettings.mPackages.values()) {
            if (ps.pkg != null) {
                String packageName = ps.pkg.packageName;
                if (((ps.pkgFlags & 1) == 0 && TextUtils.isEmpty(ps.pkg.staticSharedLibName)) || HwPackageManagerServiceUtils.isPreRemovableApp(ps)) {
                    boolean keep = shouldKeepUninstalledPackageLPr(packageName);
                    if (!keep) {
                        int i = 0;
                        while (true) {
                            if (i < users.length) {
                                if (users[i] != userHandle && ps.getInstalled(users[i])) {
                                    keep = true;
                                    break;
                                }
                                i++;
                            } else {
                                break;
                            }
                        }
                    }
                    if (!keep) {
                        this.mHandler.post(new Runnable(packageName, userHandle) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$qTeQWG5aX0oBzrmNAoXrjFCQe_s */
                            private final /* synthetic */ String f$1;
                            private final /* synthetic */ int f$2;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                            }

                            public final void run() {
                                PackageManagerService.this.lambda$removeUnusedPackagesLPw$35$PackageManagerService(this.f$1, this.f$2);
                            }
                        });
                    }
                }
            }
        }
    }

    public /* synthetic */ void lambda$removeUnusedPackagesLPw$35$PackageManagerService(String packageName, int userHandle) {
        deletePackageX(packageName, -1, userHandle, 0);
    }

    /* access modifiers changed from: package-private */
    public void createNewUser(int userId, String[] disallowedPackages) {
        synchronized (this.mInstallLock) {
            this.mSettings.createNewUserLI(this, this.mInstaller, userId, disallowedPackages);
        }
        synchronized (this.mPackages) {
            scheduleWritePackageRestrictionsLocked(userId);
            scheduleWritePackageListLocked(userId);
            primeDomainVerificationsLPw(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void onNewUserCreated(int userId) {
        this.mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, true, this.mPackages.values(), this.mPermissionCallback);
        }
        mHwPMSEx.onNewUserCreated(userId);
    }

    public VerifierDeviceIdentity getVerifierDeviceIdentity() throws RemoteException {
        VerifierDeviceIdentity verifierDeviceIdentityLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can read the verifier device identity");
        synchronized (this.mPackages) {
            verifierDeviceIdentityLPw = this.mSettings.getVerifierDeviceIdentityLPw();
        }
        return verifierDeviceIdentityLPw;
    }

    public void setPermissionEnforced(String permission, boolean enforced) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "setPermissionEnforced");
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(permission)) {
            synchronized (this.mPackages) {
                if (this.mSettings.mReadExternalStorageEnforced == null || this.mSettings.mReadExternalStorageEnforced.booleanValue() != enforced) {
                    this.mSettings.mReadExternalStorageEnforced = enforced ? Boolean.TRUE : Boolean.FALSE;
                    this.mSettings.writeLPr();
                }
            }
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                long token = Binder.clearCallingIdentity();
                try {
                    am.killProcessesBelowForeground("setPermissionEnforcement");
                } catch (RemoteException e) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(token);
                    throw th;
                }
                Binder.restoreCallingIdentity(token);
                return;
            }
            return;
        }
        throw new IllegalArgumentException("No selective enforcement for " + permission);
    }

    @Deprecated
    public boolean isPermissionEnforced(String permission) {
        return true;
    }

    public boolean isStorageLow() {
        long token = Binder.clearCallingIdentity();
        try {
            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
            if (dsm != null) {
                return dsm.isMemoryLow();
            }
            Binder.restoreCallingIdentity(token);
            return false;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return this.mInstallerService;
    }

    public IArtManager getArtManager() {
        return this.mArtManagerService;
    }

    /* access modifiers changed from: private */
    public boolean userNeedsBadging(int userId) {
        boolean b;
        int index = this.mUserNeedsBadging.indexOfKey(userId);
        if (index >= 0) {
            return this.mUserNeedsBadging.valueAt(index);
        }
        long token = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            if (userInfo == null || !userInfo.isManagedProfile()) {
                b = false;
            } else {
                b = true;
            }
            this.mUserNeedsBadging.put(userId, b);
            return b;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public KeySet getKeySetByAlias(String packageName, String alias) {
        KeySet keySet;
        if (packageName == null || alias == null) {
            return null;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getKeySetByAliasAndPackageNameLPr(packageName, alias));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public KeySet getSigningKeySet(String packageName) {
        KeySet keySet;
        if (packageName == null) {
            return null;
        }
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                if (pkg.applicationInfo.uid != callingUid) {
                    if (1000 != callingUid) {
                        throw new SecurityException("May not access signing KeySet of other apps.");
                    }
                }
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getSigningKeySetByPackageNameLPr(packageName));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName + ", uid:" + callingUid);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            return this.mSettings.mKeySetManagerService.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
        }
    }

    public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            return this.mSettings.mKeySetManagerService.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public void deletePackageIfUnusedLPr(String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps != null && !ps.isAnyInstalled(sUserManager.getUserIds())) {
            this.mHandler.post(new Runnable(packageName) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$IYkCOosz9rC8oYS9GghQdIFouuY */
                private final /* synthetic */ String f$1;

                {
                    this.f$1 = r2;
                }

                public final void run() {
                    PackageManagerService.this.lambda$deletePackageIfUnusedLPr$36$PackageManagerService(this.f$1);
                }
            });
        }
    }

    public /* synthetic */ void lambda$deletePackageIfUnusedLPr$36$PackageManagerService(String packageName) {
        deletePackageX(packageName, -1, 0, 2);
    }

    /* access modifiers changed from: private */
    public static void checkDowngrade(PackageParser.Package before, PackageInfoLite after) throws PackageManagerException {
        if (after.getLongVersionCode() < before.getLongVersionCode()) {
            throw new PackageManagerException(-25, "Update version code " + after.versionCode + " is older than current " + before.getLongVersionCode());
        } else if (after.getLongVersionCode() != before.getLongVersionCode()) {
        } else {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                throw new PackageManagerException(-25, "Update base revision code " + after.baseRevisionCode + " is older than current " + before.baseRevisionCode);
            } else if (!ArrayUtils.isEmpty(after.splitNames)) {
                for (int i = 0; i < after.splitNames.length; i++) {
                    String splitName = after.splitNames[i];
                    int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j != -1) {
                        if (after.hasPlugin && after.splitVersionCodes[i] < before.splitVersionCodes[j]) {
                            throw new PackageManagerException(-25, "Update split " + splitName + " version code " + after.splitVersionCodes[i] + " is older than current " + before.splitVersionCodes[j]);
                        } else if (after.splitRevisionCodes[i] < before.splitRevisionCodes[j]) {
                            throw new PackageManagerException(-25, "Update split " + splitName + " revision code " + after.splitRevisionCodes[i] + " is older than current " + before.splitRevisionCodes[j]);
                        }
                    }
                }
            }
        }
    }

    /* access modifiers changed from: private */
    public static class MoveCallbacks extends Handler {
        private static final int MSG_CREATED = 1;
        private static final int MSG_STATUS_CHANGED = 2;
        private final RemoteCallbackList<IPackageMoveObserver> mCallbacks = new RemoteCallbackList<>();
        /* access modifiers changed from: private */
        public final SparseIntArray mLastStatus = new SparseIntArray();

        public MoveCallbacks(Looper looper) {
            super(looper);
        }

        public void register(IPackageMoveObserver callback) {
            this.mCallbacks.register(callback);
        }

        public void unregister(IPackageMoveObserver callback) {
            this.mCallbacks.unregister(callback);
        }

        public void handleMessage(Message msg) {
            SomeArgs args = (SomeArgs) msg.obj;
            int n = this.mCallbacks.beginBroadcast();
            for (int i = 0; i < n; i++) {
                try {
                    invokeCallback(this.mCallbacks.getBroadcastItem(i), msg.what, args);
                } catch (RemoteException e) {
                }
            }
            this.mCallbacks.finishBroadcast();
            args.recycle();
        }

        private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException {
            if (what == 1) {
                callback.onCreated(args.argi1, (Bundle) args.arg2);
            } else if (what == 2) {
                callback.onStatusChanged(args.argi1, args.argi2, ((Long) args.arg3).longValue());
            }
        }

        /* access modifiers changed from: private */
        public void notifyCreated(int moveId, Bundle extras) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " created " + extras.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(1, args).sendToTarget();
        }

        /* access modifiers changed from: private */
        public void notifyStatusChanged(int moveId, int status) {
            notifyStatusChanged(moveId, status, -1);
        }

        /* access modifiers changed from: private */
        public void notifyStatusChanged(int moveId, int status, long estMillis) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " status " + status);
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.argi2 = status;
            args.arg3 = Long.valueOf(estMillis);
            obtainMessage(2, args).sendToTarget();
            synchronized (this.mLastStatus) {
                this.mLastStatus.put(moveId, status);
            }
        }
    }

    /* access modifiers changed from: private */
    public static final class OnPermissionChangeListeners extends Handler {
        private static final int MSG_ON_PERMISSIONS_CHANGED = 1;
        private final RemoteCallbackList<IOnPermissionsChangeListener> mPermissionListeners = new RemoteCallbackList<>();

        public OnPermissionChangeListeners(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            if (msg.what == 1) {
                handleOnPermissionsChanged(msg.arg1);
            }
        }

        public void addListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.register(listener);
        }

        public void removeListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.unregister(listener);
        }

        public void onPermissionsChanged(int uid) {
            if (this.mPermissionListeners.getRegisteredCallbackCount() > 0) {
                obtainMessage(1, uid, 0).sendToTarget();
            }
        }

        private void handleOnPermissionsChanged(int uid) {
            int count = this.mPermissionListeners.beginBroadcast();
            int i = 0;
            while (i < count) {
                try {
                    try {
                        this.mPermissionListeners.getBroadcastItem(i).onPermissionsChanged(uid);
                    } catch (RemoteException e) {
                        Log.e(PackageManagerService.TAG, "Permission listener is dead", e);
                    }
                    i++;
                } catch (Throwable th) {
                    this.mPermissionListeners.finishBroadcast();
                    throw th;
                }
            }
            this.mPermissionListeners.finishBroadcast();
        }
    }

    private class PackageManagerNative extends IPackageManagerNative.Stub {
        private PackageManagerNative() {
        }

        public String[] getNamesForUids(int[] uids) throws RemoteException {
            String[] results = PackageManagerService.this.getNamesForUids(uids);
            for (int i = results.length - 1; i >= 0; i--) {
                if (results[i] == null) {
                    results[i] = "";
                }
            }
            return results;
        }

        public String getInstallerForPackage(String packageName) throws RemoteException {
            String installerName = PackageManagerService.this.getInstallerPackageName(packageName);
            if (!TextUtils.isEmpty(installerName)) {
                return installerName;
            }
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo == null || (appInfo.flags & 1) == 0) {
                return "";
            }
            return "preload";
        }

        public long getVersionCodeForPackage(String packageName) throws RemoteException {
            try {
                PackageInfo pInfo = PackageManagerService.this.getPackageInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
                if (pInfo != null) {
                    return pInfo.getLongVersionCode();
                }
                return 0;
            } catch (Exception e) {
                return 0;
            }
        }

        public int getTargetSdkVersionForPackage(String packageName) throws RemoteException {
            ApplicationInfo info = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (info != null) {
                return info.targetSdkVersion;
            }
            throw new RemoteException("Couldn't get ApplicationInfo for package " + packageName);
        }

        public boolean[] isAudioPlaybackCaptureAllowed(String[] packageNames) throws RemoteException {
            int callingUser = UserHandle.getUserId(Binder.getCallingUid());
            boolean[] results = new boolean[packageNames.length];
            for (int i = results.length - 1; i >= 0; i--) {
                boolean z = false;
                ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageNames[i], 0, callingUser);
                if (appInfo != null) {
                    z = appInfo.isAudioPlaybackCaptureAllowed();
                }
                results[i] = z;
            }
            return results;
        }

        public int getLocationFlags(String packageName) throws RemoteException {
            int i = 0;
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo != null) {
                int isSystemApp = appInfo.isSystemApp() | (appInfo.isVendor() ? 2 : 0);
                if (appInfo.isProduct()) {
                    i = 4;
                }
                return i | isSystemApp;
            }
            throw new RemoteException("Couldn't get ApplicationInfo for package " + packageName);
        }

        public String getModuleMetadataPackageName() throws RemoteException {
            return PackageManagerService.this.mModuleInfoProvider.getPackageName();
        }
    }

    private class PackageManagerInternalImpl extends PackageManagerInternal {
        private PackageManagerInternalImpl() {
        }

        public void updatePermissionFlagsTEMP(String permName, String packageName, int flagMask, int flagValues, int userId) {
            PackageManagerService.this.updatePermissionFlags(permName, packageName, flagMask, flagValues, true, userId);
        }

        public List<ApplicationInfo> getInstalledApplications(int flags, int userId, int callingUid) {
            return PackageManagerService.this.getInstalledApplicationsListInternal(flags, userId, callingUid);
        }

        public boolean isPlatformSigned(String packageName) {
            PackageParser.Package pkg;
            PackageSetting packageSetting = PackageManagerService.this.mSettings.mPackages.get(packageName);
            if (packageSetting == null || (pkg = packageSetting.pkg) == null) {
                return false;
            }
            if (pkg.mSigningDetails.hasAncestorOrSelf(PackageManagerService.this.mPlatformPackage.mSigningDetails) || PackageManagerService.this.mPlatformPackage.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                return true;
            }
            return false;
        }

        public boolean isDataRestoreSafe(byte[] restoringFromSigHash, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasSha256Certificate(restoringFromSigHash, 1);
        }

        public boolean isDataRestoreSafe(Signature restoringFromSig, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasCertificate(restoringFromSig, 1);
        }

        public boolean hasSignatureCapability(int serverUid, int clientUid, @PackageParser.SigningDetails.CertCapabilities int capability) {
            PackageParser.SigningDetails serverSigningDetails = getSigningDetails(serverUid);
            PackageParser.SigningDetails clientSigningDetails = getSigningDetails(clientUid);
            return serverSigningDetails.checkCapability(clientSigningDetails, capability) || clientSigningDetails.hasAncestorOrSelf(serverSigningDetails);
        }

        private PackageParser.SigningDetails getSigningDetails(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null) {
                    return null;
                }
                return p.mSigningDetails;
            }
        }

        private PackageParser.SigningDetails getSigningDetails(int uid) {
            synchronized (PackageManagerService.this.mPackages) {
                Object obj = PackageManagerService.this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        return ((SharedUserSetting) obj).signatures.mSigningDetails;
                    } else if (obj instanceof PackageSetting) {
                        return ((PackageSetting) obj).signatures.mSigningDetails;
                    }
                }
                return PackageParser.SigningDetails.UNKNOWN;
            }
        }

        public int getPermissionFlagsTEMP(String permName, String packageName, int userId) {
            return PackageManagerService.this.getPermissionFlags(permName, packageName, userId);
        }

        public boolean isInstantApp(String packageName, int userId) {
            return PackageManagerService.this.isInstantApp(packageName, userId);
        }

        public String getInstantAppPackageName(int uid) {
            return PackageManagerService.this.getInstantAppPackageName(uid);
        }

        public boolean filterAppAccess(PackageParser.Package pkg, int callingUid, int userId) {
            boolean access$6300;
            synchronized (PackageManagerService.this.mPackages) {
                access$6300 = PackageManagerService.this.filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, userId);
            }
            return access$6300;
        }

        public PackageParser.Package getPackage(String packageName) {
            PackageParser.Package r1;
            synchronized (PackageManagerService.this.mPackages) {
                r1 = PackageManagerService.this.mPackages.get(PackageManagerService.this.resolveInternalPackageNameLPr(packageName, -1));
            }
            return r1;
        }

        public PackageList getPackageList(PackageManagerInternal.PackageListObserver observer) {
            PackageList packageList;
            synchronized (PackageManagerService.this.mPackages) {
                int N = PackageManagerService.this.mPackages.size();
                ArrayList<String> list = new ArrayList<>(N);
                for (int i = 0; i < N; i++) {
                    list.add(PackageManagerService.this.mPackages.keyAt(i));
                }
                packageList = new PackageList(list, observer);
                if (observer != null) {
                    PackageManagerService.this.mPackageListObservers.add(packageList);
                }
            }
            return packageList;
        }

        public void removePackageListObserver(PackageManagerInternal.PackageListObserver observer) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mPackageListObservers.remove(observer);
            }
        }

        public PackageParser.Package getDisabledSystemPackage(String packageName) {
            PackageParser.Package r2;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(packageName);
                r2 = ps != null ? ps.pkg : null;
            }
            return r2;
        }

        public String getDisabledSystemPackageName(String packageName) {
            PackageParser.Package pkg = getDisabledSystemPackage(packageName);
            if (pkg == null) {
                return null;
            }
            return pkg.packageName;
        }

        public String getKnownPackageName(int knownPackage, int userId) {
            switch (knownPackage) {
                case 0:
                    return PackageManagerService.PLATFORM_PACKAGE_NAME;
                case 1:
                    return PackageManagerService.this.mSetupWizardPackage;
                case 2:
                    return PackageManagerService.this.mRequiredInstallerPackage;
                case 3:
                    return PackageManagerService.this.mRequiredVerifierPackage;
                case 4:
                    return PackageManagerService.this.getDefaultBrowserPackageName(userId);
                case 5:
                    return PackageManagerService.this.mSystemTextClassifierPackage;
                case 6:
                    return PackageManagerService.this.mRequiredPermissionControllerPackage;
                case 7:
                    return PackageManagerService.this.mWellbeingPackage;
                case 8:
                    return PackageManagerService.this.mDocumenterPackage;
                case 9:
                    return PackageManagerService.this.mConfiguratorPackage;
                case 10:
                    return PackageManagerService.this.mIncidentReportApproverPackage;
                case 11:
                    return PackageManagerService.this.mAppPredictionServicePackage;
                default:
                    return null;
            }
        }

        public boolean isResolveActivityComponent(ComponentInfo component) {
            return PackageManagerService.this.mResolveActivity.packageName.equals(component.packageName) && PackageManagerService.this.mResolveActivity.name.equals(component.name);
        }

        public void setLocationPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationPackagesProvider(provider);
        }

        public void setLocationExtraPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationExtraPackagesProvider(provider);
        }

        public void setVoiceInteractionPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setVoiceInteractionPackagesProvider(provider);
        }

        public void setUseOpenWifiAppPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setUseOpenWifiAppPackagesProvider(provider);
        }

        public void setSyncAdapterPackagesprovider(PackageManagerInternal.SyncAdapterPackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSyncAdapterPackagesProvider(provider);
        }

        public void grantDefaultPermissionsToDefaultUseOpenWifiApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultUseOpenWifiApp(packageName, userId);
        }

        public void setKeepUninstalledPackages(List<String> packageList) {
            Preconditions.checkNotNull(packageList);
            List<String> removedFromList = null;
            synchronized (PackageManagerService.this.mPackages) {
                if (PackageManagerService.this.mKeepUninstalledPackages != null) {
                    int packagesCount = PackageManagerService.this.mKeepUninstalledPackages.size();
                    for (int i = 0; i < packagesCount; i++) {
                        String oldPackage = (String) PackageManagerService.this.mKeepUninstalledPackages.get(i);
                        if (packageList == null || !packageList.contains(oldPackage)) {
                            if (removedFromList == null) {
                                removedFromList = new ArrayList<>();
                            }
                            removedFromList.add(oldPackage);
                        }
                    }
                }
                List unused = PackageManagerService.this.mKeepUninstalledPackages = new ArrayList(packageList);
                if (removedFromList != null) {
                    int removedCount = removedFromList.size();
                    for (int i2 = 0; i2 < removedCount; i2++) {
                        PackageManagerService.this.deletePackageIfUnusedLPr(removedFromList.get(i2));
                    }
                }
            }
        }

        public boolean isPermissionsReviewRequired(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                if (pkg == null) {
                    return false;
                }
                return PackageManagerService.this.mPermissionManager.isPermissionsReviewRequired(pkg, userId);
            }
        }

        public PackageInfo getPackageInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getPackageInfoInternal(packageName, -1, flags, filterCallingUid, userId);
        }

        public Bundle getSuspendedPackageLauncherExtras(String packageName, int userId) {
            Bundle bundle;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                PersistableBundle launcherExtras = null;
                if (ps != null) {
                    launcherExtras = ps.readUserState(userId).suspendedLauncherExtras;
                }
                bundle = launcherExtras != null ? new Bundle(launcherExtras.deepCopy()) : null;
            }
            return bundle;
        }

        public boolean isPackageSuspended(String packageName, int userId) {
            boolean suspended;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                suspended = ps != null ? ps.getSuspended(userId) : false;
            }
            return suspended;
        }

        public String getSuspendingPackage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).suspendingPackage : null;
            }
            return str;
        }

        public SuspendDialogInfo getSuspendedDialogInfo(String suspendedPackage, int userId) {
            SuspendDialogInfo suspendDialogInfo;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                suspendDialogInfo = ps != null ? ps.readUserState(userId).dialogInfo : null;
            }
            return suspendDialogInfo;
        }

        public int getDistractingPackageRestrictions(String packageName, int userId) {
            int distractionFlags;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                distractionFlags = ps != null ? ps.getDistractionFlags(userId) : 0;
            }
            return distractionFlags;
        }

        public int getPackageUid(String packageName, int flags, int userId) {
            return PackageManagerService.this.getPackageUid(packageName, flags, userId);
        }

        public ApplicationInfo getApplicationInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        public ActivityInfo getActivityInfo(ComponentName component, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getActivityInfoInternal(component, flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, int filterCallingUid, int userId) {
            String resolvedType = intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver());
            List<ResolveInfo> result = PackageManagerService.this.queryIntentActivitiesInternal(intent, resolvedType, flags, filterCallingUid, userId, false, true);
            PackageManagerService.mHwPMSEx.filterResolveInfo(intent, resolvedType, result);
            return result;
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, resolvedType, flags, filterCallingUid, userId, false, true);
        }

        public List<ResolveInfo> queryIntentServices(Intent intent, int flags, int callingUid, int userId) {
            return PackageManagerService.this.queryIntentServicesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, userId, callingUid, false);
        }

        public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
            return PackageManagerService.this.getHomeActivitiesAsUser(allHomeCandidates, userId);
        }

        public ComponentName getDefaultHomeActivity(int userId) {
            return PackageManagerService.this.getDefaultHomeActivity(userId);
        }

        public void setDeviceAndProfileOwnerPackages(int deviceOwnerUserId, String deviceOwnerPackage, SparseArray<String> profileOwnerPackages) {
            PackageManagerService.this.mProtectedPackages.setDeviceAndProfileOwnerPackages(deviceOwnerUserId, deviceOwnerPackage, profileOwnerPackages);
            ArraySet<Integer> usersWithPoOrDo = new ArraySet<>();
            if (deviceOwnerPackage != null) {
                usersWithPoOrDo.add(Integer.valueOf(deviceOwnerUserId));
            }
            int sz = profileOwnerPackages.size();
            for (int i = 0; i < sz; i++) {
                if (profileOwnerPackages.valueAt(i) != null) {
                    usersWithPoOrDo.add(Integer.valueOf(profileOwnerPackages.keyAt(i)));
                }
            }
            PackageManagerService.this.unsuspendForNonSystemSuspendingPackages(usersWithPoOrDo);
        }

        public boolean isPackageDataProtected(int userId, String packageName) {
            return PackageManagerService.this.mProtectedPackages.isPackageDataProtected(userId, packageName);
        }

        public boolean isPackageStateProtected(String packageName, int userId) {
            return PackageManagerService.this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }

        public boolean isPackageEphemeral(int userId, String packageName) {
            boolean instantApp;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                instantApp = ps != null ? ps.getInstantApp(userId) : false;
            }
            return instantApp;
        }

        public boolean wasPackageEverLaunched(String packageName, int userId) {
            boolean wasPackageEverLaunchedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                wasPackageEverLaunchedLPr = PackageManagerService.this.mSettings.wasPackageEverLaunchedLPr(packageName, userId);
            }
            return wasPackageEverLaunchedLPr;
        }

        public boolean isEnabledAndMatches(ComponentInfo info, int flags, int userId) {
            boolean isEnabledAndMatchLPr;
            synchronized (PackageManagerService.this.mPackages) {
                isEnabledAndMatchLPr = PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info, flags, userId);
            }
            return isEnabledAndMatchLPr;
        }

        public boolean userNeedsBadging(int userId) {
            boolean access$7300;
            synchronized (PackageManagerService.this.mPackages) {
                access$7300 = PackageManagerService.this.userNeedsBadging(userId);
            }
            return access$7300;
        }

        public void grantRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.grantRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public void revokeRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.revokeRuntimePermission(permName, packageName, overridePolicy, userId, PackageManagerService.this.mPermissionCallback);
        }

        public String getNameForUid(int uid) {
            return PackageManagerService.this.getNameForUid(uid);
        }

        public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
            PackageManagerService.this.requestInstantAppResolutionPhaseTwo(responseObj, origIntent, resolvedType, callingPackage, verificationBundle, userId);
        }

        public void grantEphemeralAccess(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mInstantAppRegistry.grantInstantAccessLPw(userId, intent, targetAppId, ephemeralAppId);
            }
        }

        public boolean isInstantAppInstallerComponent(ComponentName component) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                z = PackageManagerService.this.mInstantAppInstallerActivity != null && PackageManagerService.this.mInstantAppInstallerActivity.getComponentName().equals(component);
            }
            return z;
        }

        public void pruneInstantApps() {
            PackageManagerService.this.mInstantAppRegistry.pruneInstantApps();
        }

        public String getSetupWizardPackageName() {
            return PackageManagerService.this.mSetupWizardPackage;
        }

        public void setExternalSourcesPolicy(PackageManagerInternal.ExternalSourcesPolicy policy) {
            if (policy != null) {
                PackageManagerService.this.mExternalSourcesPolicy = policy;
            }
        }

        public boolean isPackagePersistent(String packageName) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                z = false;
                if (pkg != null && (pkg.applicationInfo.flags & 9) == 9) {
                    z = true;
                }
            }
            return z;
        }

        public boolean isLegacySystemApp(PackageParser.Package pkg) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) pkg.mExtras;
                z = PackageManagerService.this.mPromoteSystemApps && ps.isSystem() && PackageManagerService.this.mExistingSystemPackages.contains(ps.name);
            }
            return z;
        }

        public List<PackageInfo> getOverlayPackages(int userId) {
            PackageInfo pkg;
            ArrayList<PackageInfo> overlayPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (!(p.mOverlayTarget == null || (pkg = PackageManagerService.this.generatePackageInfo((PackageSetting) p.mExtras, 0, userId)) == null)) {
                        overlayPackages.add(pkg);
                    }
                }
            }
            return overlayPackages;
        }

        public List<String> getTargetPackageNames(int userId) {
            List<String> targetPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget == null) {
                        targetPackages.add(p.packageName);
                    }
                }
            }
            return targetPackages;
        }

        public boolean setEnabledOverlayPackages(int userId, String targetPackageName, List<String> overlayPackageNames) {
            synchronized (PackageManagerService.this.mPackages) {
                if (targetPackageName != null) {
                    if (PackageManagerService.this.mPackages.get(targetPackageName) != null) {
                        ArrayList<String> overlayPaths = null;
                        if (overlayPackageNames != null && overlayPackageNames.size() > 0) {
                            int N = overlayPackageNames.size();
                            overlayPaths = new ArrayList<>(N);
                            for (int i = 0; i < N; i++) {
                                String packageName = overlayPackageNames.get(i);
                                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                                if (pkg == null) {
                                    Slog.e(PackageManagerService.TAG, "failed to find package " + packageName);
                                    return false;
                                }
                                overlayPaths.add(pkg.baseCodePath);
                            }
                        }
                        PackageManagerService.this.mSettings.mPackages.get(targetPackageName).setOverlayPaths(overlayPaths, userId);
                        return true;
                    }
                }
                Slog.e(PackageManagerService.TAG, "failed to find package " + targetPackageName);
                return false;
            }
        }

        public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, resolveForStart, filterCallingUid);
        }

        public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
            return PackageManagerService.this.resolveServiceInternal(intent, resolvedType, flags, userId, callingUid);
        }

        public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
            return PackageManagerService.this.resolveContentProviderInternal(name, flags, userId);
        }

        public void addIsolatedUid(int isolatedUid, int ownerUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.put(isolatedUid, ownerUid);
            }
        }

        public void removeIsolatedUid(int isolatedUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.delete(isolatedUid);
            }
        }

        public boolean isInMWPortraitWhiteList(String packageName) {
            return PackageManagerService.mHwPMSEx.isInMWPortraitWhiteList(packageName);
        }

        public int getUidTargetSdkVersion(int uid) {
            int access$8000;
            synchronized (PackageManagerService.this.mPackages) {
                access$8000 = PackageManagerService.this.getUidTargetSdkVersionLockedLPr(uid);
            }
            return access$8000;
        }

        public int getPackageTargetSdkVersion(String packageName) {
            int access$8100;
            synchronized (PackageManagerService.this.mPackages) {
                access$8100 = PackageManagerService.this.getPackageTargetSdkVersionLockedLPr(packageName);
            }
            return access$8100;
        }

        public boolean canAccessInstantApps(int callingUid, int userId) {
            return PackageManagerService.this.canViewInstantApps(callingUid, userId);
        }

        public boolean canAccessComponent(int callingUid, ComponentName component, int userId) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(component.getPackageName());
                z = ps != null && !PackageManagerService.this.filterAppAccessLPr(ps, callingUid, component, 0, userId);
            }
            return z;
        }

        public boolean hasInstantApplicationMetadata(String packageName, int userId) {
            boolean hasInstantApplicationMetadataLPr;
            synchronized (PackageManagerService.this.mPackages) {
                hasInstantApplicationMetadataLPr = PackageManagerService.this.mInstantAppRegistry.hasInstantApplicationMetadataLPr(packageName, userId);
            }
            return hasInstantApplicationMetadataLPr;
        }

        public void notifyPackageUse(String packageName, int reason) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.notifyPackageUseLocked(packageName, reason);
            }
        }

        public PackageManagerInternal.CheckPermissionDelegate getCheckPermissionDelegate() {
            PackageManagerInternal.CheckPermissionDelegate checkPermissionDelegateLocked;
            synchronized (PackageManagerService.this.mPackages) {
                checkPermissionDelegateLocked = PackageManagerService.this.getCheckPermissionDelegateLocked();
            }
            return checkPermissionDelegateLocked;
        }

        public void setCheckPermissionDelegate(PackageManagerInternal.CheckPermissionDelegate delegate) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.setCheckPermissionDelegateLocked(delegate);
            }
        }

        public SparseArray<String> getAppsWithSharedUserIds() {
            SparseArray<String> access$8500;
            synchronized (PackageManagerService.this.mPackages) {
                access$8500 = PackageManagerService.this.getAppsWithSharedUserIdsLocked();
            }
            return access$8500;
        }

        public String getSharedUserIdForPackage(String packageName) {
            String access$8600;
            synchronized (PackageManagerService.this.mPackages) {
                access$8600 = PackageManagerService.this.getSharedUserIdForPackageLocked(packageName);
            }
            return access$8600;
        }

        public String[] getPackagesForSharedUserId(String sharedUserId, int userId) {
            String[] access$8700;
            synchronized (PackageManagerService.this.mPackages) {
                access$8700 = PackageManagerService.this.getPackagesForSharedUserIdLocked(sharedUserId, userId);
            }
            return access$8700;
        }

        public boolean isOnlyCoreApps() {
            return PackageManagerService.this.isOnlyCoreApps();
        }

        public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
            PackageManagerService.this.freeStorage(volumeUuid, bytes, storageFlags);
        }

        public float getUserAspectRatio(String packageName, String aspectName) {
            return PackageManagerService.mHwPMSEx.getApplicationAspectRatio(packageName, aspectName);
        }

        public void checkPackageStartable(String packageName, int userId) {
            PackageManagerService.this.checkPackageStartable(packageName, userId);
        }

        public boolean getHwCertPermission(boolean allowed, PackageParser.Package pkg, String perm) {
            return PackageManagerService.this.getHwCertPermission(allowed, pkg, perm);
        }

        public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) {
            PackageManagerService.mHwPMSEx.installPackageAsUser(originPath, observer, installFlags, installerPackageName, userId);
        }

        public boolean isUpgrade() {
            return PackageManagerService.this.isUpgrade();
        }

        public void forEachPackage(Consumer<PackageParser.Package> actionLocked) {
            PackageManagerService.this.forEachPackage(actionLocked);
        }

        public void forEachInstalledPackage(Consumer<PackageParser.Package> actionLocked, int userId) {
            PackageManagerService.this.forEachInstalledPackage(actionLocked, userId);
        }

        public ArraySet<String> getEnabledComponents(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return new ArraySet<>();
                }
                return setting.getEnabledComponents(userId);
            }
        }

        public ArraySet<String> getDisabledComponents(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return new ArraySet<>();
                }
                return setting.getDisabledComponents(userId);
            }
        }

        public int getApplicationEnabledState(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return 0;
                }
                return setting.getEnabled(userId);
            }
        }

        public void setEnableRollbackCode(int token, int enableRollbackCode) {
            PackageManagerService.this.setEnableRollbackCode(token, enableRollbackCode);
        }

        public boolean compileLayouts(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                if (pkg == null) {
                    return false;
                }
                return PackageManagerService.this.mArtManagerService.compileLayouts(pkg);
            }
        }

        public void finishPackageInstall(int token, boolean didLaunch) {
            PackageManagerService.this.finishPackageInstall(token, didLaunch);
        }

        public String removeLegacyDefaultBrowserPackageName(int userId) {
            String removeDefaultBrowserPackageNameLPw;
            synchronized (PackageManagerService.this.mPackages) {
                removeDefaultBrowserPackageNameLPw = PackageManagerService.this.mSettings.removeDefaultBrowserPackageNameLPw(userId);
            }
            return removeDefaultBrowserPackageNameLPw;
        }

        public void setDefaultBrowserProvider(PackageManagerInternal.DefaultBrowserProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerInternal.DefaultBrowserProvider unused = PackageManagerService.this.mDefaultBrowserProvider = provider;
            }
        }

        public void setDefaultDialerProvider(PackageManagerInternal.DefaultDialerProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerInternal.DefaultDialerProvider unused = PackageManagerService.this.mDefaultDialerProvider = provider;
            }
        }

        public void setDefaultHomeProvider(PackageManagerInternal.DefaultHomeProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerInternal.DefaultHomeProvider unused = PackageManagerService.this.mDefaultHomeProvider = provider;
            }
        }

        public boolean isApexPackage(String packageName) {
            return PackageManagerService.this.mApexManager.isApexPackage(packageName);
        }

        public void uninstallApex(String packageName, long versionCode, int userId, IntentSender intentSender) {
            int callerUid = Binder.getCallingUid();
            if (callerUid == 0 || callerUid == 2000) {
                PackageInstallerService.PackageDeleteObserverAdapter adapter = new PackageInstallerService.PackageDeleteObserverAdapter(PackageManagerService.this.mContext, intentSender, packageName, false, userId);
                if (userId != -1) {
                    adapter.onPackageDeleted(packageName, -5, "Can't uninstall an apex for a single user");
                    return;
                }
                ApexManager am = PackageManagerService.this.mApexManager;
                PackageInfo activePackage = am.getPackageInfo(packageName, 1);
                if (activePackage == null) {
                    adapter.onPackageDeleted(packageName, -5, packageName + " is not an apex package");
                } else if (versionCode != -1 && activePackage.getLongVersionCode() != versionCode) {
                    adapter.onPackageDeleted(packageName, -5, "Active version " + activePackage.getLongVersionCode() + " is not equal to " + versionCode + "]");
                } else if (!am.uninstallApex(activePackage.applicationInfo.sourceDir)) {
                    adapter.onPackageDeleted(packageName, -5, "Failed to uninstall apex " + packageName);
                } else {
                    adapter.onPackageDeleted(packageName, 1, null);
                }
            } else {
                throw new SecurityException("Not allowed to uninstall apexes");
            }
        }

        public boolean wereDefaultPermissionsGrantedSinceBoot(int userId) {
            boolean wereDefaultPermissionsGrantedSinceBoot;
            synchronized (PackageManagerService.this.mPackages) {
                wereDefaultPermissionsGrantedSinceBoot = PackageManagerService.this.mDefaultPermissionPolicy.wereDefaultPermissionsGrantedSinceBoot(userId);
            }
            return wereDefaultPermissionsGrantedSinceBoot;
        }

        public void setRuntimePermissionsFingerPrint(String fingerPrint, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.setRuntimePermissionsFingerPrintLPr(fingerPrint, userId);
            }
        }

        public void migrateLegacyObbData() {
            new Thread(new Runnable() {
                /* class com.android.server.pm.PackageManagerService.PackageManagerInternalImpl.AnonymousClass1 */

                public void run() {
                    try {
                        PackageManagerService.this.mInstaller.migrateLegacyObbData();
                    } catch (Exception e) {
                        Slog.wtf(PackageManagerService.TAG, e);
                    }
                }
            }).start();
        }

        public boolean isSystemAppGrantByMdmAndNonPreload(String pkgName) {
            PackageSetting pkgSetting;
            if (TextUtils.isEmpty(pkgName) || (pkgSetting = PackageManagerService.this.mSettings.mPackages.get(pkgName)) == null) {
                return false;
            }
            PackageManagerService packageManagerService = PackageManagerService.this;
            return PackageManagerService.isSystemAppGrantByMdmAndNonPreload(pkgSetting.name, pkgSetting.codePathString, pkgSetting.volumeUuid);
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public SparseArray<String> getAppsWithSharedUserIdsLocked() {
        SparseArray<String> sharedUserIds = new SparseArray<>();
        synchronized (this.mPackages) {
            for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
                sharedUserIds.put(UserHandle.getAppId(setting.userId), setting.name);
            }
        }
        return sharedUserIds;
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public String getSharedUserIdForPackageLocked(String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps == null || !ps.isSharedUser()) {
            return null;
        }
        return ps.sharedUser.name;
    }

    /* access modifiers changed from: private */
    @GuardedBy({"mPackages"})
    public String[] getPackagesForSharedUserIdLocked(String sharedUserId, int userId) {
        try {
            int i = 0;
            SharedUserSetting sus = this.mSettings.getSharedUserLPw(sharedUserId, 0, 0, false);
            if (sus == null) {
                return EmptyArray.STRING;
            }
            String[] res = new String[sus.packages.size()];
            Iterator<PackageSetting> it = sus.packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.getInstalled(userId)) {
                    res[i] = ps.name;
                    i++;
                } else {
                    res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                }
            }
            return res;
        } catch (PackageManagerException e) {
            return EmptyArray.STRING;
        }
    }

    public int getRuntimePermissionsVersion(int userId) {
        int defaultRuntimePermissionsVersionLPr;
        Preconditions.checkArgumentNonnegative(userId);
        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "setRuntimePermissionVersion");
        synchronized (this.mPackages) {
            defaultRuntimePermissionsVersionLPr = this.mSettings.getDefaultRuntimePermissionsVersionLPr(userId);
        }
        return defaultRuntimePermissionsVersionLPr;
    }

    public void setRuntimePermissionsVersion(int version, int userId) {
        Preconditions.checkArgumentNonnegative(version);
        Preconditions.checkArgumentNonnegative(userId);
        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "setRuntimePermissionVersion");
        synchronized (this.mPackages) {
            this.mSettings.setDefaultRuntimePermissionsVersionLPr(version, userId);
        }
    }

    public void grantDefaultPermissionsToEnabledCarrierApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantPermissionsToEnabledCarrierApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledCarrierApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledImsServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledImsServices");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledImsServices(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$CY19imJrnYUo8jf5_WmTKjYLeUw */
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.lambda$grantDefaultPermissionsToEnabledTelephonyDataServices$37$PackageManagerService(this.f$1, this.f$2);
                }
            });
        }
    }

    public /* synthetic */ void lambda$grantDefaultPermissionsToEnabledTelephonyDataServices$37$PackageManagerService(String[] packageNames, int userId) throws Exception {
        this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledTelephonyDataServices(packageNames, userId);
    }

    public void revokeDefaultPermissionsFromDisabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromDisabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$CgkIOYHp_LKWGsICQ3imidPsPFA */
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.lambda$revokeDefaultPermissionsFromDisabledTelephonyDataServices$38$PackageManagerService(this.f$1, this.f$2);
                }
            });
        }
    }

    public /* synthetic */ void lambda$revokeDefaultPermissionsFromDisabledTelephonyDataServices$38$PackageManagerService(String[] packageNames, int userId) throws Exception {
        this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromDisabledTelephonyDataServices(packageNames, userId);
    }

    public void grantDefaultPermissionsToActiveLuiApp(String packageName, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToActiveLuiApp");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToActiveLuiApp(packageName, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void revokeDefaultPermissionsFromLuiApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromLuiApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromLuiApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void forEachPackage(Consumer<PackageParser.Package> actionLocked) {
        synchronized (this.mPackages) {
            int numPackages = this.mPackages.size();
            for (int i = 0; i < numPackages; i++) {
                actionLocked.accept(this.mPackages.valueAt(i));
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void forEachInstalledPackage(Consumer<PackageParser.Package> actionLocked, int userId) {
        synchronized (this.mPackages) {
            int numPackages = this.mPackages.size();
            for (int i = 0; i < numPackages; i++) {
                PackageParser.Package pkg = this.mPackages.valueAt(i);
                PackageSetting setting = this.mSettings.getPackageLPr(pkg.packageName);
                if (setting != null) {
                    if (setting.getInstalled(userId)) {
                        actionLocked.accept(pkg);
                    }
                }
            }
        }
    }

    private static void enforceSystemOrPhoneCaller(String tag) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 1001 && callingUid != 1000) {
            throw new SecurityException("Cannot call " + tag + " from UID " + callingUid);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isHistoricalPackageUsageAvailable() {
        return this.mPackageUsage.isHistoricalPackageUsageAvailable();
    }

    /* access modifiers changed from: package-private */
    public Collection<PackageParser.Package> getPackages() {
        ArrayList arrayList;
        synchronized (this.mPackages) {
            arrayList = new ArrayList(this.mPackages.values());
        }
        return arrayList;
    }

    public void logAppProcessStartIfNeeded(String processName, int uid, String seinfo, String apkFile, int pid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && SecurityLog.isLoggingEnabled()) {
            Bundle data = new Bundle();
            data.putLong("startTimestamp", System.currentTimeMillis());
            data.putString("processName", processName);
            data.putInt(WatchlistLoggingHandler.WatchlistEventKeys.UID, uid);
            data.putString("seinfo", seinfo);
            data.putString("apkFile", apkFile);
            data.putInt("pid", pid);
            Message msg = this.mProcessLoggingHandler.obtainMessage(1);
            msg.setData(data);
            this.mProcessLoggingHandler.sendMessage(msg);
        }
    }

    public CompilerStats.PackageStats getCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getPackageStats(pkgName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(PackageParser.Package pkg) {
        return getOrCreateCompilerPackageStats(pkg.packageName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getOrCreatePackageStats(pkgName);
    }

    public void deleteCompilerPackageStats(String pkgName) {
        this.mCompilerStats.deletePackageStats(pkgName);
    }

    public int getInstallReason(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "get install reason");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, userId)) {
                return 0;
            }
            if (ps == null) {
                return 0;
            }
            if (isSystemAppGrantByMdmAndNonPreload(ps.name, ps.codePathString, ps.volumeUuid)) {
                return 9;
            }
            return ps.getInstallReason(userId);
        }
    }

    public boolean canRequestPackageInstalls(String packageName, int userId) {
        return canRequestPackageInstallsInternal(packageName, 0, userId, true);
    }

    private boolean canRequestPackageInstallsInternal(String packageName, int flags, int userId, boolean throwIfPermNotDeclared) {
        PackageManagerInternal.ExternalSourcesPolicy externalSourcesPolicy;
        int callingUid = Binder.getCallingUid();
        int uid = getPackageUid(packageName, 0, userId);
        if (callingUid == uid || callingUid == 0 || callingUid == 1000) {
            ApplicationInfo info = getApplicationInfo(packageName, flags, userId);
            if (info == null || info.targetSdkVersion < 26 || isInstantApp(packageName, userId)) {
                return false;
            }
            if (!ArrayUtils.contains(getAppOpPermissionPackages("android.permission.REQUEST_INSTALL_PACKAGES"), packageName)) {
                if (!throwIfPermNotDeclared) {
                    Slog.e(TAG, "Need to declare " + "android.permission.REQUEST_INSTALL_PACKAGES" + " to call this api");
                    return false;
                }
                throw new SecurityException("Need to declare " + "android.permission.REQUEST_INSTALL_PACKAGES" + " to call this api");
            } else if (sUserManager.hasUserRestriction("no_install_unknown_sources", userId) || sUserManager.hasUserRestriction("no_install_unknown_sources_globally", userId) || (externalSourcesPolicy = this.mExternalSourcesPolicy) == null || externalSourcesPolicy.getPackageTrustedToInstallApps(packageName, uid) != 0) {
                return false;
            } else {
                return true;
            }
        } else {
            throw new SecurityException("Caller uid " + callingUid + " does not own package " + packageName);
        }
    }

    /* access modifiers changed from: private */
    public void parseInstalledPkgInfo(InstallArgs args, PackageInstalledInfo res) {
        StringBuilder pkgPath = new StringBuilder(100);
        int pkgInstallResult = 0;
        int pkgVersionCode = 0;
        String pkgVersionName = "";
        String pkgName = "";
        boolean pkgUpdate = false;
        if (!(args == null || args.origin == null || args.origin.file == null)) {
            pkgPath.append(args.origin.file.toString());
            pkgPath.append(";");
        }
        if (!(args == null || args.installerPackageName == null)) {
            pkgPath.append(args.installerPackageName);
        }
        if (res != null) {
            pkgInstallResult = res.returnCode;
            if (res.pkg != null) {
                pkgVersionCode = res.pkg.mVersionCode;
                pkgVersionName = res.pkg.mVersionName;
                if (res.pkg.applicationInfo != null) {
                    pkgName = res.pkg.applicationInfo.packageName;
                }
            }
            if (res.removedInfo != null) {
                pkgUpdate = res.removedInfo.removedPackage != null;
            }
        }
        mHwPMSEx.parseInstalledPkgInfo(pkgPath.toString(), pkgName, pkgVersionName, pkgVersionCode, pkgInstallResult, pkgUpdate);
    }

    public static String getCallingAppName(Context context, PackageParser.Package pkg) {
        PackageManager pm = context.getPackageManager();
        String displayName = pkg.packageName;
        if (pm != null) {
            return String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
        }
        return displayName;
    }

    public ComponentName getInstantAppResolverSettingsComponent() {
        return this.mInstantAppResolverSettingsComponent;
    }

    public ComponentName getInstantAppInstallerComponent() {
        ActivityInfo activityInfo;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && (activityInfo = this.mInstantAppInstallerActivity) != null) {
            return activityInfo.getComponentName();
        }
        return null;
    }

    public String getInstantAppAndroidId(String packageName, int userId) {
        String instantAppAndroidIdLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppAndroidId");
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppAndroidId");
        if (!isInstantApp(packageName, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppAndroidIdLPw = this.mInstantAppRegistry.getInstantAppAndroidIdLPw(packageName, userId);
        }
        return instantAppAndroidIdLPw;
    }

    /* access modifiers changed from: package-private */
    public boolean canHaveOatDir(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null) {
                return false;
            }
            return p.canHaveOatDir();
        }
    }

    private String getOatDir(PackageParser.Package pkg) {
        if (!pkg.canHaveOatDir()) {
            return null;
        }
        File codePath = new File(pkg.codePath);
        if (codePath.isDirectory()) {
            return PackageDexOptimizer.getOatDir(codePath).getAbsolutePath();
        }
        return null;
    }

    /* access modifiers changed from: package-private */
    public void deleteOatArtifactsOfPackage(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(pkg.applicationInfo);
        List<String> codePaths = pkg.getAllCodePaths();
        String oatDir = getOatDir(pkg);
        for (String codePath : codePaths) {
            for (String isa : instructionSets) {
                try {
                    this.mInstaller.deleteOdex(codePath, isa, oatDir);
                } catch (Installer.InstallerException e) {
                    Log.e(TAG, "Failed deleting oat files for " + codePath, e);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public Set<String> getUnusedPackages(long downgradeTimeThresholdMillis) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Set<String> unusedPackages = new HashSet<>();
        long currentTimeInMillis = System.currentTimeMillis();
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                Iterator<PackageParser.Package> it = this.mPackages.values().iterator();
                while (it.hasNext()) {
                    PackageParser.Package pkg = it.next();
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null) {
                        arrayMap = arrayMap2;
                        if (PackageManagerServiceUtils.isUnusedSinceTimeInMillis(ps.firstInstallTime, currentTimeInMillis, downgradeTimeThresholdMillis, getDexManager().getPackageUseInfoOrDefault(pkg.packageName), pkg.getLatestPackageUseTimeInMills(), pkg.getLatestForegroundPackageUseTimeInMills())) {
                            unusedPackages.add(pkg.packageName);
                        }
                        arrayMap2 = arrayMap;
                        it = it;
                    }
                }
                return unusedPackages;
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private static boolean isSystemAppGrantByMdmAndNonPreload(PackageParser.Package pkg) {
        if (MDM_SYS_APP_PREALOAD_LIST.containsKey(pkg.packageName) || TextUtils.isEmpty(pkg.codePath)) {
            return false;
        }
        String str = pkg.codePath;
        if (!str.startsWith(Environment.getDataAppDirectory(pkg.volumeUuid) + SliceClientPermissions.SliceAuthority.DELIMITER) || !mHwPMSEx.isSystemAppGrantByMdm(pkg)) {
            return false;
        }
        return true;
    }

    /* access modifiers changed from: private */
    public static boolean isSystemAppGrantByMdmAndNonPreload(String packageName, String codePath, String volumeUuid) {
        if (MDM_SYS_APP_PREALOAD_LIST.containsKey(packageName) || TextUtils.isEmpty(codePath)) {
            return false;
        }
        if (!codePath.startsWith(Environment.getDataAppDirectory(volumeUuid) + SliceClientPermissions.SliceAuthority.DELIMITER) || !mHwPMSEx.isSystemAppGrantByMdm(packageName)) {
            return false;
        }
        return true;
    }

    public void setHarmfulAppWarning(String packageName, CharSequence warning, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "setHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                this.mSettings.setHarmfulAppWarningLPw(packageName, warning, userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            return;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public CharSequence getHarmfulAppWarning(String packageName, int userId) {
        String harmfulAppWarningLPr;
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "getHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                harmfulAppWarningLPr = this.mSettings.getHarmfulAppWarningLPr(packageName, userId);
            }
            return harmfulAppWarningLPr;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public boolean isPackageStateProtected(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "isPackageStateProtected");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.MANAGE_DEVICE_ADMINS", callingUid) == 0) {
            return this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }
        throw new SecurityException("Caller must have the android.permission.MANAGE_DEVICE_ADMINS permission.");
    }

    public void sendDeviceCustomizationReadyBroadcast() {
        this.mContext.enforceCallingPermission("android.permission.SEND_DEVICE_CUSTOMIZATION_READY", "sendDeviceCustomizationReadyBroadcast");
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent("android.intent.action.DEVICE_CUSTOMIZATION_READY");
            intent.setFlags(DumpState.DUMP_SERVICE_PERMISSIONS);
            try {
                ActivityManager.getService().broadcastIntent((IApplicationThread) null, intent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, new String[]{"android.permission.RECEIVE_DEVICE_CUSTOMIZATION_READY"}, -1, (Bundle) null, false, false, -1);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    static class ActiveInstallSession {
        private final String mInstallerPackageName;
        private final int mInstallerUid;
        private final IPackageInstallObserver2 mObserver;
        private final String mPackageName;
        private final PackageInstaller.SessionParams mSessionParams;
        private final PackageParser.SigningDetails mSigningDetails;
        private final File mStagedDir;
        UserHandle mUser;

        ActiveInstallSession(String packageName, File stagedDir, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, PackageParser.SigningDetails signingDetails) {
            this.mPackageName = packageName;
            this.mStagedDir = stagedDir;
            this.mObserver = observer;
            this.mSessionParams = sessionParams;
            this.mInstallerPackageName = installerPackageName;
            this.mInstallerUid = installerUid;
            this.mUser = user;
            this.mSigningDetails = signingDetails;
        }

        public String getPackageName() {
            return this.mPackageName;
        }

        public File getStagedDir() {
            return this.mStagedDir;
        }

        public IPackageInstallObserver2 getObserver() {
            return this.mObserver;
        }

        public PackageInstaller.SessionParams getSessionParams() {
            return this.mSessionParams;
        }

        public String getInstallerPackageName() {
            return this.mInstallerPackageName;
        }

        public int getInstallerUid() {
            return this.mInstallerUid;
        }

        public UserHandle getUser() {
            return this.mUser;
        }

        public PackageParser.SigningDetails getSigningDetails() {
            return this.mSigningDetails;
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ArrayMap<String, PackageParser.Package> getPackagesLock() {
        return this.mPackages;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public Settings getSettings() {
        return this.mSettings;
    }

    /* JADX WARN: Type inference failed for: r0v0, types: [com.android.server.pm.PackageManagerService$HwInnerPackageManagerService, android.os.IBinder] */
    public IBinder getHwInnerService() {
        return this.mHwInnerService;
    }

    public IHwPackageManagerServiceEx getHwPMSEx() {
        return mHwPMSEx;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getIsDefaultPreferredActivityChangedInner() {
        return this.mIsDefaultPreferredActivityChanged;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getIsDefaultGoogleCalendarInner() {
        return this.mIsDefaultGoogleCalendar;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public HwCustPackageManagerService getHwPMSCustPackageManagerService() {
        return getCustPackageManagerService();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean isFirstBootInner() {
        return isFirstBoot();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public Installer getInstallerInner() {
        return this.mInstaller;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public PackageSetting getPackageSettingByPackageName(String packageName) {
        PackageSetting packageSetting;
        synchronized (this.mPackages) {
            packageSetting = this.mSettings.mPackages.get(packageName);
        }
        return packageSetting;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public String getNameForUidInner(int uid) {
        return getNameForUid(uid);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int checkSignaturesInner(String pkg1, String pkg2) {
        return checkSignatures(pkg1, pkg2);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getCotaFlagInner() {
        return this.mCotaFlag;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void setHwPMSCotaApksInstallStatus(int value) {
        setCotaApksInstallStatus(value);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void scanPackageFilesLIInner(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public HashMap<String, HashSet<String>> getHwPMSCotaDelInstallMap() {
        return getCotaDelInstallMap();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ArrayMap<String, FeatureInfo> getAvailableFeaturesInner() {
        return this.mAvailableFeatures;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ActivityInfo getResolveActivityInner() {
        return this.mResolveActivity;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void setUpCustomResolverActivityInner(PackageParser.Package pkg) {
        setUpCustomResolverActivity(pkg);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public PackageParser.Package scanPackageLIInner(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int installExistingPackageAsUserInternalInner(String packageName, int userId, int installFlags, int installReason) {
        return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason, null, null);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void prepareAppDataAfterInstallLIFInner(PackageParser.Package pkg) {
        prepareAppDataAfterInstallLIF(pkg);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void updateSettingsLIInner(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void updateSharedLibrariesLPrInner(PackageParser.Package pkg, PackageParser.Package changingLib) throws PackageManagerException {
        updateSharedLibrariesLocked(pkg, changingLib, this.mPackages);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public UserManagerInternal getUserManagerInternalInner() {
        return getUserManagerInternal();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void sendPackageBroadcastInner(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast(action, pkg, extras, flags, targetPkg, finishedReceiver, userIds, instantUserIds);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getSystemReadyInner() {
        return this.mSystemReady;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public HashMap<String, HashSet<String>> getHwPMSCotaInstallMap() {
        return getCotaInstallMap();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void killApplicationInner(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, reason);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void removePackageLIInner(PackageParser.Package pkg, boolean chatty) {
        removePackageLI(pkg, chatty);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int deletePackageInner(String packageName, long versionCode, int userId, int deleteFlags) {
        return deletePackageX(packageName, versionCode, userId, deleteFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void scanDirLIInner(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        scanDirLI(scanDir, parseFlags, scanFlags, currentTime, hwFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void assertProvidersNotDefined(PackageParser.Package pkg) throws PackageManagerException {
        this.mComponentResolver.assertProvidersNotDefined(pkg);
    }

    public class HwInnerPackageManagerService extends IHwPackageManager.Stub {
        PackageManagerService mPMS;

        HwInnerPackageManagerService(PackageManagerService pms) {
            this.mPMS = pms;
        }

        public boolean setAllAppsUseSideMode(boolean isUse) {
            return PackageManagerService.mHwPMSEx.setAllAppsUseSideMode(isUse);
        }

        public boolean restoreAllAppsUseSideMode() {
            return PackageManagerService.mHwPMSEx.restoreAllAppsUseSideMode();
        }

        public boolean isAllAppsUseSideMode(List<String> packages) {
            return PackageManagerService.mHwPMSEx.isAllAppsUseSideMode(packages);
        }

        public boolean isPerfOptEnable(String packageName, int optType) {
            return PackageManagerService.mHwPMSEx.isPerfOptEnable(packageName, optType);
        }

        public int getAppUseNotchMode(String packageName) {
            return PackageManagerService.mHwPMSEx.getAppUseNotchMode(packageName);
        }

        public void setAppUseNotchMode(String packageName, int mode) {
            PackageManagerService.mHwPMSEx.setAppUseNotchMode(packageName, mode);
        }

        public int getAppUseSideMode(String packageName) {
            return PackageManagerService.mHwPMSEx.getAppUseSideMode(packageName);
        }

        public void setAppUseSideMode(String packageName, int mode) {
            PackageManagerService.mHwPMSEx.setAppUseSideMode(packageName, mode);
        }

        public void setAppCanUninstall(String packageName, boolean canUninstall) {
            PackageManagerService.mHwPMSEx.setAppCanUninstall(packageName, canUninstall);
        }

        public boolean setApplicationAspectRatio(String packageName, String aspectName, float ar) {
            return PackageManagerService.mHwPMSEx.setApplicationAspectRatio(packageName, aspectName, ar);
        }

        public float getApplicationAspectRatio(String packageName, String aspectName) {
            return PackageManagerService.mHwPMSEx.getApplicationAspectRatio(packageName, aspectName);
        }

        public boolean setForceDarkSetting(List<String> packageNames, int forceDarkMode) {
            return PackageManagerService.mHwPMSEx.setForceDarkSetting(packageNames, forceDarkMode);
        }

        public int getForceDarkSetting(String packageName) {
            return PackageManagerService.mHwPMSEx.getForceDarkSetting(packageName);
        }

        public void setVersionMatchFlag(int deviceType, int version, boolean isMatchSuccess) {
            PackageManagerService.mHwPMSEx.setVersionMatchFlag(deviceType, version, isMatchSuccess);
        }

        public boolean getVersionMatchFlag(int deviceType, int version) {
            return PackageManagerService.mHwPMSEx.getVersionMatchFlag(deviceType, version);
        }

        public void setOpenFileResult(Intent intent, int retCode) {
            PackageManagerService.mHwPMSEx.setOpenFileResult(intent, retCode);
        }

        public int getOpenFileResult(Intent intent) {
            return PackageManagerService.mHwPMSEx.getOpenFileResult(intent);
        }

        public List<String> getPreinstalledApkList() {
            return PackageManagerService.mHwPMSEx.getPreinstalledApkList();
        }

        public List<String> getHwPublicityAppList() {
            return PackageManagerService.mHwPMSEx.getHwPublicityAppList();
        }

        public ParcelFileDescriptor getHwPublicityAppParcelFileDescriptor() {
            return PackageManagerService.mHwPMSEx.getHwPublicityAppParcelFileDescriptor();
        }

        public int startBackupSession(IBackupSessionCallback callback) {
            return PackageManagerService.mHwPMSEx.getStartBackupSession(callback);
        }

        public int executeBackupTask(int sessionId, String taskCmd) {
            return PackageManagerService.mHwPMSEx.getExecuteBackupTask(sessionId, taskCmd);
        }

        public int finishBackupSession(int sessionId) {
            return PackageManagerService.mHwPMSEx.getFinishBackupSession(sessionId);
        }

        public String getResourcePackageNameByIcon(String pkgName, int icon, int userId) {
            return PackageManagerService.mHwPMSEx.getResourcePackageNameByIcon(pkgName, icon, userId);
        }

        public boolean scanInstallApk(String apkFile) {
            return PackageManagerService.mHwPMSEx.scanInstallApk(apkFile);
        }

        public List<String> getScanInstallList() {
            return PackageManagerService.mHwPMSEx.getScanInstallList();
        }

        public void setHdbKey(String key) {
            PackageManagerService.mHwPMSEx.setHdbKey(key);
        }

        public boolean pmInstallHwTheme(String themePath, boolean setwallpaper, int userId) {
            return PackageManagerService.mHwPMSEx.pmInstallHwTheme(themePath, setwallpaper, userId);
        }

        public boolean isMapleEnv() {
            return ZygoteInit.sIsMygote;
        }

        public String readMspesFile(String fileName) {
            return PackageManagerService.mHwPMSEx.readMspesFile(fileName);
        }

        public boolean writeMspesFile(String fileName, String content) {
            return PackageManagerService.mHwPMSEx.writeMspesFile(fileName, content);
        }

        public String getMspesOEMConfig() {
            return PackageManagerService.mHwPMSEx.getMspesOEMConfig();
        }

        public int updateMspesOEMConfig(String src) {
            return PackageManagerService.mHwPMSEx.updateMspesOEMConfig(src);
        }

        public List<String> getSystemWhiteList(String type) {
            return PackageManagerService.mHwPMSEx.getSystemWhiteList(type);
        }

        public boolean shouldSkipTriggerFreeform(String pkgName, int userId) {
            return PackageManagerService.mHwPMSEx.shouldSkipTriggerFreeform(pkgName, userId);
        }

        public int getPrivilegeAppType(String pkgName) {
            return PackageManagerService.mHwPMSEx.getPrivilegeAppType(pkgName);
        }

        public void clearPreferredActivityAsUser(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
            PackageManagerService.mHwPMSEx.clearPreferredActivityAsUser(filter, match, set, activity, userId);
        }

        public void registerExtServiceProvider(IExtServiceProvider extServiceProvider, Intent filter) {
            PackageManagerService.mHwPMSEx.registerExtServiceProvider(extServiceProvider, filter);
        }

        public void unregisterExtServiceProvider(IExtServiceProvider extServiceProvider) {
            PackageManagerService.mHwPMSEx.unregisterExtServiceProvider(extServiceProvider);
        }

        public boolean getMapleEnableFlag(String packageName) {
            PackageSetting ps;
            int callingUid = Binder.getCallingUid();
            String callingApp = PackageManagerService.this.getNameForUid(callingUid);
            synchronized (PackageManagerService.this.mPackages) {
                ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
            }
            StringBuilder sb = new StringBuilder();
            sb.append((ps == null || !ps.isSharedUser()) ? "" : ps.sharedUser.name);
            sb.append(":");
            String sharedUserIdName = sb.toString();
            if (packageName == null || callingApp == null) {
                return false;
            }
            if (callingApp.equals(packageName) || callingApp.startsWith(sharedUserIdName) || callingUid == 1000) {
                return HwMaplePMServiceUtils.getMapleEnableFlag(packageName);
            }
            return false;
        }

        public void setMapleEnableFlag(String packageName, boolean flag) {
            PackageSetting ps;
            int callingUid = Binder.getCallingUid();
            String callingApp = PackageManagerService.this.getNameForUid(callingUid);
            synchronized (PackageManagerService.this.mPackages) {
                ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
            }
            StringBuilder sb = new StringBuilder();
            sb.append((ps == null || !ps.isSharedUser()) ? "" : ps.sharedUser.name);
            sb.append(":");
            String sharedUserIdName = sb.toString();
            if (packageName != null && callingApp != null) {
                if (callingApp.equals(packageName) || callingApp.startsWith(sharedUserIdName) || callingUid == 1000) {
                    HwMaplePMServiceUtils.setMapleEnableFlag(packageName, flag);
                }
            }
        }

        public Bundle[] canGrantDPermissions(Bundle[] bundles) {
            return PackageManagerService.mHwPMSEx.canGrantDPermissions(bundles);
        }

        public Map<String, String> getHwRenamedPackages(int flags) {
            return PackageManagerService.mHwPMSEx.getHwRenamedPackages(flags);
        }

        public List<ApplicationInfo> getClusterApplications(int flags, int clusterMask, boolean isOnlyDisabled) {
            int callingUid = Binder.getCallingUid();
            int userId = UserHandle.getCallingUserId();
            if (PackageManagerService.this.getInstantAppPackageName(callingUid) == null) {
                return PackageManagerService.mHwPMSEx.getClusterApplications(flags, clusterMask, isOnlyDisabled, userId);
            }
            Slog.e(PackageManagerService.TAG, "Instant app can not query cluster Applications!");
            return Collections.emptyList();
        }

        public List<HwHepPackageInfo> getInstalledHep(int flags) {
            if (PackageManagerService.this.getInstantAppPackageName(Binder.getCallingUid()) == null) {
                return PackageManagerService.mHwPMSEx.getInstalledHep(flags);
            }
            Slog.e(PackageManagerService.TAG, "Instant app can not query installed hep information!");
            return Collections.emptyList();
        }

        public int uninstallHep(String packageName, int flags) {
            return PackageManagerService.mHwPMSEx.uninstallHep(packageName, flags);
        }

        public int getDisplayChangeAppRestartConfig(int type, String pkgName) {
            return PackageManagerService.mHwPMSEx.getDisplayChangeAppRestartConfig(type, pkgName);
        }
    }

    public boolean getHwCertPermission(boolean allowed, PackageParser.Package pkg, String perm) {
        return mHwPMSEx.getHwCertPermission(allowed, pkg, perm);
    }

    public void updateAppsUseSideWhitelist(ArrayMap<String, String> compressApps, ArrayMap<String, String> extendApps) {
        mHwPMSEx.updateAppsUseSideWhitelist(compressApps, extendApps);
    }

    public List<String> getAppsUseSideList() {
        return mHwPMSEx.getAppsUseSideList();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public Handler getPackageHandler() {
        return this.mHandler;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public PermissionManagerServiceInternal getPermissionManager() {
        return this.mPermissionManager;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public InstallParams createInstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, PackageParser.SigningDetails signingDetails, int installReason) {
        return new InstallParams(origin, move, observer, installFlags, installerPackageName, volumeUuid, verificationInfo, user, packageAbiOverride, grantedPermissions, null, signingDetails, installReason, -1);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner, com.android.server.pm.AbsPackageManagerService
    public Signature[] getRealSignature(PackageParser.Package pkg) {
        if (pkg == null || !pkg.mRealSigningDetails.hasSignatures()) {
            return new Signature[0];
        }
        return pkg.mRealSigningDetails.signatures;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void setRealSigningDetails(PackageParser.Package pkg, PackageParser.SigningDetails real) {
        if (real != null) {
            pkg.mRealSigningDetails = real;
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getIsPreNUpgradeInner() {
        return this.mIsPreNUpgrade;
    }

    /* access modifiers changed from: package-private */
    public CompilerStats getCompilerStats() {
        return this.mCompilerStats;
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> getOptimizablePkgList() {
        List<PackageParser.Package> pkgs = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p);
                }
            }
        }
        return pkgs;
    }

    public int getSdkVersion() {
        return this.tSdkVersion;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void WritePackageRestrictions(int userId) {
        scheduleWritePackageRestrictionsLocked(userId);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void sendPreferredActivityChangedBroadcast(int userId) {
        if (!updateDefaultHomeNotLocked(userId)) {
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int getUidTargetSdkVersionLockedLPrEx(int userId) {
        return getUidTargetSdkVersionLockedLPr(userId);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void scheduleWriteSettingsInner() {
        synchronized (this.mPackages) {
            scheduleWriteSettingsLocked();
        }
    }
}
